{"ast":null,"code":"\"use strict\";\n\nconst validateNames = require(\"../helpers/validate-names\");\nconst DocumentType = require(\"../generated/DocumentType\");\nconst Document = require(\"../generated/Document\");\nconst {\n  HTML_NS,\n  SVG_NS\n} = require(\"../helpers/namespaces\");\nclass DOMImplementationImpl {\n  constructor(args, privateData) {\n    this._ownerDocument = privateData.ownerDocument;\n    this._features = Object.create(null);\n  }\n  hasFeature() {\n    return true;\n  }\n  createDocumentType(qualifiedName, publicId, systemId) {\n    validateNames.qname(qualifiedName);\n    return DocumentType.createImpl([], {\n      ownerDocument: this._ownerDocument,\n      name: qualifiedName,\n      publicId,\n      systemId\n    });\n  }\n  createDocument(namespace, qualifiedName, doctype) {\n    let contentType = \"application/xml\";\n    if (namespace === HTML_NS) {\n      contentType = \"application/xhtml+xml\";\n    } else if (namespace === SVG_NS) {\n      contentType = \"image/svg+xml\";\n    }\n    const document = Document.createImpl([], {\n      options: {\n        contentType,\n        parsingMode: \"xml\",\n        encoding: \"UTF-8\"\n      }\n    });\n    let element = null;\n    if (qualifiedName !== \"\") {\n      element = document.createElementNS(namespace, qualifiedName);\n    }\n    if (doctype !== null) {\n      document.appendChild(doctype);\n    }\n    if (element !== null) {\n      document.appendChild(element);\n    }\n    document.origin = this._ownerDocument.origin;\n    return document;\n  }\n  createHTMLDocument(title) {\n    // Let doc be a new document that is an HTML document.\n    // Set doc's content type to \"text/html\".\n    const document = Document.createImpl([], {\n      options: {\n        parsingMode: \"html\",\n        encoding: \"UTF-8\"\n      }\n    });\n\n    // Create a doctype, with \"html\" as its name and with its node document set\n    // to doc. Append the newly created node to doc.\n    const doctype = DocumentType.createImpl([], {\n      ownerDocument: this,\n      name: \"html\",\n      publicId: \"\",\n      systemId: \"\"\n    });\n    document.appendChild(doctype);\n\n    // Create an html element in the HTML namespace, and append it to doc.\n    const htmlElement = document.createElementNS(HTML_NS, \"html\");\n    document.appendChild(htmlElement);\n\n    // Create a head element in the HTML namespace, and append it to the html\n    // element created in the previous step.\n    const headElement = document.createElement(\"head\");\n    htmlElement.appendChild(headElement);\n\n    // If the title argument is not omitted:\n    if (title !== undefined) {\n      // Create a title element in the HTML namespace, and append it to the head\n      // element created in the previous step.\n      const titleElement = document.createElement(\"title\");\n      headElement.appendChild(titleElement);\n\n      // Create a Text node, set its data to title (which could be the empty\n      // string), and append it to the title element created in the previous step.\n      titleElement.appendChild(document.createTextNode(title));\n    }\n\n    // Create a body element in the HTML namespace, and append it to the html\n    // element created in the earlier step.\n    htmlElement.appendChild(document.createElement(\"body\"));\n\n    // doc's origin is an alias to the origin of the context object's associated\n    // document, and doc's effective script origin is an alias to the effective\n    // script origin of the context object's associated document.\n\n    return document;\n  }\n  _removeFeature(feature, version) {\n    feature = feature.toLowerCase();\n    if (this._features[feature]) {\n      if (version) {\n        const versions = this._features[feature];\n        for (let j = 0; j < versions.length; j++) {\n          if (versions[j] === version) {\n            versions.splice(j, 1);\n            return;\n          }\n        }\n      } else {\n        delete this._features[feature];\n      }\n    }\n  }\n  _addFeature(feature, version) {\n    feature = feature.toLowerCase();\n    if (version) {\n      if (!this._features[feature]) {\n        this._features[feature] = [];\n      }\n      if (version instanceof Array) {\n        Array.prototype.push.apply(this._features[feature], version);\n      } else {\n        this._features[feature].push(version);\n      }\n    } else {\n      this._features[feature] = [];\n    }\n  }\n  _hasFeature(feature, version) {\n    feature = feature ? feature.toLowerCase() : \"\";\n    const versions = this._features[feature] || false;\n    if (!version && versions.length && versions.length > 0) {\n      return true;\n    } else if (typeof versions === \"string\") {\n      return versions === version;\n    } else if (versions.indexOf && versions.length > 0) {\n      for (let i = 0; i < versions.length; i++) {\n        const found = versions[i] instanceof RegExp ? versions[i].test(version) : versions[i] === version;\n        if (found) {\n          return true;\n        }\n      }\n      return false;\n    }\n    return false;\n  }\n}\nmodule.exports = {\n  implementation: DOMImplementationImpl\n};","map":{"version":3,"names":["validateNames","require","DocumentType","Document","HTML_NS","SVG_NS","DOMImplementationImpl","constructor","args","privateData","_ownerDocument","ownerDocument","_features","Object","create","hasFeature","createDocumentType","qualifiedName","publicId","systemId","qname","createImpl","name","createDocument","namespace","doctype","contentType","document","options","parsingMode","encoding","element","createElementNS","appendChild","origin","createHTMLDocument","title","htmlElement","headElement","createElement","undefined","titleElement","createTextNode","_removeFeature","feature","version","toLowerCase","versions","j","length","splice","_addFeature","Array","prototype","push","apply","_hasFeature","indexOf","i","found","RegExp","test","module","exports","implementation"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/nodes/DOMImplementation-impl.js"],"sourcesContent":["\"use strict\";\n\nconst validateNames = require(\"../helpers/validate-names\");\nconst DocumentType = require(\"../generated/DocumentType\");\nconst Document = require(\"../generated/Document\");\nconst { HTML_NS, SVG_NS } = require(\"../helpers/namespaces\");\n\nclass DOMImplementationImpl {\n  constructor(args, privateData) {\n    this._ownerDocument = privateData.ownerDocument;\n    this._features = Object.create(null);\n  }\n\n  hasFeature() {\n    return true;\n  }\n\n  createDocumentType(qualifiedName, publicId, systemId) {\n    validateNames.qname(qualifiedName);\n\n    return DocumentType.createImpl([], {\n      ownerDocument: this._ownerDocument,\n      name: qualifiedName,\n      publicId,\n      systemId\n    });\n  }\n\n  createDocument(namespace, qualifiedName, doctype) {\n    let contentType = \"application/xml\";\n\n    if (namespace === HTML_NS) {\n      contentType = \"application/xhtml+xml\";\n    } else if (namespace === SVG_NS) {\n      contentType = \"image/svg+xml\";\n    }\n\n    const document = Document.createImpl([], {\n      options: { contentType, parsingMode: \"xml\", encoding: \"UTF-8\" }\n    });\n\n    let element = null;\n    if (qualifiedName !== \"\") {\n      element = document.createElementNS(namespace, qualifiedName);\n    }\n\n    if (doctype !== null) {\n      document.appendChild(doctype);\n    }\n\n    if (element !== null) {\n      document.appendChild(element);\n    }\n\n    document.origin = this._ownerDocument.origin;\n\n    return document;\n  }\n\n  createHTMLDocument(title) {\n    // Let doc be a new document that is an HTML document.\n    // Set doc's content type to \"text/html\".\n    const document = Document.createImpl([], {\n      options: { parsingMode: \"html\", encoding: \"UTF-8\" }\n    });\n\n    // Create a doctype, with \"html\" as its name and with its node document set\n    // to doc. Append the newly created node to doc.\n    const doctype = DocumentType.createImpl([], {\n      ownerDocument: this,\n      name: \"html\",\n      publicId: \"\",\n      systemId: \"\"\n    });\n\n    document.appendChild(doctype);\n\n    // Create an html element in the HTML namespace, and append it to doc.\n    const htmlElement = document.createElementNS(HTML_NS, \"html\");\n    document.appendChild(htmlElement);\n\n    // Create a head element in the HTML namespace, and append it to the html\n    // element created in the previous step.\n    const headElement = document.createElement(\"head\");\n    htmlElement.appendChild(headElement);\n\n    // If the title argument is not omitted:\n    if (title !== undefined) {\n      // Create a title element in the HTML namespace, and append it to the head\n      // element created in the previous step.\n      const titleElement = document.createElement(\"title\");\n      headElement.appendChild(titleElement);\n\n      // Create a Text node, set its data to title (which could be the empty\n      // string), and append it to the title element created in the previous step.\n      titleElement.appendChild(document.createTextNode(title));\n    }\n\n    // Create a body element in the HTML namespace, and append it to the html\n    // element created in the earlier step.\n    htmlElement.appendChild(document.createElement(\"body\"));\n\n    // doc's origin is an alias to the origin of the context object's associated\n    // document, and doc's effective script origin is an alias to the effective\n    // script origin of the context object's associated document.\n\n    return document;\n  }\n\n  _removeFeature(feature, version) {\n    feature = feature.toLowerCase();\n    if (this._features[feature]) {\n      if (version) {\n        const versions = this._features[feature];\n        for (let j = 0; j < versions.length; j++) {\n          if (versions[j] === version) {\n            versions.splice(j, 1);\n            return;\n          }\n        }\n      } else {\n        delete this._features[feature];\n      }\n    }\n  }\n\n  _addFeature(feature, version) {\n    feature = feature.toLowerCase();\n\n    if (version) {\n      if (!this._features[feature]) {\n        this._features[feature] = [];\n      }\n\n      if (version instanceof Array) {\n        Array.prototype.push.apply(this._features[feature], version);\n      } else {\n        this._features[feature].push(version);\n      }\n    } else {\n      this._features[feature] = [];\n    }\n  }\n\n  _hasFeature(feature, version) {\n    feature = feature ? feature.toLowerCase() : \"\";\n    const versions = this._features[feature] || false;\n\n    if (!version && versions.length && versions.length > 0) {\n      return true;\n    } else if (typeof versions === \"string\") {\n      return versions === version;\n    } else if (versions.indexOf && versions.length > 0) {\n      for (let i = 0; i < versions.length; i++) {\n        const found = versions[i] instanceof RegExp ? versions[i].test(version) : versions[i] === version;\n        if (found) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    return false;\n  }\n}\n\nmodule.exports = {\n  implementation: DOMImplementationImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}