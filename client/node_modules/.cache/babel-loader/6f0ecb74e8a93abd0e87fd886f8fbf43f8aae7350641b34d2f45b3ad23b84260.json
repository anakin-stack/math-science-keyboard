{"ast":null,"code":"\"use strict\";\n\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst {\n  filter,\n  FILTER_ACCEPT\n} = require(\"./helpers\");\nexports.implementation = class NodeIteratorImpl {\n  constructor(constructorArgs, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true;\n\n    // This is used to deactive the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n    this._working = true;\n    this._workingNodeIteratorsMax = privateData.workingNodeIteratorsMax;\n  }\n  get referenceNode() {\n    this._throwIfNotWorking();\n    return this._referenceNode;\n  }\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n    return this._pointerBeforeReferenceNode;\n  }\n  nextNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"next\");\n  }\n  previousNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"previous\");\n  }\n  detach() {\n    // Intentionally do nothing, per spec.\n  }\n\n  // Called by Documents.\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, {\n        skipChildren: true\n      });\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n        candidateForNext = domSymbolTree.following(candidateForNext, {\n          skipChildren: true\n        });\n      }\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n      this._pointerBeforeReferenceNode = false;\n    }\n    const {\n      previousSibling\n    } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ? toBeRemovedNode.parentNode : domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  }\n\n  // Only called by getters and methods that are affected by the pre-removing steps\n  _throwIfNotWorking() {\n    if (!this._working) {\n      throw Error(`This NodeIterator is no longer working. More than ${this._workingNodeIteratorsMax} iterators are ` + `being used concurrently. You can increase the 'concurrentNodeIterators' option to make this error go away.`);\n    }\n  }\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, {\n            root: this.root\n          });\n          if (!node) {\n            return null;\n          }\n        }\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, {\n            root: this.root\n          });\n          if (!node) {\n            return null;\n          }\n        }\n        beforeNode = true;\n      }\n      const result = filter(this, node);\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n};","map":{"version":3,"names":["domSymbolTree","require","filter","FILTER_ACCEPT","exports","implementation","NodeIteratorImpl","constructor","constructorArgs","privateData","_active","root","whatToShow","_referenceNode","_pointerBeforeReferenceNode","_working","_workingNodeIteratorsMax","workingNodeIteratorsMax","referenceNode","_throwIfNotWorking","pointerBeforeReferenceNode","nextNode","_traverse","previousNode","detach","_preRemovingSteps","toBeRemovedNode","contains","next","candidateForNext","following","skipChildren","previousSibling","parentNode","lastInclusiveDescendant","Error","direction","node","beforeNode","preceding","result"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/traversal/NodeIterator-impl.js"],"sourcesContent":["\"use strict\";\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { filter, FILTER_ACCEPT } = require(\"./helpers\");\n\nexports.implementation = class NodeIteratorImpl {\n  constructor(constructorArgs, privateData) {\n    this._active = false;\n    this.root = privateData.root;\n    this.whatToShow = privateData.whatToShow;\n    this.filter = privateData.filter;\n\n    this._referenceNode = this.root;\n    this._pointerBeforeReferenceNode = true;\n\n    // This is used to deactive the NodeIterator if there are too many working in a Document at the same time.\n    // Without weak references, a JS implementation of NodeIterator will leak, since we can't know when to clean it up.\n    // This ensures we force a clean up of those beyond some maximum (specified by the Document).\n    this._working = true;\n    this._workingNodeIteratorsMax = privateData.workingNodeIteratorsMax;\n  }\n\n  get referenceNode() {\n    this._throwIfNotWorking();\n    return this._referenceNode;\n  }\n\n  get pointerBeforeReferenceNode() {\n    this._throwIfNotWorking();\n    return this._pointerBeforeReferenceNode;\n  }\n\n  nextNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"next\");\n  }\n\n  previousNode() {\n    this._throwIfNotWorking();\n    return this._traverse(\"previous\");\n  }\n\n  detach() {\n    // Intentionally do nothing, per spec.\n  }\n\n  // Called by Documents.\n  _preRemovingSteps(toBeRemovedNode) {\n    // Second clause is https://github.com/whatwg/dom/issues/496\n    if (!toBeRemovedNode.contains(this._referenceNode) || toBeRemovedNode === this.root) {\n      return;\n    }\n\n    if (this._pointerBeforeReferenceNode) {\n      let next = null;\n      let candidateForNext = domSymbolTree.following(toBeRemovedNode, { skipChildren: true });\n      while (candidateForNext !== null) {\n        if (this.root.contains(candidateForNext)) {\n          next = candidateForNext;\n          break;\n        }\n        candidateForNext = domSymbolTree.following(candidateForNext, { skipChildren: true });\n      }\n\n      if (next !== null) {\n        this._referenceNode = next;\n        return;\n      }\n\n      this._pointerBeforeReferenceNode = false;\n    }\n\n    const { previousSibling } = toBeRemovedNode;\n    this._referenceNode = previousSibling === null ?\n                          toBeRemovedNode.parentNode :\n                          domSymbolTree.lastInclusiveDescendant(toBeRemovedNode.previousSibling);\n  }\n\n  // Only called by getters and methods that are affected by the pre-removing steps\n  _throwIfNotWorking() {\n    if (!this._working) {\n      throw Error(`This NodeIterator is no longer working. More than ${this._workingNodeIteratorsMax} iterators are ` +\n        `being used concurrently. You can increase the 'concurrentNodeIterators' option to make this error go away.`);\n    }\n  }\n\n  _traverse(direction) {\n    let node = this._referenceNode;\n    let beforeNode = this._pointerBeforeReferenceNode;\n\n    while (true) {\n      if (direction === \"next\") {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else if (direction === \"previous\") {\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n\n      const result = filter(this, node);\n      if (result === FILTER_ACCEPT) {\n        break;\n      }\n    }\n\n    this._referenceNode = node;\n    this._pointerBeforeReferenceNode = beforeNode;\n    return node;\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}