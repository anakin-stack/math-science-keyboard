{"ast":null,"code":"\"use strict\";\n\nconst DOMException = require(\"domexception\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst idlUtils = require(\"../generated/utils\");\nconst Event = require(\"../generated/Event\").interface;\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n    if (callback === null) {\n      return;\n    }\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n    if (!this._eventListeners[type]) {\n      return;\n    }\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n    eventImpl.isTrusted = false;\n    return this._dispatch(eventImpl);\n  }\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n    const eventPath = [];\n    let {\n      target\n    } = eventImpl;\n    let targetParent = domSymbolTree.parent(target);\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n    eventImpl.eventPhase = Event.AT_TARGET;\n    if (!eventImpl._stopPropagationFlag) {\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\nmodule.exports = {\n  implementation: EventTargetImpl\n};\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || wrapper && (wrapper._document || wrapper._ownerDocument);\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n    const listener = handlers[i];\n    const {\n      capture,\n      once /* , passive */\n    } = listener.options;\n    if (listeners.indexOf(listener) === -1 || eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture || eventImpl.eventPhase === Event.BUBBLING_PHASE && capture) {\n      continue;\n    }\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n  return returnValue;\n}","map":{"version":3,"names":["DOMException","require","reportException","domSymbolTree","idlUtils","Event","interface","EventTargetImpl","constructor","_eventListeners","Object","create","addEventListener","type","callback","options","undefined","TypeError","normalizeEventHandlerOptions","i","length","listener","capture","push","removeEventListener","splice","dispatchEvent","eventImpl","_dispatchFlag","_initializedFlag","eventPhase","NONE","isTrusted","_dispatch","targetOverride","target","eventPath","targetParent","parent","_defaultView","implForWrapper","CAPTURING_PHASE","_stopPropagationFlag","object","objectImpl","eventListeners","invokeEventListeners","AT_TARGET","bubbles","BUBBLING_PHASE","_stopImmediatePropagationFlag","currentTarget","_canceledFlag","module","exports","implementation","listeners","wrapper","wrapperForImpl","document","_ownerDocument","_document","name","handlers","slice","once","indexOf","handleEvent","call","e","window","defaultBoolKeys","returnValue","Boolean","filter","k","key"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/events/EventTarget-impl.js"],"sourcesContent":["\"use strict\";\nconst DOMException = require(\"domexception\");\nconst reportException = require(\"../helpers/runtime-script-errors\");\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst idlUtils = require(\"../generated/utils\");\n\nconst Event = require(\"../generated/Event\").interface;\n\nclass EventTargetImpl {\n  constructor() {\n    this._eventListeners = Object.create(null);\n  }\n\n  addEventListener(type, callback, options) {\n    // webidl2js currently can't handle neither optional arguments nor callback interfaces\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\", \"once\"]);\n\n    if (callback === null) {\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      this._eventListeners[type] = [];\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.options.capture === options.capture && listener.callback === callback) {\n        return;\n      }\n    }\n\n    this._eventListeners[type].push({\n      callback,\n      options\n    });\n  }\n\n  removeEventListener(type, callback, options) {\n    if (callback === undefined || callback === null) {\n      callback = null;\n    } else if (typeof callback !== \"object\" && typeof callback !== \"function\") {\n      throw new TypeError(\"Only undefined, null, an object, or a function are allowed for the callback parameter\");\n    }\n\n    options = normalizeEventHandlerOptions(options, [\"capture\"]);\n\n    if (callback === null) {\n      // Optimization, not in the spec.\n      return;\n    }\n\n    if (!this._eventListeners[type]) {\n      return;\n    }\n\n    for (let i = 0; i < this._eventListeners[type].length; ++i) {\n      const listener = this._eventListeners[type][i];\n      if (listener.callback === callback && listener.options.capture === options.capture) {\n        this._eventListeners[type].splice(i, 1);\n        break;\n      }\n    }\n  }\n\n  dispatchEvent(eventImpl) {\n    if (eventImpl._dispatchFlag || !eventImpl._initializedFlag) {\n      throw new DOMException(\"Tried to dispatch an uninitialized event\", \"InvalidStateError\");\n    }\n    if (eventImpl.eventPhase !== Event.NONE) {\n      throw new DOMException(\"Tried to dispatch a dispatching event\", \"InvalidStateError\");\n    }\n\n    eventImpl.isTrusted = false;\n\n    return this._dispatch(eventImpl);\n  }\n\n  _dispatch(eventImpl, targetOverride) {\n    eventImpl._dispatchFlag = true;\n    eventImpl.target = targetOverride || this;\n\n    const eventPath = [];\n    let { target } = eventImpl;\n    let targetParent = domSymbolTree.parent(target);\n    while (targetParent) {\n      eventPath.push(targetParent);\n      target = targetParent;\n      targetParent = domSymbolTree.parent(targetParent);\n    }\n    if (eventImpl.type !== \"load\" && target._defaultView) {\n      // https://html.spec.whatwg.org/#events-and-the-window-object\n      eventPath.push(idlUtils.implForWrapper(target._defaultView));\n    }\n\n    eventImpl.eventPhase = Event.CAPTURING_PHASE;\n    for (let i = eventPath.length - 1; i >= 0; --i) {\n      if (eventImpl._stopPropagationFlag) {\n        break;\n      }\n\n      const object = eventPath[i];\n      const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n      const eventListeners = objectImpl._eventListeners[eventImpl.type];\n      invokeEventListeners(eventListeners, object, eventImpl);\n    }\n\n    eventImpl.eventPhase = Event.AT_TARGET;\n\n    if (!eventImpl._stopPropagationFlag) {\n      if (this._eventListeners[eventImpl.type]) {\n        const eventListeners = this._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, eventImpl.target, eventImpl);\n      }\n    }\n\n    if (eventImpl.bubbles) {\n      eventImpl.eventPhase = Event.BUBBLING_PHASE;\n      for (let i = 0; i < eventPath.length; ++i) {\n        if (eventImpl._stopPropagationFlag) {\n          break;\n        }\n\n        const object = eventPath[i];\n        const objectImpl = idlUtils.implForWrapper(object) || object; // window :(\n        const eventListeners = objectImpl._eventListeners[eventImpl.type];\n        invokeEventListeners(eventListeners, object, eventImpl);\n      }\n    }\n\n    eventImpl._dispatchFlag = false;\n    eventImpl._stopPropagationFlag = false;\n    eventImpl._stopImmediatePropagationFlag = false;\n    eventImpl.eventPhase = Event.NONE;\n    eventImpl.currentTarget = null;\n    return !eventImpl._canceledFlag;\n  }\n}\n\nmodule.exports = {\n  implementation: EventTargetImpl\n};\n\nfunction invokeEventListeners(listeners, target, eventImpl) {\n  const wrapper = idlUtils.wrapperForImpl(target);\n  const document = target._ownerDocument || (wrapper && (wrapper._document || wrapper._ownerDocument));\n  // Will be falsy for windows that have closed\n  if (!document) {\n    return;\n  }\n\n  // workaround for events emitted on window (window-proxy)\n  // the wrapper is the root window instance, but we only want to expose the vm proxy at all times\n  if (wrapper._document && wrapper.constructor.name === \"Window\") {\n    target = idlUtils.implForWrapper(wrapper._document)._defaultView;\n  }\n  eventImpl.currentTarget = target;\n  if (!listeners) {\n    return;\n  }\n\n  const handlers = listeners.slice();\n  for (let i = 0; i < handlers.length; ++i) {\n    if (eventImpl._stopImmediatePropagationFlag) {\n      return;\n    }\n\n    const listener = handlers[i];\n    const { capture, once/* , passive */ } = listener.options;\n\n    if (listeners.indexOf(listener) === -1 ||\n        (eventImpl.eventPhase === Event.CAPTURING_PHASE && !capture) ||\n        (eventImpl.eventPhase === Event.BUBBLING_PHASE && capture)) {\n      continue;\n    }\n\n    if (once) {\n      listeners.splice(listeners.indexOf(listener), 1);\n    }\n\n    try {\n      if (typeof listener.callback === \"object\") {\n        if (typeof listener.callback.handleEvent === \"function\") {\n          listener.callback.handleEvent(idlUtils.wrapperForImpl(eventImpl));\n        }\n      } else {\n        listener.callback.call(idlUtils.wrapperForImpl(eventImpl.currentTarget), idlUtils.wrapperForImpl(eventImpl));\n      }\n    } catch (e) {\n      let window = null;\n      if (wrapper && wrapper._document) {\n        // Triggered by Window\n        window = wrapper;\n      } else if (target._ownerDocument) {\n        // Triggered by most webidl2js'ed instances\n        window = target._ownerDocument._defaultView;\n      } else if (wrapper._ownerDocument) {\n        // Currently triggered by XHR and some other non-webidl2js things\n        window = wrapper._ownerDocument._defaultView;\n      }\n\n      if (window) {\n        reportException(window, e);\n      }\n      // Errors in window-less documents just get swallowed... can you think of anything better?\n    }\n  }\n}\n\n/**\n * Normalize the event listeners options argument in order to get always a valid options object\n * @param   {Object} options         - user defined options\n * @param   {Array} defaultBoolKeys  - boolean properties that should belong to the options object\n * @returns {Object} object containing at least the \"defaultBoolKeys\"\n */\nfunction normalizeEventHandlerOptions(options, defaultBoolKeys) {\n  const returnValue = {};\n\n  // no need to go further here\n  if (typeof options === \"boolean\" || options === null || typeof options === \"undefined\") {\n    returnValue.capture = Boolean(options);\n    return returnValue;\n  }\n\n  // non objects options so we typecast its value as \"capture\" value\n  if (typeof options !== \"object\") {\n    returnValue.capture = Boolean(options);\n    // at this point we don't need to loop the \"capture\" key anymore\n    defaultBoolKeys = defaultBoolKeys.filter(k => k !== \"capture\");\n  }\n\n  for (const key of defaultBoolKeys) {\n    returnValue[key] = Boolean(options[key]);\n  }\n\n  return returnValue;\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}