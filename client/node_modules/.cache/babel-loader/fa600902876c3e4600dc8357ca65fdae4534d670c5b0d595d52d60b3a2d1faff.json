{"ast":null,"code":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst isHTMLOptionElement = require(\"./HTMLOptionElement.js\").is;\nconst isHTMLOptGroupElement = require(\"./HTMLOptGroupElement.js\").is;\nconst isHTMLElement = require(\"./HTMLElement.js\").is;\nconst convertHTMLOptionElement = require(\"./HTMLOptionElement.js\").convert;\nconst impl = utils.implSymbol;\nconst HTMLCollection = require(\"./HTMLCollection.js\");\nfunction HTMLOptionsCollection() {\n  throw new TypeError(\"Illegal constructor\");\n}\nObject.setPrototypeOf(HTMLOptionsCollection.prototype, HTMLCollection.interface.prototype);\nObject.setPrototypeOf(HTMLOptionsCollection, HTMLCollection.interface);\nObject.defineProperty(HTMLOptionsCollection, \"prototype\", {\n  value: HTMLOptionsCollection.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nObject.defineProperty(HTMLOptionsCollection.prototype, Symbol.iterator, {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n  value: Array.prototype[Symbol.iterator]\n});\nHTMLOptionsCollection.prototype.add = function add(element) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'add' on 'HTMLOptionsCollection': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  {\n    let curArg = arguments[0];\n    if (isHTMLOptionElement(curArg) || isHTMLOptGroupElement(curArg)) {\n      curArg = utils.implForWrapper(curArg);\n    } else {\n      throw new TypeError(\"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 1\" + \" is not of any supported type.\");\n    }\n    args.push(curArg);\n  }\n  {\n    let curArg = arguments[1];\n    if (curArg !== undefined) {\n      if (curArg === null || curArg === undefined) {\n        curArg = null;\n      } else {\n        if (isHTMLElement(curArg)) {\n          curArg = utils.implForWrapper(curArg);\n        } else if (typeof curArg === \"number\") {\n          curArg = conversions[\"long\"](curArg, {\n            context: \"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2\"\n          });\n        } else {\n          curArg = conversions[\"long\"](curArg, {\n            context: \"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2\"\n          });\n        }\n      }\n    } else {\n      curArg = null;\n    }\n    args.push(curArg);\n  }\n  return this[impl].add(...args);\n};\nHTMLOptionsCollection.prototype.remove = function remove(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'remove' on 'HTMLOptionsCollection': 1 argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  {\n    let curArg = arguments[0];\n    curArg = conversions[\"long\"](curArg, {\n      context: \"Failed to execute 'remove' on 'HTMLOptionsCollection': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return this[impl].remove(...args);\n};\nObject.defineProperty(HTMLOptionsCollection.prototype, \"length\", {\n  get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    return this[impl][\"length\"];\n  },\n  set(V) {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    V = conversions[\"unsigned long\"](V, {\n      context: \"Failed to set the 'length' property on 'HTMLOptionsCollection': The provided value\"\n    });\n    this[impl][\"length\"] = V;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(HTMLOptionsCollection.prototype, \"selectedIndex\", {\n  get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    return this[impl][\"selectedIndex\"];\n  },\n  set(V) {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    V = conversions[\"long\"](V, {\n      context: \"Failed to set the 'selectedIndex' property on 'HTMLOptionsCollection': The provided value\"\n    });\n    this[impl][\"selectedIndex\"] = V;\n  },\n  enumerable: true,\n  configurable: true\n});\nObject.defineProperty(HTMLOptionsCollection.prototype, Symbol.toStringTag, {\n  value: \"HTMLOptionsCollection\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nconst iface = {\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\n  // implementing this mixin interface.\n  _mixedIntoPredicates: [],\n  is(obj) {\n    if (obj) {\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(obj)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n      const wrapper = utils.wrapperForImpl(obj);\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(wrapper)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj) {\n    let {\n      context = \"The provided value\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'HTMLOptionsCollection'.`);\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionsCollection.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionsCollection.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLCollection._internalSetup(obj);\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n    this._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    obj = new Proxy(obj, {\n      get(target, P, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.get(target, P, receiver);\n        }\n        const desc = this.getOwnPropertyDescriptor(target, P);\n        if (desc === undefined) {\n          const parent = Object.getPrototypeOf(target);\n          if (parent === null) {\n            return undefined;\n          }\n          return Reflect.get(target, P, receiver);\n        }\n        if (!desc.get && !desc.set) {\n          return desc.value;\n        }\n        const getter = desc.get;\n        if (getter === undefined) {\n          return undefined;\n        }\n        return Reflect.apply(getter, receiver, []);\n      },\n      has(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.has(target, P);\n        }\n        const desc = this.getOwnPropertyDescriptor(target, P);\n        if (desc !== undefined) {\n          return true;\n        }\n        const parent = Object.getPrototypeOf(target);\n        if (parent !== null) {\n          return Reflect.has(parent, P);\n        }\n        return false;\n      },\n      ownKeys(target) {\n        const keys = new Set();\n        for (const key of target[impl][utils.supportedPropertyIndices]) {\n          keys.add(`${key}`);\n        }\n        for (const key of target[impl][utils.supportedPropertyNames]) {\n          if (!(key in target)) {\n            keys.add(`${key}`);\n          }\n        }\n        for (const key of Reflect.ownKeys(target)) {\n          keys.add(key);\n        }\n        return [...keys];\n      },\n      getOwnPropertyDescriptor(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.getOwnPropertyDescriptor(target, P);\n        }\n        let ignoreNamedProps = false;\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          const indexedValue = target[impl].item(index);\n          if (indexedValue !== null) {\n            return {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(indexedValue)\n            };\n          }\n          ignoreNamedProps = true;\n        }\n        const namedValue = target[impl].namedItem(P);\n        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {\n          return {\n            writable: false,\n            enumerable: true,\n            configurable: true,\n            value: utils.tryWrapperForImpl(namedValue)\n          };\n        }\n        return Reflect.getOwnPropertyDescriptor(target, P);\n      },\n      set(target, P, V, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.set(target, P, V, receiver);\n        }\n        if (target === receiver) {\n          if (utils.isArrayIndexPropName(P)) {\n            const index = P >>> 0;\n            let indexedValue = V;\n            if (indexedValue === null || indexedValue === undefined) {\n              indexedValue = null;\n            } else {\n              indexedValue = convertHTMLOptionElement(indexedValue, {\n                context: \"Failed to set the \" + index + \" property on 'HTMLOptionsCollection': The provided value\"\n              });\n            }\n            const creating = !(target[impl].item(index) !== null);\n            if (creating) {\n              target[impl][utils.indexedSetNew](index, indexedValue);\n            } else {\n              target[impl][utils.indexedSetExisting](index, indexedValue);\n            }\n            return true;\n          }\n          typeof P === \"string\" && !utils.isArrayIndexPropName(P);\n        }\n        let ownDesc;\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          const indexedValue = target[impl].item(index);\n          if (indexedValue !== null) {\n            ownDesc = {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(indexedValue)\n            };\n          }\n        }\n        if (ownDesc === undefined) {\n          ownDesc = Reflect.getOwnPropertyDescriptor(target, P);\n        }\n        if (ownDesc === undefined) {\n          const parent = Reflect.getPrototypeOf(target);\n          if (parent !== null) {\n            return Reflect.set(parent, P, V, receiver);\n          }\n          ownDesc = {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: undefined\n          };\n        }\n        if (!ownDesc.writable) {\n          return false;\n        }\n        if (!utils.isObject(receiver)) {\n          return false;\n        }\n        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);\n        let valueDesc;\n        if (existingDesc !== undefined) {\n          if (existingDesc.get || existingDesc.set) {\n            return false;\n          }\n          if (!existingDesc.writable) {\n            return false;\n          }\n          valueDesc = {\n            value: V\n          };\n        } else {\n          valueDesc = {\n            writable: true,\n            enumerable: true,\n            configurable: true,\n            value: V\n          };\n        }\n        return Reflect.defineProperty(receiver, P, valueDesc);\n      },\n      defineProperty(target, P, desc) {\n        if (typeof P === \"symbol\") {\n          return Reflect.defineProperty(target, P, desc);\n        }\n        if (utils.isArrayIndexPropName(P)) {\n          if (desc.get || desc.set) {\n            return false;\n          }\n          const index = P >>> 0;\n          let indexedValue = desc.value;\n          if (indexedValue === null || indexedValue === undefined) {\n            indexedValue = null;\n          } else {\n            indexedValue = convertHTMLOptionElement(indexedValue, {\n              context: \"Failed to set the \" + index + \" property on 'HTMLOptionsCollection': The provided value\"\n            });\n          }\n          const creating = !(target[impl].item(index) !== null);\n          if (creating) {\n            target[impl][utils.indexedSetNew](index, indexedValue);\n          } else {\n            target[impl][utils.indexedSetExisting](index, indexedValue);\n          }\n          return true;\n        }\n        if (!utils.hasOwn(target, P)) {\n          const creating = !(target[impl].namedItem(P) !== null);\n          if (!creating) {\n            return false;\n          }\n        }\n        return Reflect.defineProperty(target, P, desc);\n      },\n      deleteProperty(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.deleteProperty(target, P);\n        }\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          return !(target[impl].item(index) !== null);\n        }\n        if (target[impl].namedItem(P) !== null && !(P in target)) {\n          return false;\n        }\n        return Reflect.deleteProperty(target, P);\n      },\n      preventExtensions() {\n        return false;\n      }\n    });\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n  interface: HTMLOptionsCollection,\n  expose: {\n    Window: {\n      HTMLOptionsCollection\n    }\n  }\n}; // iface\nmodule.exports = iface;\nconst Impl = require(\"../nodes/HTMLOptionsCollection-impl.js\");","map":{"version":3,"names":["conversions","require","utils","isHTMLOptionElement","is","isHTMLOptGroupElement","isHTMLElement","convertHTMLOptionElement","convert","impl","implSymbol","HTMLCollection","HTMLOptionsCollection","TypeError","Object","setPrototypeOf","prototype","interface","defineProperty","value","writable","enumerable","configurable","Symbol","iterator","Array","add","element","module","exports","arguments","length","args","curArg","implForWrapper","push","undefined","context","remove","index","get","set","V","toStringTag","iface","_mixedIntoPredicates","obj","hasOwn","Impl","implementation","isMixedInto","isImpl","wrapper","wrapperForImpl","create","constructorArgs","privateData","setup","createImpl","_internalSetup","Proxy","target","P","receiver","Reflect","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","apply","has","ownKeys","keys","Set","key","supportedPropertyIndices","supportedPropertyNames","ignoreNamedProps","isArrayIndexPropName","indexedValue","item","tryWrapperForImpl","namedValue","namedItem","creating","indexedSetNew","indexedSetExisting","ownDesc","isObject","existingDesc","valueDesc","deleteProperty","preventExtensions","wrapperSymbol","init","expose","Window"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/generated/HTMLOptionsCollection.js"],"sourcesContent":["\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst isHTMLOptionElement = require(\"./HTMLOptionElement.js\").is;\nconst isHTMLOptGroupElement = require(\"./HTMLOptGroupElement.js\").is;\nconst isHTMLElement = require(\"./HTMLElement.js\").is;\nconst convertHTMLOptionElement = require(\"./HTMLOptionElement.js\").convert;\nconst impl = utils.implSymbol;\nconst HTMLCollection = require(\"./HTMLCollection.js\");\n\nfunction HTMLOptionsCollection() {\n  throw new TypeError(\"Illegal constructor\");\n}\n\nObject.setPrototypeOf(HTMLOptionsCollection.prototype, HTMLCollection.interface.prototype);\nObject.setPrototypeOf(HTMLOptionsCollection, HTMLCollection.interface);\n\nObject.defineProperty(HTMLOptionsCollection, \"prototype\", {\n  value: HTMLOptionsCollection.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nObject.defineProperty(HTMLOptionsCollection.prototype, Symbol.iterator, {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n  value: Array.prototype[Symbol.iterator]\n});\n\nHTMLOptionsCollection.prototype.add = function add(element) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'add' on 'HTMLOptionsCollection': 1 argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n  const args = [];\n  {\n    let curArg = arguments[0];\n    if (isHTMLOptionElement(curArg) || isHTMLOptGroupElement(curArg)) {\n      curArg = utils.implForWrapper(curArg);\n    } else {\n      throw new TypeError(\n        \"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 1\" + \" is not of any supported type.\"\n      );\n    }\n    args.push(curArg);\n  }\n  {\n    let curArg = arguments[1];\n    if (curArg !== undefined) {\n      if (curArg === null || curArg === undefined) {\n        curArg = null;\n      } else {\n        if (isHTMLElement(curArg)) {\n          curArg = utils.implForWrapper(curArg);\n        } else if (typeof curArg === \"number\") {\n          curArg = conversions[\"long\"](curArg, {\n            context: \"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2\"\n          });\n        } else {\n          curArg = conversions[\"long\"](curArg, {\n            context: \"Failed to execute 'add' on 'HTMLOptionsCollection': parameter 2\"\n          });\n        }\n      }\n    } else {\n      curArg = null;\n    }\n    args.push(curArg);\n  }\n  return this[impl].add(...args);\n};\n\nHTMLOptionsCollection.prototype.remove = function remove(index) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'remove' on 'HTMLOptionsCollection': 1 argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n  const args = [];\n  {\n    let curArg = arguments[0];\n    curArg = conversions[\"long\"](curArg, {\n      context: \"Failed to execute 'remove' on 'HTMLOptionsCollection': parameter 1\"\n    });\n    args.push(curArg);\n  }\n  return this[impl].remove(...args);\n};\n\nObject.defineProperty(HTMLOptionsCollection.prototype, \"length\", {\n  get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    return this[impl][\"length\"];\n  },\n\n  set(V) {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    V = conversions[\"unsigned long\"](V, {\n      context: \"Failed to set the 'length' property on 'HTMLOptionsCollection': The provided value\"\n    });\n\n    this[impl][\"length\"] = V;\n  },\n\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionsCollection.prototype, \"selectedIndex\", {\n  get() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    return this[impl][\"selectedIndex\"];\n  },\n\n  set(V) {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n\n    V = conversions[\"long\"](V, {\n      context: \"Failed to set the 'selectedIndex' property on 'HTMLOptionsCollection': The provided value\"\n    });\n\n    this[impl][\"selectedIndex\"] = V;\n  },\n\n  enumerable: true,\n  configurable: true\n});\n\nObject.defineProperty(HTMLOptionsCollection.prototype, Symbol.toStringTag, {\n  value: \"HTMLOptionsCollection\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nconst iface = {\n  // When an interface-module that implements this interface as a mixin is loaded, it will append its own `.is()`\n  // method into this array. It allows objects that directly implements *those* interfaces to be recognized as\n  // implementing this mixin interface.\n  _mixedIntoPredicates: [],\n  is(obj) {\n    if (obj) {\n      if (utils.hasOwn(obj, impl) && obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(obj)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (const isMixedInto of module.exports._mixedIntoPredicates) {\n        if (isMixedInto(wrapper)) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj, { context = \"The provided value\" } = {}) {\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'HTMLOptionsCollection'.`);\n  },\n\n  create(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionsCollection.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(HTMLOptionsCollection.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {\n    HTMLCollection._internalSetup(obj);\n  },\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n\n    obj = new Proxy(obj, {\n      get(target, P, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.get(target, P, receiver);\n        }\n        const desc = this.getOwnPropertyDescriptor(target, P);\n        if (desc === undefined) {\n          const parent = Object.getPrototypeOf(target);\n          if (parent === null) {\n            return undefined;\n          }\n          return Reflect.get(target, P, receiver);\n        }\n        if (!desc.get && !desc.set) {\n          return desc.value;\n        }\n        const getter = desc.get;\n        if (getter === undefined) {\n          return undefined;\n        }\n        return Reflect.apply(getter, receiver, []);\n      },\n\n      has(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.has(target, P);\n        }\n        const desc = this.getOwnPropertyDescriptor(target, P);\n        if (desc !== undefined) {\n          return true;\n        }\n        const parent = Object.getPrototypeOf(target);\n        if (parent !== null) {\n          return Reflect.has(parent, P);\n        }\n        return false;\n      },\n\n      ownKeys(target) {\n        const keys = new Set();\n\n        for (const key of target[impl][utils.supportedPropertyIndices]) {\n          keys.add(`${key}`);\n        }\n\n        for (const key of target[impl][utils.supportedPropertyNames]) {\n          if (!(key in target)) {\n            keys.add(`${key}`);\n          }\n        }\n\n        for (const key of Reflect.ownKeys(target)) {\n          keys.add(key);\n        }\n        return [...keys];\n      },\n\n      getOwnPropertyDescriptor(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.getOwnPropertyDescriptor(target, P);\n        }\n        let ignoreNamedProps = false;\n\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          const indexedValue = target[impl].item(index);\n          if (indexedValue !== null) {\n            return {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(indexedValue)\n            };\n          }\n          ignoreNamedProps = true;\n        }\n\n        const namedValue = target[impl].namedItem(P);\n\n        if (namedValue !== null && !(P in target) && !ignoreNamedProps) {\n          return {\n            writable: false,\n            enumerable: true,\n            configurable: true,\n            value: utils.tryWrapperForImpl(namedValue)\n          };\n        }\n\n        return Reflect.getOwnPropertyDescriptor(target, P);\n      },\n\n      set(target, P, V, receiver) {\n        if (typeof P === \"symbol\") {\n          return Reflect.set(target, P, V, receiver);\n        }\n        if (target === receiver) {\n          if (utils.isArrayIndexPropName(P)) {\n            const index = P >>> 0;\n            let indexedValue = V;\n\n            if (indexedValue === null || indexedValue === undefined) {\n              indexedValue = null;\n            } else {\n              indexedValue = convertHTMLOptionElement(indexedValue, {\n                context: \"Failed to set the \" + index + \" property on 'HTMLOptionsCollection': The provided value\"\n              });\n            }\n\n            const creating = !(target[impl].item(index) !== null);\n            if (creating) {\n              target[impl][utils.indexedSetNew](index, indexedValue);\n            } else {\n              target[impl][utils.indexedSetExisting](index, indexedValue);\n            }\n\n            return true;\n          }\n\n          typeof P === \"string\" && !utils.isArrayIndexPropName(P);\n        }\n        let ownDesc;\n\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          const indexedValue = target[impl].item(index);\n          if (indexedValue !== null) {\n            ownDesc = {\n              writable: true,\n              enumerable: true,\n              configurable: true,\n              value: utils.tryWrapperForImpl(indexedValue)\n            };\n          }\n        }\n\n        if (ownDesc === undefined) {\n          ownDesc = Reflect.getOwnPropertyDescriptor(target, P);\n        }\n        if (ownDesc === undefined) {\n          const parent = Reflect.getPrototypeOf(target);\n          if (parent !== null) {\n            return Reflect.set(parent, P, V, receiver);\n          }\n          ownDesc = { writable: true, enumerable: true, configurable: true, value: undefined };\n        }\n        if (!ownDesc.writable) {\n          return false;\n        }\n        if (!utils.isObject(receiver)) {\n          return false;\n        }\n        const existingDesc = Reflect.getOwnPropertyDescriptor(receiver, P);\n        let valueDesc;\n        if (existingDesc !== undefined) {\n          if (existingDesc.get || existingDesc.set) {\n            return false;\n          }\n          if (!existingDesc.writable) {\n            return false;\n          }\n          valueDesc = { value: V };\n        } else {\n          valueDesc = { writable: true, enumerable: true, configurable: true, value: V };\n        }\n        return Reflect.defineProperty(receiver, P, valueDesc);\n      },\n\n      defineProperty(target, P, desc) {\n        if (typeof P === \"symbol\") {\n          return Reflect.defineProperty(target, P, desc);\n        }\n\n        if (utils.isArrayIndexPropName(P)) {\n          if (desc.get || desc.set) {\n            return false;\n          }\n\n          const index = P >>> 0;\n          let indexedValue = desc.value;\n\n          if (indexedValue === null || indexedValue === undefined) {\n            indexedValue = null;\n          } else {\n            indexedValue = convertHTMLOptionElement(indexedValue, {\n              context: \"Failed to set the \" + index + \" property on 'HTMLOptionsCollection': The provided value\"\n            });\n          }\n\n          const creating = !(target[impl].item(index) !== null);\n          if (creating) {\n            target[impl][utils.indexedSetNew](index, indexedValue);\n          } else {\n            target[impl][utils.indexedSetExisting](index, indexedValue);\n          }\n\n          return true;\n        }\n        if (!utils.hasOwn(target, P)) {\n          const creating = !(target[impl].namedItem(P) !== null);\n          if (!creating) {\n            return false;\n          }\n        }\n        return Reflect.defineProperty(target, P, desc);\n      },\n\n      deleteProperty(target, P) {\n        if (typeof P === \"symbol\") {\n          return Reflect.deleteProperty(target, P);\n        }\n\n        if (utils.isArrayIndexPropName(P)) {\n          const index = P >>> 0;\n          return !(target[impl].item(index) !== null);\n        }\n\n        if (target[impl].namedItem(P) !== null && !(P in target)) {\n          return false;\n        }\n\n        return Reflect.deleteProperty(target, P);\n      },\n\n      preventExtensions() {\n        return false;\n      }\n    });\n\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n  interface: HTMLOptionsCollection,\n  expose: {\n    Window: { HTMLOptionsCollection }\n  }\n}; // iface\nmodule.exports = iface;\n\nconst Impl = require(\"../nodes/HTMLOptionsCollection-impl.js\");\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}