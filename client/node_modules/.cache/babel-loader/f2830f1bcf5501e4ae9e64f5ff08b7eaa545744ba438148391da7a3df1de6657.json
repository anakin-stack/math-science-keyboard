{"ast":null,"code":"// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  (function c(node, st, override) {\n    var type = override || node.type,\n      found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) {\n      found(node, st);\n    }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  (function c(node, st, override) {\n    var type = override || node.type,\n      found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) {\n      ancestors.push(node);\n    }\n    baseVisitor[type](node, st, c);\n    if (found) {\n      found(node, st || ancestors, ancestors);\n    }\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor;\n  (function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\nfunction makeTest(test) {\n  if (typeof test === \"string\") {\n    return function (type) {\n      return type === test;\n    };\n  } else if (!test) {\n    return function () {\n      return true;\n    };\n  } else {\n    return test;\n  }\n}\nvar Found = function Found(node, state) {\n  this.node = node;\n  this.state = state;\n};\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  (function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) {\n      callback(node, st, type);\n    }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  var ancestors = [];\n  (function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) {\n      ancestors.push(node);\n    }\n    baseVisitor[type](node, st, c);\n    if (!override) {\n      callback(node, st || ancestors, ancestors, type);\n    }\n    if (isNew) {\n      ancestors.pop();\n    }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) && (end == null || node.end >= end)) {\n        baseVisitor[type](node, st, c);\n      }\n      if ((start == null || node.start === start) && (end == null || node.end === end) && test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n    throw e;\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) {\n        return;\n      }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) {\n        throw new Found(node, st);\n      }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n    throw e;\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) {\n        return;\n      }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) {\n        throw new Found(node, st);\n      }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) {\n      return e;\n    }\n    throw e;\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) {\n    baseVisitor = base;\n  }\n  var max;\n  (function c(node, st, override) {\n    if (node.start > pos) {\n      return;\n    }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node)) {\n      max = new Found(node, st);\n    }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max;\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function (proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor();\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) {\n    visitor[type] = funcs[type];\n  }\n  return visitor;\n}\nfunction skipThrough(node, st, c) {\n  c(node, st);\n}\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var stmt = list[i];\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression = function (node, st, c) {\n  return c(node.expression, st, \"Expression\");\n};\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) {\n    c(node.alternate, st, \"Statement\");\n  }\n};\nbase.LabeledStatement = function (node, st, c) {\n  return c(node.body, st, \"Statement\");\n};\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n    if (cs.test) {\n      c(cs.test, st, \"Expression\");\n    }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1) {\n      var cons = list[i];\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1) {\n    var cons = list[i];\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) {\n    c(node.argument, st, \"Expression\");\n  }\n};\nbase.ThrowStatement = base.SpreadElement = function (node, st, c) {\n  return c(node.argument, st, \"Expression\");\n};\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) {\n    c(node.handler, st);\n  }\n  if (node.finalizer) {\n    c(node.finalizer, st, \"Statement\");\n  }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) {\n    c(node.param, st, \"Pattern\");\n  }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) {\n    c(node.init, st, \"ForInit\");\n  }\n  if (node.test) {\n    c(node.test, st, \"Expression\");\n  }\n  if (node.update) {\n    c(node.update, st, \"Expression\");\n  }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") {\n    c(node, st);\n  } else {\n    c(node, st, \"Expression\");\n  }\n};\nbase.DebuggerStatement = ignore;\nbase.FunctionDeclaration = function (node, st, c) {\n  return c(node, st, \"Function\");\n};\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1) {\n    var decl = list[i];\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) {\n    c(node.init, st, \"Expression\");\n  }\n};\nbase.Function = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\") {\n    c(node, st, \"VariablePattern\");\n  } else if (node.type === \"MemberExpression\") {\n    c(node, st, \"MemberPattern\");\n  } else {\n    c(node, st);\n  }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) {\n  return c(node.argument, st, \"Pattern\");\n};\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n    if (elt) {\n      c(elt, st, \"Pattern\");\n    }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n    if (prop.type === \"Property\") {\n      if (prop.computed) {\n        c(prop.key, st, \"Expression\");\n      }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n    if (elt) {\n      c(elt, st, \"Expression\");\n    }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1) {\n    var expr = list[i];\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1) {\n    var quasi = list[i];\n    c(quasi, st);\n  }\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1) {\n    var expr = list$1[i$1];\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments) {\n    for (var i = 0, list = node.arguments; i < list.length; i += 1) {\n      var arg = list[i];\n      c(arg, st, \"Expression\");\n    }\n  }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) {\n    c(node.property, st, \"Expression\");\n  }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration) {\n    c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\");\n  }\n  if (node.source) {\n    c(node.source, st, \"Expression\");\n  }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n    var spec = list[i];\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) {\n  return c(node, st, \"Class\");\n};\nbase.Class = function (node, st, c) {\n  if (node.id) {\n    c(node.id, st, \"Pattern\");\n  }\n  if (node.superClass) {\n    c(node.superClass, st, \"Expression\");\n  }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1) {\n    var elt = list[i];\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) {\n    c(node.key, st, \"Expression\");\n  }\n  c(node.value, st, \"Expression\");\n};\nexport { ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple };","map":{"version":3,"names":["simple","node","visitors","baseVisitor","state","override","base","c","st","type","found","ancestor","ancestors","isNew","length","push","pop","recursive","funcs","visitor","make","undefined","makeTest","test","Found","full","callback","fullAncestor","findNodeAt","start","end","e","findNodeAround","pos","findNodeAfter","findNodeBefore","max","create","Object","proto","Ctor","prototype","skipThrough","ignore","_node","_st","_c","Program","BlockStatement","i","list","body","stmt","Statement","EmptyStatement","ExpressionStatement","ParenthesizedExpression","expression","IfStatement","consequent","alternate","LabeledStatement","BreakStatement","ContinueStatement","WithStatement","object","SwitchStatement","discriminant","i$1","list$1","cases","cs","cons","SwitchCase","ReturnStatement","YieldExpression","AwaitExpression","argument","ThrowStatement","SpreadElement","TryStatement","block","handler","finalizer","CatchClause","param","WhileStatement","DoWhileStatement","ForStatement","init","update","ForInStatement","ForOfStatement","left","right","ForInit","DebuggerStatement","FunctionDeclaration","VariableDeclaration","declarations","decl","VariableDeclarator","id","Function","params","Pattern","VariablePattern","MemberPattern","RestElement","ArrayPattern","elements","elt","ObjectPattern","properties","prop","computed","key","value","Expression","ThisExpression","Super","MetaProperty","ArrayExpression","ObjectExpression","FunctionExpression","ArrowFunctionExpression","SequenceExpression","expressions","expr","TemplateLiteral","quasis","quasi","TemplateElement","UnaryExpression","UpdateExpression","BinaryExpression","LogicalExpression","AssignmentExpression","AssignmentPattern","ConditionalExpression","NewExpression","CallExpression","callee","arguments","arg","MemberExpression","property","ExportNamedDeclaration","ExportDefaultDeclaration","declaration","source","ExportAllDeclaration","ImportDeclaration","specifiers","spec","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","Identifier","Literal","Import","TaggedTemplateExpression","tag","ClassDeclaration","ClassExpression","Class","superClass","ClassBody","MethodDefinition","Property"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/acorn-walk/dist/walk.mjs"],"sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression and\n// Statement, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nfunction simple(node, visitors, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st); }\n  })(node, state, override);\n}\n\n// An ancestor walk keeps an array of ancestor nodes (including the\n// current node) and passes them to the callback as third parameter\n// (and also as state parameter when no other state is present).\nfunction ancestor(node, visitors, baseVisitor, state) {\n  var ancestors = [];\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type, found = visitors[type];\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (found) { found(node, st || ancestors, ancestors); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nfunction recursive(node, state, funcs, baseVisitor, override) {\n  var visitor = funcs ? make(funcs, baseVisitor || undefined) : baseVisitor\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c);\n  })(node, state, override);\n}\n\nfunction makeTest(test) {\n  if (typeof test === \"string\")\n    { return function (type) { return type === test; } }\n  else if (!test)\n    { return function () { return true; } }\n  else\n    { return test }\n}\n\nvar Found = function Found(node, state) { this.node = node; this.state = state; };\n\n// A full walk triggers the callback on each node\nfunction full(node, callback, baseVisitor, state, override) {\n  if (!baseVisitor) { baseVisitor = base\n  ; }(function c(node, st, override) {\n    var type = override || node.type;\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st, type); }\n  })(node, state, override);\n}\n\n// An fullAncestor walk is like an ancestor walk, but triggers\n// the callback on each node\nfunction fullAncestor(node, callback, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  var ancestors = []\n  ;(function c(node, st, override) {\n    var type = override || node.type;\n    var isNew = node !== ancestors[ancestors.length - 1];\n    if (isNew) { ancestors.push(node); }\n    baseVisitor[type](node, st, c);\n    if (!override) { callback(node, st || ancestors, ancestors, type); }\n    if (isNew) { ancestors.pop(); }\n  })(node, state);\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nfunction findNodeAt(node, start, end, test, baseVisitor, state) {\n  if (!baseVisitor) { baseVisitor = base; }\n  test = makeTest(test);\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        { baseVisitor[type](node, st, c); }\n      if ((start == null || node.start === start) &&\n          (end == null || node.end === end) &&\n          test(type, node))\n        { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nfunction findNodeAround(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      var type = override || node.type;\n      if (node.start > pos || node.end < pos) { return }\n      baseVisitor[type](node, st, c);\n      if (test(type, node)) { throw new Found(node, st) }\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nfunction findNodeAfter(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  try {\n    (function c(node, st, override) {\n      if (node.end < pos) { return }\n      var type = override || node.type;\n      if (node.start >= pos && test(type, node)) { throw new Found(node, st) }\n      baseVisitor[type](node, st, c);\n    })(node, state);\n  } catch (e) {\n    if (e instanceof Found) { return e }\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nfunction findNodeBefore(node, pos, test, baseVisitor, state) {\n  test = makeTest(test);\n  if (!baseVisitor) { baseVisitor = base; }\n  var max\n  ;(function c(node, st, override) {\n    if (node.start > pos) { return }\n    var type = override || node.type;\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      { max = new Found(node, st); }\n    baseVisitor[type](node, st, c);\n  })(node, state);\n  return max\n}\n\n// Fallback to an Object.create polyfill for older environments.\nvar create = Object.create || function(proto) {\n  function Ctor() {}\n  Ctor.prototype = proto;\n  return new Ctor\n};\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nfunction make(funcs, baseVisitor) {\n  var visitor = create(baseVisitor || base);\n  for (var type in funcs) { visitor[type] = funcs[type]; }\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st); }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nvar base = {};\n\nbase.Program = base.BlockStatement = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var stmt = list[i];\n\n    c(stmt, st, \"Statement\");\n  }\n};\nbase.Statement = skipThrough;\nbase.EmptyStatement = ignore;\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  function (node, st, c) { return c(node.expression, st, \"Expression\"); };\nbase.IfStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Statement\");\n  if (node.alternate) { c(node.alternate, st, \"Statement\"); }\n};\nbase.LabeledStatement = function (node, st, c) { return c(node.body, st, \"Statement\"); };\nbase.BreakStatement = base.ContinueStatement = ignore;\nbase.WithStatement = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.SwitchStatement = function (node, st, c) {\n  c(node.discriminant, st, \"Expression\");\n  for (var i$1 = 0, list$1 = node.cases; i$1 < list$1.length; i$1 += 1) {\n    var cs = list$1[i$1];\n\n    if (cs.test) { c(cs.test, st, \"Expression\"); }\n    for (var i = 0, list = cs.consequent; i < list.length; i += 1)\n      {\n      var cons = list[i];\n\n      c(cons, st, \"Statement\");\n    }\n  }\n};\nbase.SwitchCase = function (node, st, c) {\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  for (var i = 0, list = node.consequent; i < list.length; i += 1)\n    {\n    var cons = list[i];\n\n    c(cons, st, \"Statement\");\n  }\n};\nbase.ReturnStatement = base.YieldExpression = base.AwaitExpression = function (node, st, c) {\n  if (node.argument) { c(node.argument, st, \"Expression\"); }\n};\nbase.ThrowStatement = base.SpreadElement =\n  function (node, st, c) { return c(node.argument, st, \"Expression\"); };\nbase.TryStatement = function (node, st, c) {\n  c(node.block, st, \"Statement\");\n  if (node.handler) { c(node.handler, st); }\n  if (node.finalizer) { c(node.finalizer, st, \"Statement\"); }\n};\nbase.CatchClause = function (node, st, c) {\n  if (node.param) { c(node.param, st, \"Pattern\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.WhileStatement = base.DoWhileStatement = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForStatement = function (node, st, c) {\n  if (node.init) { c(node.init, st, \"ForInit\"); }\n  if (node.test) { c(node.test, st, \"Expression\"); }\n  if (node.update) { c(node.update, st, \"Expression\"); }\n  c(node.body, st, \"Statement\");\n};\nbase.ForInStatement = base.ForOfStatement = function (node, st, c) {\n  c(node.left, st, \"ForInit\");\n  c(node.right, st, \"Expression\");\n  c(node.body, st, \"Statement\");\n};\nbase.ForInit = function (node, st, c) {\n  if (node.type === \"VariableDeclaration\") { c(node, st); }\n  else { c(node, st, \"Expression\"); }\n};\nbase.DebuggerStatement = ignore;\n\nbase.FunctionDeclaration = function (node, st, c) { return c(node, st, \"Function\"); };\nbase.VariableDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.declarations; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    c(decl, st);\n  }\n};\nbase.VariableDeclarator = function (node, st, c) {\n  c(node.id, st, \"Pattern\");\n  if (node.init) { c(node.init, st, \"Expression\"); }\n};\n\nbase.Function = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    c(param, st, \"Pattern\");\n  }\n  c(node.body, st, node.expression ? \"Expression\" : \"Statement\");\n};\n\nbase.Pattern = function (node, st, c) {\n  if (node.type === \"Identifier\")\n    { c(node, st, \"VariablePattern\"); }\n  else if (node.type === \"MemberExpression\")\n    { c(node, st, \"MemberPattern\"); }\n  else\n    { c(node, st); }\n};\nbase.VariablePattern = ignore;\nbase.MemberPattern = skipThrough;\nbase.RestElement = function (node, st, c) { return c(node.argument, st, \"Pattern\"); };\nbase.ArrayPattern = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Pattern\"); }\n  }\n};\nbase.ObjectPattern = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1) {\n    var prop = list[i];\n\n    if (prop.type === \"Property\") {\n      if (prop.computed) { c(prop.key, st, \"Expression\"); }\n      c(prop.value, st, \"Pattern\");\n    } else if (prop.type === \"RestElement\") {\n      c(prop.argument, st, \"Pattern\");\n    }\n  }\n};\n\nbase.Expression = skipThrough;\nbase.ThisExpression = base.Super = base.MetaProperty = ignore;\nbase.ArrayExpression = function (node, st, c) {\n  for (var i = 0, list = node.elements; i < list.length; i += 1) {\n    var elt = list[i];\n\n    if (elt) { c(elt, st, \"Expression\"); }\n  }\n};\nbase.ObjectExpression = function (node, st, c) {\n  for (var i = 0, list = node.properties; i < list.length; i += 1)\n    {\n    var prop = list[i];\n\n    c(prop, st);\n  }\n};\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration;\nbase.SequenceExpression = function (node, st, c) {\n  for (var i = 0, list = node.expressions; i < list.length; i += 1)\n    {\n    var expr = list[i];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateLiteral = function (node, st, c) {\n  for (var i = 0, list = node.quasis; i < list.length; i += 1)\n    {\n    var quasi = list[i];\n\n    c(quasi, st);\n  }\n\n  for (var i$1 = 0, list$1 = node.expressions; i$1 < list$1.length; i$1 += 1)\n    {\n    var expr = list$1[i$1];\n\n    c(expr, st, \"Expression\");\n  }\n};\nbase.TemplateElement = ignore;\nbase.UnaryExpression = base.UpdateExpression = function (node, st, c) {\n  c(node.argument, st, \"Expression\");\n};\nbase.BinaryExpression = base.LogicalExpression = function (node, st, c) {\n  c(node.left, st, \"Expression\");\n  c(node.right, st, \"Expression\");\n};\nbase.AssignmentExpression = base.AssignmentPattern = function (node, st, c) {\n  c(node.left, st, \"Pattern\");\n  c(node.right, st, \"Expression\");\n};\nbase.ConditionalExpression = function (node, st, c) {\n  c(node.test, st, \"Expression\");\n  c(node.consequent, st, \"Expression\");\n  c(node.alternate, st, \"Expression\");\n};\nbase.NewExpression = base.CallExpression = function (node, st, c) {\n  c(node.callee, st, \"Expression\");\n  if (node.arguments)\n    { for (var i = 0, list = node.arguments; i < list.length; i += 1)\n      {\n        var arg = list[i];\n\n        c(arg, st, \"Expression\");\n      } }\n};\nbase.MemberExpression = function (node, st, c) {\n  c(node.object, st, \"Expression\");\n  if (node.computed) { c(node.property, st, \"Expression\"); }\n};\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = function (node, st, c) {\n  if (node.declaration)\n    { c(node.declaration, st, node.type === \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\"); }\n  if (node.source) { c(node.source, st, \"Expression\"); }\n};\nbase.ExportAllDeclaration = function (node, st, c) {\n  c(node.source, st, \"Expression\");\n};\nbase.ImportDeclaration = function (node, st, c) {\n  for (var i = 0, list = node.specifiers; i < list.length; i += 1)\n    {\n    var spec = list[i];\n\n    c(spec, st);\n  }\n  c(node.source, st, \"Expression\");\n};\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = base.Import = ignore;\n\nbase.TaggedTemplateExpression = function (node, st, c) {\n  c(node.tag, st, \"Expression\");\n  c(node.quasi, st, \"Expression\");\n};\nbase.ClassDeclaration = base.ClassExpression = function (node, st, c) { return c(node, st, \"Class\"); };\nbase.Class = function (node, st, c) {\n  if (node.id) { c(node.id, st, \"Pattern\"); }\n  if (node.superClass) { c(node.superClass, st, \"Expression\"); }\n  c(node.body, st);\n};\nbase.ClassBody = function (node, st, c) {\n  for (var i = 0, list = node.body; i < list.length; i += 1)\n    {\n    var elt = list[i];\n\n    c(elt, st);\n  }\n};\nbase.MethodDefinition = base.Property = function (node, st, c) {\n  if (node.computed) { c(node.key, st, \"Expression\"); }\n  c(node.value, st, \"Expression\");\n};\n\nexport { ancestor, base, findNodeAfter, findNodeAround, findNodeAt, findNodeBefore, full, fullAncestor, make, recursive, simple };\n"],"mappings":"AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASA,MAAMA,CAACC,IAAI,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC5D,IAAI,CAACF,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EACpC;EAAC,CAAC,SAASC,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IACjC,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;MAAEC,KAAK,GAAGR,QAAQ,CAACO,IAAI,CAAC;IACxDN,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;IAC9B,IAAIG,KAAK,EAAE;MAAEA,KAAK,CAACT,IAAI,EAAEO,EAAE,CAAC;IAAE;EAChC,CAAC,EAAEP,IAAI,EAAEG,KAAK,EAAEC,QAAQ,CAAC;AAC3B;;AAEA;AACA;AACA;AACA,SAASM,QAAQA,CAACV,IAAI,EAAEC,QAAQ,EAAEC,WAAW,EAAEC,KAAK,EAAE;EACpD,IAAIQ,SAAS,GAAG,EAAE;EAClB,IAAI,CAACT,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EACpC;EAAC,CAAC,SAASC,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IACjC,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;MAAEC,KAAK,GAAGR,QAAQ,CAACO,IAAI,CAAC;IACxD,IAAII,KAAK,GAAGZ,IAAI,KAAKW,SAAS,CAACA,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;IACpD,IAAID,KAAK,EAAE;MAAED,SAAS,CAACG,IAAI,CAACd,IAAI,CAAC;IAAE;IACnCE,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;IAC9B,IAAIG,KAAK,EAAE;MAAEA,KAAK,CAACT,IAAI,EAAEO,EAAE,IAAII,SAAS,EAAEA,SAAS,CAAC;IAAE;IACtD,IAAIC,KAAK,EAAE;MAAED,SAAS,CAACI,GAAG,CAAC,CAAC;IAAE;EAChC,CAAC,EAAEf,IAAI,EAAEG,KAAK,CAAC;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA,SAASa,SAASA,CAAChB,IAAI,EAAEG,KAAK,EAAEc,KAAK,EAAEf,WAAW,EAAEE,QAAQ,EAAE;EAC5D,IAAIc,OAAO,GAAGD,KAAK,GAAGE,IAAI,CAACF,KAAK,EAAEf,WAAW,IAAIkB,SAAS,CAAC,GAAGlB,WAAW;EACxE,CAAC,SAASI,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IAC/Bc,OAAO,CAACd,QAAQ,IAAIJ,IAAI,CAACQ,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;EAC7C,CAAC,EAAEN,IAAI,EAAEG,KAAK,EAAEC,QAAQ,CAAC;AAC3B;AAEA,SAASiB,QAAQA,CAACC,IAAI,EAAE;EACtB,IAAI,OAAOA,IAAI,KAAK,QAAQ,EAC1B;IAAE,OAAO,UAAUd,IAAI,EAAE;MAAE,OAAOA,IAAI,KAAKc,IAAI;IAAE,CAAC;EAAC,CAAC,MACjD,IAAI,CAACA,IAAI,EACZ;IAAE,OAAO,YAAY;MAAE,OAAO,IAAI;IAAE,CAAC;EAAC,CAAC,MAEvC;IAAE,OAAOA,IAAI;EAAC;AAClB;AAEA,IAAIC,KAAK,GAAG,SAASA,KAAKA,CAACvB,IAAI,EAAEG,KAAK,EAAE;EAAE,IAAI,CAACH,IAAI,GAAGA,IAAI;EAAE,IAAI,CAACG,KAAK,GAAGA,KAAK;AAAE,CAAC;;AAEjF;AACA,SAASqB,IAAIA,CAACxB,IAAI,EAAEyB,QAAQ,EAAEvB,WAAW,EAAEC,KAAK,EAAEC,QAAQ,EAAE;EAC1D,IAAI,CAACF,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EACpC;EAAC,CAAC,SAASC,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IACjC,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;IAChCN,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;IAC9B,IAAI,CAACF,QAAQ,EAAE;MAAEqB,QAAQ,CAACzB,IAAI,EAAEO,EAAE,EAAEC,IAAI,CAAC;IAAE;EAC7C,CAAC,EAAER,IAAI,EAAEG,KAAK,EAAEC,QAAQ,CAAC;AAC3B;;AAEA;AACA;AACA,SAASsB,YAAYA,CAAC1B,IAAI,EAAEyB,QAAQ,EAAEvB,WAAW,EAAEC,KAAK,EAAE;EACxD,IAAI,CAACD,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EAAE;EACxC,IAAIM,SAAS,GAAG,EAAE;EACjB,CAAC,SAASL,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IAC/B,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;IAChC,IAAII,KAAK,GAAGZ,IAAI,KAAKW,SAAS,CAACA,SAAS,CAACE,MAAM,GAAG,CAAC,CAAC;IACpD,IAAID,KAAK,EAAE;MAAED,SAAS,CAACG,IAAI,CAACd,IAAI,CAAC;IAAE;IACnCE,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;IAC9B,IAAI,CAACF,QAAQ,EAAE;MAAEqB,QAAQ,CAACzB,IAAI,EAAEO,EAAE,IAAII,SAAS,EAAEA,SAAS,EAAEH,IAAI,CAAC;IAAE;IACnE,IAAII,KAAK,EAAE;MAAED,SAAS,CAACI,GAAG,CAAC,CAAC;IAAE;EAChC,CAAC,EAAEf,IAAI,EAAEG,KAAK,CAAC;AACjB;;AAEA;AACA;AACA;AACA,SAASwB,UAAUA,CAAC3B,IAAI,EAAE4B,KAAK,EAAEC,GAAG,EAAEP,IAAI,EAAEpB,WAAW,EAAEC,KAAK,EAAE;EAC9D,IAAI,CAACD,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EAAE;EACxCiB,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC;EACrB,IAAI;IACF,CAAC,SAAShB,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;MAC9B,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;MAChC,IAAI,CAACoB,KAAK,IAAI,IAAI,IAAI5B,IAAI,CAAC4B,KAAK,IAAIA,KAAK,MACpCC,GAAG,IAAI,IAAI,IAAI7B,IAAI,CAAC6B,GAAG,IAAIA,GAAG,CAAC,EAClC;QAAE3B,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;MAAE;MACpC,IAAI,CAACsB,KAAK,IAAI,IAAI,IAAI5B,IAAI,CAAC4B,KAAK,KAAKA,KAAK,MACrCC,GAAG,IAAI,IAAI,IAAI7B,IAAI,CAAC6B,GAAG,KAAKA,GAAG,CAAC,IACjCP,IAAI,CAACd,IAAI,EAAER,IAAI,CAAC,EAClB;QAAE,MAAM,IAAIuB,KAAK,CAACvB,IAAI,EAAEO,EAAE,CAAC;MAAC;IAChC,CAAC,EAAEP,IAAI,EAAEG,KAAK,CAAC;EACjB,CAAC,CAAC,OAAO2B,CAAC,EAAE;IACV,IAAIA,CAAC,YAAYP,KAAK,EAAE;MAAE,OAAOO,CAAC;IAAC;IACnC,MAAMA,CAAC;EACT;AACF;;AAEA;AACA;AACA,SAASC,cAAcA,CAAC/B,IAAI,EAAEgC,GAAG,EAAEV,IAAI,EAAEpB,WAAW,EAAEC,KAAK,EAAE;EAC3DmB,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC;EACrB,IAAI,CAACpB,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EAAE;EACxC,IAAI;IACF,CAAC,SAASC,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;MAC9B,IAAII,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;MAChC,IAAIR,IAAI,CAAC4B,KAAK,GAAGI,GAAG,IAAIhC,IAAI,CAAC6B,GAAG,GAAGG,GAAG,EAAE;QAAE;MAAO;MACjD9B,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;MAC9B,IAAIgB,IAAI,CAACd,IAAI,EAAER,IAAI,CAAC,EAAE;QAAE,MAAM,IAAIuB,KAAK,CAACvB,IAAI,EAAEO,EAAE,CAAC;MAAC;IACpD,CAAC,EAAEP,IAAI,EAAEG,KAAK,CAAC;EACjB,CAAC,CAAC,OAAO2B,CAAC,EAAE;IACV,IAAIA,CAAC,YAAYP,KAAK,EAAE;MAAE,OAAOO,CAAC;IAAC;IACnC,MAAMA,CAAC;EACT;AACF;;AAEA;AACA,SAASG,aAAaA,CAACjC,IAAI,EAAEgC,GAAG,EAAEV,IAAI,EAAEpB,WAAW,EAAEC,KAAK,EAAE;EAC1DmB,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC;EACrB,IAAI,CAACpB,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EAAE;EACxC,IAAI;IACF,CAAC,SAASC,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;MAC9B,IAAIJ,IAAI,CAAC6B,GAAG,GAAGG,GAAG,EAAE;QAAE;MAAO;MAC7B,IAAIxB,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;MAChC,IAAIR,IAAI,CAAC4B,KAAK,IAAII,GAAG,IAAIV,IAAI,CAACd,IAAI,EAAER,IAAI,CAAC,EAAE;QAAE,MAAM,IAAIuB,KAAK,CAACvB,IAAI,EAAEO,EAAE,CAAC;MAAC;MACvEL,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;IAChC,CAAC,EAAEN,IAAI,EAAEG,KAAK,CAAC;EACjB,CAAC,CAAC,OAAO2B,CAAC,EAAE;IACV,IAAIA,CAAC,YAAYP,KAAK,EAAE;MAAE,OAAOO,CAAC;IAAC;IACnC,MAAMA,CAAC;EACT;AACF;;AAEA;AACA,SAASI,cAAcA,CAAClC,IAAI,EAAEgC,GAAG,EAAEV,IAAI,EAAEpB,WAAW,EAAEC,KAAK,EAAE;EAC3DmB,IAAI,GAAGD,QAAQ,CAACC,IAAI,CAAC;EACrB,IAAI,CAACpB,WAAW,EAAE;IAAEA,WAAW,GAAGG,IAAI;EAAE;EACxC,IAAI8B,GAAG;EACN,CAAC,SAAS7B,CAACA,CAACN,IAAI,EAAEO,EAAE,EAAEH,QAAQ,EAAE;IAC/B,IAAIJ,IAAI,CAAC4B,KAAK,GAAGI,GAAG,EAAE;MAAE;IAAO;IAC/B,IAAIxB,IAAI,GAAGJ,QAAQ,IAAIJ,IAAI,CAACQ,IAAI;IAChC,IAAIR,IAAI,CAAC6B,GAAG,IAAIG,GAAG,KAAK,CAACG,GAAG,IAAIA,GAAG,CAACnC,IAAI,CAAC6B,GAAG,GAAG7B,IAAI,CAAC6B,GAAG,CAAC,IAAIP,IAAI,CAACd,IAAI,EAAER,IAAI,CAAC,EAC1E;MAAEmC,GAAG,GAAG,IAAIZ,KAAK,CAACvB,IAAI,EAAEO,EAAE,CAAC;IAAE;IAC/BL,WAAW,CAACM,IAAI,CAAC,CAACR,IAAI,EAAEO,EAAE,EAAED,CAAC,CAAC;EAChC,CAAC,EAAEN,IAAI,EAAEG,KAAK,CAAC;EACf,OAAOgC,GAAG;AACZ;;AAEA;AACA,IAAIC,MAAM,GAAGC,MAAM,CAACD,MAAM,IAAI,UAASE,KAAK,EAAE;EAC5C,SAASC,IAAIA,CAAA,EAAG,CAAC;EACjBA,IAAI,CAACC,SAAS,GAAGF,KAAK;EACtB,OAAO,IAAIC,IAAI,CAAD,CAAC;AACjB,CAAC;;AAED;AACA;AACA,SAASpB,IAAIA,CAACF,KAAK,EAAEf,WAAW,EAAE;EAChC,IAAIgB,OAAO,GAAGkB,MAAM,CAAClC,WAAW,IAAIG,IAAI,CAAC;EACzC,KAAK,IAAIG,IAAI,IAAIS,KAAK,EAAE;IAAEC,OAAO,CAACV,IAAI,CAAC,GAAGS,KAAK,CAACT,IAAI,CAAC;EAAE;EACvD,OAAOU,OAAO;AAChB;AAEA,SAASuB,WAAWA,CAACzC,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAEA,CAAC,CAACN,IAAI,EAAEO,EAAE,CAAC;AAAE;AACjD,SAASmC,MAAMA,CAACC,KAAK,EAAEC,GAAG,EAAEC,EAAE,EAAE,CAAC;;AAEjC;;AAEA,IAAIxC,IAAI,GAAG,CAAC,CAAC;AAEbA,IAAI,CAACyC,OAAO,GAAGzC,IAAI,CAAC0C,cAAc,GAAG,UAAU/C,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC1D,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACkD,IAAI,EAAEF,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EACvD;IACA,IAAIG,IAAI,GAAGF,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAAC6C,IAAI,EAAE5C,EAAE,EAAE,WAAW,CAAC;EAC1B;AACF,CAAC;AACDF,IAAI,CAAC+C,SAAS,GAAGX,WAAW;AAC5BpC,IAAI,CAACgD,cAAc,GAAGX,MAAM;AAC5BrC,IAAI,CAACiD,mBAAmB,GAAGjD,IAAI,CAACkD,uBAAuB,GACrD,UAAUvD,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,CAACwD,UAAU,EAAEjD,EAAE,EAAE,YAAY,CAAC;AAAE,CAAC;AACzEF,IAAI,CAACoD,WAAW,GAAG,UAAUzD,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACxCA,CAAC,CAACN,IAAI,CAACsB,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;EAC9BD,CAAC,CAACN,IAAI,CAAC0D,UAAU,EAAEnD,EAAE,EAAE,WAAW,CAAC;EACnC,IAAIP,IAAI,CAAC2D,SAAS,EAAE;IAAErD,CAAC,CAACN,IAAI,CAAC2D,SAAS,EAAEpD,EAAE,EAAE,WAAW,CAAC;EAAE;AAC5D,CAAC;AACDF,IAAI,CAACuD,gBAAgB,GAAG,UAAU5D,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAAE,CAAC;AACxFF,IAAI,CAACwD,cAAc,GAAGxD,IAAI,CAACyD,iBAAiB,GAAGpB,MAAM;AACrDrC,IAAI,CAAC0D,aAAa,GAAG,UAAU/D,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC1CA,CAAC,CAACN,IAAI,CAACgE,MAAM,EAAEzD,EAAE,EAAE,YAAY,CAAC;EAChCD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAC/B,CAAC;AACDF,IAAI,CAAC4D,eAAe,GAAG,UAAUjE,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC5CA,CAAC,CAACN,IAAI,CAACkE,YAAY,EAAE3D,EAAE,EAAE,YAAY,CAAC;EACtC,KAAK,IAAI4D,GAAG,GAAG,CAAC,EAAEC,MAAM,GAAGpE,IAAI,CAACqE,KAAK,EAAEF,GAAG,GAAGC,MAAM,CAACvD,MAAM,EAAEsD,GAAG,IAAI,CAAC,EAAE;IACpE,IAAIG,EAAE,GAAGF,MAAM,CAACD,GAAG,CAAC;IAEpB,IAAIG,EAAE,CAAChD,IAAI,EAAE;MAAEhB,CAAC,CAACgE,EAAE,CAAChD,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;IAAE;IAC7C,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGqB,EAAE,CAACZ,UAAU,EAAEV,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC3D;MACA,IAAIuB,IAAI,GAAGtB,IAAI,CAACD,CAAC,CAAC;MAElB1C,CAAC,CAACiE,IAAI,EAAEhE,EAAE,EAAE,WAAW,CAAC;IAC1B;EACF;AACF,CAAC;AACDF,IAAI,CAACmE,UAAU,GAAG,UAAUxE,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACvC,IAAIN,IAAI,CAACsB,IAAI,EAAE;IAAEhB,CAAC,CAACN,IAAI,CAACsB,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;EAAE;EACjD,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAAC0D,UAAU,EAAEV,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC7D;IACA,IAAIuB,IAAI,GAAGtB,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAACiE,IAAI,EAAEhE,EAAE,EAAE,WAAW,CAAC;EAC1B;AACF,CAAC;AACDF,IAAI,CAACoE,eAAe,GAAGpE,IAAI,CAACqE,eAAe,GAAGrE,IAAI,CAACsE,eAAe,GAAG,UAAU3E,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC1F,IAAIN,IAAI,CAAC4E,QAAQ,EAAE;IAAEtE,CAAC,CAACN,IAAI,CAAC4E,QAAQ,EAAErE,EAAE,EAAE,YAAY,CAAC;EAAE;AAC3D,CAAC;AACDF,IAAI,CAACwE,cAAc,GAAGxE,IAAI,CAACyE,aAAa,GACtC,UAAU9E,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,CAAC4E,QAAQ,EAAErE,EAAE,EAAE,YAAY,CAAC;AAAE,CAAC;AACvEF,IAAI,CAAC0E,YAAY,GAAG,UAAU/E,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACzCA,CAAC,CAACN,IAAI,CAACgF,KAAK,EAAEzE,EAAE,EAAE,WAAW,CAAC;EAC9B,IAAIP,IAAI,CAACiF,OAAO,EAAE;IAAE3E,CAAC,CAACN,IAAI,CAACiF,OAAO,EAAE1E,EAAE,CAAC;EAAE;EACzC,IAAIP,IAAI,CAACkF,SAAS,EAAE;IAAE5E,CAAC,CAACN,IAAI,CAACkF,SAAS,EAAE3E,EAAE,EAAE,WAAW,CAAC;EAAE;AAC5D,CAAC;AACDF,IAAI,CAAC8E,WAAW,GAAG,UAAUnF,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACxC,IAAIN,IAAI,CAACoF,KAAK,EAAE;IAAE9E,CAAC,CAACN,IAAI,CAACoF,KAAK,EAAE7E,EAAE,EAAE,SAAS,CAAC;EAAE;EAChDD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAC/B,CAAC;AACDF,IAAI,CAACgF,cAAc,GAAGhF,IAAI,CAACiF,gBAAgB,GAAG,UAAUtF,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACnEA,CAAC,CAACN,IAAI,CAACsB,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;EAC9BD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAC/B,CAAC;AACDF,IAAI,CAACkF,YAAY,GAAG,UAAUvF,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACzC,IAAIN,IAAI,CAACwF,IAAI,EAAE;IAAElF,CAAC,CAACN,IAAI,CAACwF,IAAI,EAAEjF,EAAE,EAAE,SAAS,CAAC;EAAE;EAC9C,IAAIP,IAAI,CAACsB,IAAI,EAAE;IAAEhB,CAAC,CAACN,IAAI,CAACsB,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;EAAE;EACjD,IAAIP,IAAI,CAACyF,MAAM,EAAE;IAAEnF,CAAC,CAACN,IAAI,CAACyF,MAAM,EAAElF,EAAE,EAAE,YAAY,CAAC;EAAE;EACrDD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAC/B,CAAC;AACDF,IAAI,CAACqF,cAAc,GAAGrF,IAAI,CAACsF,cAAc,GAAG,UAAU3F,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACjEA,CAAC,CAACN,IAAI,CAAC4F,IAAI,EAAErF,EAAE,EAAE,SAAS,CAAC;EAC3BD,CAAC,CAACN,IAAI,CAAC6F,KAAK,EAAEtF,EAAE,EAAE,YAAY,CAAC;EAC/BD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAE,WAAW,CAAC;AAC/B,CAAC;AACDF,IAAI,CAACyF,OAAO,GAAG,UAAU9F,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACpC,IAAIN,IAAI,CAACQ,IAAI,KAAK,qBAAqB,EAAE;IAAEF,CAAC,CAACN,IAAI,EAAEO,EAAE,CAAC;EAAE,CAAC,MACpD;IAAED,CAAC,CAACN,IAAI,EAAEO,EAAE,EAAE,YAAY,CAAC;EAAE;AACpC,CAAC;AACDF,IAAI,CAAC0F,iBAAiB,GAAGrD,MAAM;AAE/BrC,IAAI,CAAC2F,mBAAmB,GAAG,UAAUhG,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,EAAEO,EAAE,EAAE,UAAU,CAAC;AAAE,CAAC;AACrFF,IAAI,CAAC4F,mBAAmB,GAAG,UAAUjG,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAChD,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACkG,YAAY,EAAElD,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC/D;IACA,IAAImD,IAAI,GAAGlD,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAAC6F,IAAI,EAAE5F,EAAE,CAAC;EACb;AACF,CAAC;AACDF,IAAI,CAAC+F,kBAAkB,GAAG,UAAUpG,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC/CA,CAAC,CAACN,IAAI,CAACqG,EAAE,EAAE9F,EAAE,EAAE,SAAS,CAAC;EACzB,IAAIP,IAAI,CAACwF,IAAI,EAAE;IAAElF,CAAC,CAACN,IAAI,CAACwF,IAAI,EAAEjF,EAAE,EAAE,YAAY,CAAC;EAAE;AACnD,CAAC;AAEDF,IAAI,CAACiG,QAAQ,GAAG,UAAUtG,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACrC,IAAIN,IAAI,CAACqG,EAAE,EAAE;IAAE/F,CAAC,CAACN,IAAI,CAACqG,EAAE,EAAE9F,EAAE,EAAE,SAAS,CAAC;EAAE;EAC1C,KAAK,IAAIyC,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACuG,MAAM,EAAEvD,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EACzD;IACA,IAAIoC,KAAK,GAAGnC,IAAI,CAACD,CAAC,CAAC;IAEnB1C,CAAC,CAAC8E,KAAK,EAAE7E,EAAE,EAAE,SAAS,CAAC;EACzB;EACAD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,EAAEP,IAAI,CAACwD,UAAU,GAAG,YAAY,GAAG,WAAW,CAAC;AAChE,CAAC;AAEDnD,IAAI,CAACmG,OAAO,GAAG,UAAUxG,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACpC,IAAIN,IAAI,CAACQ,IAAI,KAAK,YAAY,EAC5B;IAAEF,CAAC,CAACN,IAAI,EAAEO,EAAE,EAAE,iBAAiB,CAAC;EAAE,CAAC,MAChC,IAAIP,IAAI,CAACQ,IAAI,KAAK,kBAAkB,EACvC;IAAEF,CAAC,CAACN,IAAI,EAAEO,EAAE,EAAE,eAAe,CAAC;EAAE,CAAC,MAEjC;IAAED,CAAC,CAACN,IAAI,EAAEO,EAAE,CAAC;EAAE;AACnB,CAAC;AACDF,IAAI,CAACoG,eAAe,GAAG/D,MAAM;AAC7BrC,IAAI,CAACqG,aAAa,GAAGjE,WAAW;AAChCpC,IAAI,CAACsG,WAAW,GAAG,UAAU3G,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,CAAC4E,QAAQ,EAAErE,EAAE,EAAE,SAAS,CAAC;AAAE,CAAC;AACrFF,IAAI,CAACuG,YAAY,GAAG,UAAU5G,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACzC,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAAC6G,QAAQ,EAAE7D,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAAE;IAC7D,IAAI8D,GAAG,GAAG7D,IAAI,CAACD,CAAC,CAAC;IAEjB,IAAI8D,GAAG,EAAE;MAAExG,CAAC,CAACwG,GAAG,EAAEvG,EAAE,EAAE,SAAS,CAAC;IAAE;EACpC;AACF,CAAC;AACDF,IAAI,CAAC0G,aAAa,GAAG,UAAU/G,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC1C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACgH,UAAU,EAAEhE,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAAE;IAC/D,IAAIiE,IAAI,GAAGhE,IAAI,CAACD,CAAC,CAAC;IAElB,IAAIiE,IAAI,CAACzG,IAAI,KAAK,UAAU,EAAE;MAC5B,IAAIyG,IAAI,CAACC,QAAQ,EAAE;QAAE5G,CAAC,CAAC2G,IAAI,CAACE,GAAG,EAAE5G,EAAE,EAAE,YAAY,CAAC;MAAE;MACpDD,CAAC,CAAC2G,IAAI,CAACG,KAAK,EAAE7G,EAAE,EAAE,SAAS,CAAC;IAC9B,CAAC,MAAM,IAAI0G,IAAI,CAACzG,IAAI,KAAK,aAAa,EAAE;MACtCF,CAAC,CAAC2G,IAAI,CAACrC,QAAQ,EAAErE,EAAE,EAAE,SAAS,CAAC;IACjC;EACF;AACF,CAAC;AAEDF,IAAI,CAACgH,UAAU,GAAG5E,WAAW;AAC7BpC,IAAI,CAACiH,cAAc,GAAGjH,IAAI,CAACkH,KAAK,GAAGlH,IAAI,CAACmH,YAAY,GAAG9E,MAAM;AAC7DrC,IAAI,CAACoH,eAAe,GAAG,UAAUzH,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC5C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAAC6G,QAAQ,EAAE7D,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAAE;IAC7D,IAAI8D,GAAG,GAAG7D,IAAI,CAACD,CAAC,CAAC;IAEjB,IAAI8D,GAAG,EAAE;MAAExG,CAAC,CAACwG,GAAG,EAAEvG,EAAE,EAAE,YAAY,CAAC;IAAE;EACvC;AACF,CAAC;AACDF,IAAI,CAACqH,gBAAgB,GAAG,UAAU1H,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC7C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACgH,UAAU,EAAEhE,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC7D;IACA,IAAIiE,IAAI,GAAGhE,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAAC2G,IAAI,EAAE1G,EAAE,CAAC;EACb;AACF,CAAC;AACDF,IAAI,CAACsH,kBAAkB,GAAGtH,IAAI,CAACuH,uBAAuB,GAAGvH,IAAI,CAAC2F,mBAAmB;AACjF3F,IAAI,CAACwH,kBAAkB,GAAG,UAAU7H,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC/C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAAC8H,WAAW,EAAE9E,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC9D;IACA,IAAI+E,IAAI,GAAG9E,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAACyH,IAAI,EAAExH,EAAE,EAAE,YAAY,CAAC;EAC3B;AACF,CAAC;AACDF,IAAI,CAAC2H,eAAe,GAAG,UAAUhI,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC5C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACiI,MAAM,EAAEjF,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EACzD;IACA,IAAIkF,KAAK,GAAGjF,IAAI,CAACD,CAAC,CAAC;IAEnB1C,CAAC,CAAC4H,KAAK,EAAE3H,EAAE,CAAC;EACd;EAEA,KAAK,IAAI4D,GAAG,GAAG,CAAC,EAAEC,MAAM,GAAGpE,IAAI,CAAC8H,WAAW,EAAE3D,GAAG,GAAGC,MAAM,CAACvD,MAAM,EAAEsD,GAAG,IAAI,CAAC,EACxE;IACA,IAAI4D,IAAI,GAAG3D,MAAM,CAACD,GAAG,CAAC;IAEtB7D,CAAC,CAACyH,IAAI,EAAExH,EAAE,EAAE,YAAY,CAAC;EAC3B;AACF,CAAC;AACDF,IAAI,CAAC8H,eAAe,GAAGzF,MAAM;AAC7BrC,IAAI,CAAC+H,eAAe,GAAG/H,IAAI,CAACgI,gBAAgB,GAAG,UAAUrI,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACpEA,CAAC,CAACN,IAAI,CAAC4E,QAAQ,EAAErE,EAAE,EAAE,YAAY,CAAC;AACpC,CAAC;AACDF,IAAI,CAACiI,gBAAgB,GAAGjI,IAAI,CAACkI,iBAAiB,GAAG,UAAUvI,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACtEA,CAAC,CAACN,IAAI,CAAC4F,IAAI,EAAErF,EAAE,EAAE,YAAY,CAAC;EAC9BD,CAAC,CAACN,IAAI,CAAC6F,KAAK,EAAEtF,EAAE,EAAE,YAAY,CAAC;AACjC,CAAC;AACDF,IAAI,CAACmI,oBAAoB,GAAGnI,IAAI,CAACoI,iBAAiB,GAAG,UAAUzI,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC1EA,CAAC,CAACN,IAAI,CAAC4F,IAAI,EAAErF,EAAE,EAAE,SAAS,CAAC;EAC3BD,CAAC,CAACN,IAAI,CAAC6F,KAAK,EAAEtF,EAAE,EAAE,YAAY,CAAC;AACjC,CAAC;AACDF,IAAI,CAACqI,qBAAqB,GAAG,UAAU1I,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAClDA,CAAC,CAACN,IAAI,CAACsB,IAAI,EAAEf,EAAE,EAAE,YAAY,CAAC;EAC9BD,CAAC,CAACN,IAAI,CAAC0D,UAAU,EAAEnD,EAAE,EAAE,YAAY,CAAC;EACpCD,CAAC,CAACN,IAAI,CAAC2D,SAAS,EAAEpD,EAAE,EAAE,YAAY,CAAC;AACrC,CAAC;AACDF,IAAI,CAACsI,aAAa,GAAGtI,IAAI,CAACuI,cAAc,GAAG,UAAU5I,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAChEA,CAAC,CAACN,IAAI,CAAC6I,MAAM,EAAEtI,EAAE,EAAE,YAAY,CAAC;EAChC,IAAIP,IAAI,CAAC8I,SAAS,EAChB;IAAE,KAAK,IAAI9F,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAAC8I,SAAS,EAAE9F,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC9D;MACE,IAAI+F,GAAG,GAAG9F,IAAI,CAACD,CAAC,CAAC;MAEjB1C,CAAC,CAACyI,GAAG,EAAExI,EAAE,EAAE,YAAY,CAAC;IAC1B;EAAE;AACR,CAAC;AACDF,IAAI,CAAC2I,gBAAgB,GAAG,UAAUhJ,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC7CA,CAAC,CAACN,IAAI,CAACgE,MAAM,EAAEzD,EAAE,EAAE,YAAY,CAAC;EAChC,IAAIP,IAAI,CAACkH,QAAQ,EAAE;IAAE5G,CAAC,CAACN,IAAI,CAACiJ,QAAQ,EAAE1I,EAAE,EAAE,YAAY,CAAC;EAAE;AAC3D,CAAC;AACDF,IAAI,CAAC6I,sBAAsB,GAAG7I,IAAI,CAAC8I,wBAAwB,GAAG,UAAUnJ,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACnF,IAAIN,IAAI,CAACoJ,WAAW,EAClB;IAAE9I,CAAC,CAACN,IAAI,CAACoJ,WAAW,EAAE7I,EAAE,EAAEP,IAAI,CAACQ,IAAI,KAAK,wBAAwB,IAAIR,IAAI,CAACoJ,WAAW,CAAC/C,EAAE,GAAG,WAAW,GAAG,YAAY,CAAC;EAAE;EACzH,IAAIrG,IAAI,CAACqJ,MAAM,EAAE;IAAE/I,CAAC,CAACN,IAAI,CAACqJ,MAAM,EAAE9I,EAAE,EAAE,YAAY,CAAC;EAAE;AACvD,CAAC;AACDF,IAAI,CAACiJ,oBAAoB,GAAG,UAAUtJ,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACjDA,CAAC,CAACN,IAAI,CAACqJ,MAAM,EAAE9I,EAAE,EAAE,YAAY,CAAC;AAClC,CAAC;AACDF,IAAI,CAACkJ,iBAAiB,GAAG,UAAUvJ,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC9C,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACwJ,UAAU,EAAExG,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EAC7D;IACA,IAAIyG,IAAI,GAAGxG,IAAI,CAACD,CAAC,CAAC;IAElB1C,CAAC,CAACmJ,IAAI,EAAElJ,EAAE,CAAC;EACb;EACAD,CAAC,CAACN,IAAI,CAACqJ,MAAM,EAAE9I,EAAE,EAAE,YAAY,CAAC;AAClC,CAAC;AACDF,IAAI,CAACqJ,eAAe,GAAGrJ,IAAI,CAACsJ,sBAAsB,GAAGtJ,IAAI,CAACuJ,wBAAwB,GAAGvJ,IAAI,CAACwJ,UAAU,GAAGxJ,IAAI,CAACyJ,OAAO,GAAGzJ,IAAI,CAAC0J,MAAM,GAAGrH,MAAM;AAE1IrC,IAAI,CAAC2J,wBAAwB,GAAG,UAAUhK,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACrDA,CAAC,CAACN,IAAI,CAACiK,GAAG,EAAE1J,EAAE,EAAE,YAAY,CAAC;EAC7BD,CAAC,CAACN,IAAI,CAACkI,KAAK,EAAE3H,EAAE,EAAE,YAAY,CAAC;AACjC,CAAC;AACDF,IAAI,CAAC6J,gBAAgB,GAAG7J,IAAI,CAAC8J,eAAe,GAAG,UAAUnK,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAAE,OAAOA,CAAC,CAACN,IAAI,EAAEO,EAAE,EAAE,OAAO,CAAC;AAAE,CAAC;AACtGF,IAAI,CAAC+J,KAAK,GAAG,UAAUpK,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAClC,IAAIN,IAAI,CAACqG,EAAE,EAAE;IAAE/F,CAAC,CAACN,IAAI,CAACqG,EAAE,EAAE9F,EAAE,EAAE,SAAS,CAAC;EAAE;EAC1C,IAAIP,IAAI,CAACqK,UAAU,EAAE;IAAE/J,CAAC,CAACN,IAAI,CAACqK,UAAU,EAAE9J,EAAE,EAAE,YAAY,CAAC;EAAE;EAC7DD,CAAC,CAACN,IAAI,CAACkD,IAAI,EAAE3C,EAAE,CAAC;AAClB,CAAC;AACDF,IAAI,CAACiK,SAAS,GAAG,UAAUtK,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EACtC,KAAK,IAAI0C,CAAC,GAAG,CAAC,EAAEC,IAAI,GAAGjD,IAAI,CAACkD,IAAI,EAAEF,CAAC,GAAGC,IAAI,CAACpC,MAAM,EAAEmC,CAAC,IAAI,CAAC,EACvD;IACA,IAAI8D,GAAG,GAAG7D,IAAI,CAACD,CAAC,CAAC;IAEjB1C,CAAC,CAACwG,GAAG,EAAEvG,EAAE,CAAC;EACZ;AACF,CAAC;AACDF,IAAI,CAACkK,gBAAgB,GAAGlK,IAAI,CAACmK,QAAQ,GAAG,UAAUxK,IAAI,EAAEO,EAAE,EAAED,CAAC,EAAE;EAC7D,IAAIN,IAAI,CAACkH,QAAQ,EAAE;IAAE5G,CAAC,CAACN,IAAI,CAACmH,GAAG,EAAE5G,EAAE,EAAE,YAAY,CAAC;EAAE;EACpDD,CAAC,CAACN,IAAI,CAACoH,KAAK,EAAE7G,EAAE,EAAE,YAAY,CAAC;AACjC,CAAC;AAED,SAASG,QAAQ,EAAEL,IAAI,EAAE4B,aAAa,EAAEF,cAAc,EAAEJ,UAAU,EAAEO,cAAc,EAAEV,IAAI,EAAEE,YAAY,EAAEP,IAAI,EAAEH,SAAS,EAAEjB,MAAM"},"metadata":{},"sourceType":"module","externalDependencies":[]}