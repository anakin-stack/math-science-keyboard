{"ast":null,"code":"\"use strict\";\n\n// Returns \"Type(value) is Object\" in ES terminology.\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\nfunction mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\nmodule.exports = exports = {\n  isObject,\n  getReferenceToBytes,\n  getCopyToBytes,\n  mixin,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  IteratorPrototype\n};","map":{"version":3,"names":["isObject","value","getReferenceToBytes","bufferSource","Object","getPrototypeOf","Buffer","prototype","ArrayBuffer","from","buffer","byteOffset","byteLength","getCopyToBytes","mixin","target","source","keys","getOwnPropertyNames","i","length","defineProperty","getOwnPropertyDescriptor","wrapperSymbol","Symbol","implSymbol","sameObjectCaches","getSameObject","wrapper","prop","creator","create","wrapperForImpl","impl","implForWrapper","tryWrapperForImpl","tryImplForWrapper","iterInternalSymbol","IteratorPrototype","iterator","module","exports"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/domexception/lib/utils.js"],"sourcesContent":["\"use strict\";\n\n// Returns \"Type(value) is Object\" in ES terminology.\nfunction isObject(value) {\n  return typeof value === \"object\" && value !== null || typeof value === \"function\";\n}\n\nfunction getReferenceToBytes(bufferSource) {\n  // Node.js' Buffer does not allow subclassing for now, so we can get away with a prototype object check for perf.\n  if (Object.getPrototypeOf(bufferSource) === Buffer.prototype) {\n    return bufferSource;\n  }\n  if (bufferSource instanceof ArrayBuffer) {\n    return Buffer.from(bufferSource);\n  }\n  return Buffer.from(bufferSource.buffer, bufferSource.byteOffset, bufferSource.byteLength);\n}\n\nfunction getCopyToBytes(bufferSource) {\n  return Buffer.from(getReferenceToBytes(bufferSource));\n}\n\nfunction mixin(target, source) {\n  const keys = Object.getOwnPropertyNames(source);\n  for (let i = 0; i < keys.length; ++i) {\n    if (keys[i] in target) {\n      continue;\n    }\n\n    Object.defineProperty(target, keys[i], Object.getOwnPropertyDescriptor(source, keys[i]));\n  }\n}\n\nconst wrapperSymbol = Symbol(\"wrapper\");\nconst implSymbol = Symbol(\"impl\");\nconst sameObjectCaches = Symbol(\"SameObject caches\");\n\nfunction getSameObject(wrapper, prop, creator) {\n  if (!wrapper[sameObjectCaches]) {\n    wrapper[sameObjectCaches] = Object.create(null);\n  }\n\n  if (prop in wrapper[sameObjectCaches]) {\n    return wrapper[sameObjectCaches][prop];\n  }\n\n  wrapper[sameObjectCaches][prop] = creator();\n  return wrapper[sameObjectCaches][prop];\n}\n\nfunction wrapperForImpl(impl) {\n  return impl ? impl[wrapperSymbol] : null;\n}\n\nfunction implForWrapper(wrapper) {\n  return wrapper ? wrapper[implSymbol] : null;\n}\n\nfunction tryWrapperForImpl(impl) {\n  const wrapper = wrapperForImpl(impl);\n  return wrapper ? wrapper : impl;\n}\n\nfunction tryImplForWrapper(wrapper) {\n  const impl = implForWrapper(wrapper);\n  return impl ? impl : wrapper;\n}\n\nconst iterInternalSymbol = Symbol(\"internal\");\nconst IteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));\n\nmodule.exports = exports = {\n  isObject,\n  getReferenceToBytes,\n  getCopyToBytes,\n  mixin,\n  wrapperSymbol,\n  implSymbol,\n  getSameObject,\n  wrapperForImpl,\n  implForWrapper,\n  tryWrapperForImpl,\n  tryImplForWrapper,\n  iterInternalSymbol,\n  IteratorPrototype\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}