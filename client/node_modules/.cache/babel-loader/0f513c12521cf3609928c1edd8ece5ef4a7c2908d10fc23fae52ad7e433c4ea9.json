{"ast":null,"code":"// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 157, 310, 10, 21, 11, 7, 153, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 477, 28, 11, 0, 9, 21, 190, 52, 76, 44, 33, 24, 27, 35, 30, 0, 12, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 85, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 54, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 86, 26, 230, 43, 117, 63, 32, 0, 257, 0, 11, 39, 8, 0, 22, 0, 12, 39, 3, 3, 20, 0, 35, 56, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 270, 921, 103, 110, 18, 195, 2749, 1070, 4050, 582, 8634, 568, 8, 30, 114, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 68, 12, 0, 67, 12, 65, 1, 31, 6129, 15, 754, 9486, 286, 82, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 4149, 196, 60, 67, 1213, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42710, 42, 4148, 12, 221, 3, 5761, 15, 7472, 3104, 541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 525, 10, 176, 2, 54, 14, 32, 9, 16, 3, 46, 10, 54, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 4, 9, 83, 11, 7, 0, 161, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 280, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 19306, 9, 135, 4, 60, 6, 26, 9, 1016, 45, 17, 3, 19723, 1, 5319, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 2214, 6, 110, 6, 6, 9, 792487, 239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) {\n      return false;\n    }\n    pos += set[i + 1];\n    if (pos >= code) {\n      return true;\n    }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) {\n    return code === 36;\n  }\n  if (code < 91) {\n    return true;\n  }\n  if (code < 97) {\n    return code === 95;\n  }\n  if (code < 123) {\n    return true;\n  }\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code));\n  }\n  if (astral === false) {\n    return false;\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes);\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) {\n    return code === 36;\n  }\n  if (code < 58) {\n    return true;\n  }\n  if (code < 65) {\n    return false;\n  }\n  if (code < 91) {\n    return true;\n  }\n  if (code < 97) {\n    return code === 95;\n  }\n  if (code < 123) {\n    return true;\n  }\n  if (code <= 0xffff) {\n    return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code));\n  }\n  if (astral === false) {\n    return false;\n  }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes);\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if (conf === void 0) conf = {};\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\nfunction binop(name, prec) {\n  return new TokenType(name, {\n    beforeExpr: true,\n    binop: prec\n  });\n}\nvar beforeExpr = {\n  beforeExpr: true\n};\nvar startsExpr = {\n  startsExpr: true\n};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if (options === void 0) options = {};\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options);\n}\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  assign: new TokenType(\"_=\", {\n    beforeExpr: true,\n    isAssign: true\n  }),\n  incDec: new TokenType(\"++/--\", {\n    prefix: true,\n    postfix: true,\n    startsExpr: true\n  }),\n  prefix: new TokenType(\"!/~\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {\n    beforeExpr: true,\n    binop: 9,\n    prefix: true,\n    startsExpr: true\n  }),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {\n    beforeExpr: true\n  }),\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {\n    isLoop: true,\n    beforeExpr: true\n  }),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {\n    isLoop: true\n  }),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {\n    isLoop: true\n  }),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {\n    beforeExpr: true,\n    startsExpr: true\n  }),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _instanceof: kw(\"instanceof\", {\n    beforeExpr: true,\n    binop: 7\n  }),\n  _typeof: kw(\"typeof\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _void: kw(\"void\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  }),\n  _delete: kw(\"delete\", {\n    beforeExpr: true,\n    prefix: true,\n    startsExpr: true\n  })\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || !ecma2019String && (code === 0x2028 || code === 0x2029);\n}\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName);\n}\nvar isArray = Array.isArray || function (obj) {\n  return toString.call(obj) === \"[object Array]\";\n};\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\nPosition.prototype.offset = function offset(n) {\n  return new Position(this.line, this.column + n);\n};\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) {\n    this.source = p.sourceFile;\n  }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur);\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n  for (var opt in defaultOptions) {\n    options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt];\n  }\n  if (options.ecmaVersion >= 2015) {\n    options.ecmaVersion -= 2009;\n  }\n  if (options.allowReserved == null) {\n    options.allowReserved = options.ecmaVersion < 5;\n  }\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) {\n      return tokens.push(token);\n    };\n  }\n  if (isArray(options.onComment)) {\n    options.onComment = pushComment(options, options.onComment);\n  }\n  return options;\n}\nfunction pushComment(options, array) {\n  return function (block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations) {\n      comment.loc = new SourceLocation(this, startLoc, endLoc);\n    }\n    if (options.ranges) {\n      comment.range = [start, end];\n    }\n    array.push(comment);\n  };\n}\n\n// Registered plugins\nvar plugins = {};\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\");\n}\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--) {\n      if (reserved = reservedWords[v]) {\n        break;\n      }\n    }\n    if (options.sourceType === \"module\") {\n      reserved += \" await\";\n    }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\") {\n    this.skipLineComment(2);\n  }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword(word) {\n  return this.keywords.test(word);\n};\nParser.prototype.isReservedWord = function isReservedWord(word) {\n  return this.reservedWords.test(word);\n};\nParser.prototype.extend = function extend(name, f) {\n  this[name] = f(this[name]);\n};\nParser.prototype.loadPlugins = function loadPlugins(pluginConfigs) {\n  var this$1 = this;\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) {\n      throw new Error(\"Plugin '\" + name + \"' not found\");\n    }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\nParser.prototype.parse = function parse() {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node);\n};\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\npp.strictDirective = function (start) {\n  var this$1 = this;\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) {\n      return false;\n    }\n    if ((match[1] || match[2]) === \"use strict\") {\n      return true;\n    }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function (type) {\n  if (this.type === type) {\n    this.next();\n    return true;\n  } else {\n    return false;\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function (name) {\n  return this.type === types.name && this.value === name && !this.containsEsc;\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function (name) {\n  if (!this.isContextual(name)) {\n    return false;\n  }\n  this.next();\n  return true;\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function (name) {\n  if (!this.eatContextual(name)) {\n    this.unexpected();\n  }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function () {\n  return this.type === types.eof || this.type === types.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\npp.insertSemicolon = function () {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon) {\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc);\n    }\n    return true;\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function () {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) {\n    this.unexpected();\n  }\n};\npp.afterTrailingComma = function (tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma) {\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc);\n    }\n    if (!notNext) {\n      this.next();\n    }\n    return true;\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function (type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function (pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\nfunction DestructuringErrors() {\n  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;\n}\npp.checkPatternErrors = function (refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) {\n    return;\n  }\n  if (refDestructuringErrors.trailingComma > -1) {\n    this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\");\n  }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) {\n    this.raiseRecoverable(parens, \"Parenthesized pattern\");\n  }\n};\npp.checkExpressionErrors = function (refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) {\n    return false;\n  }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) {\n    return shorthandAssign >= 0 || doubleProto >= 0;\n  }\n  if (shorthandAssign >= 0) {\n    this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\");\n  }\n  if (doubleProto >= 0) {\n    this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\");\n  }\n};\npp.checkYieldAwaitInDefaultParams = function () {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos)) {\n    this.raise(this.yieldPos, \"Yield expression cannot be a default value\");\n  }\n  if (this.awaitPos) {\n    this.raise(this.awaitPos, \"Await expression cannot be a default value\");\n  }\n};\npp.isSimpleAssignTarget = function (expr) {\n  if (expr.type === \"ParenthesizedExpression\") {\n    return this.isSimpleAssignTarget(expr.expression);\n  }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\";\n};\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function (node) {\n  var this$1 = this;\n  var exports = {};\n  if (!node.body) {\n    node.body = [];\n  }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\");\n};\nvar loopLabel = {\n  kind: \"loop\"\n};\nvar switchLabel = {\n  kind: \"switch\"\n};\npp$1.isLet = function () {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) {\n    return false;\n  }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length,\n    nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh === 123) {\n    return true;\n  } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) {\n      ++pos;\n    }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) {\n      return true;\n    }\n  }\n  return false;\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function () {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\")) {\n    return false;\n  }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) && this.input.slice(next, next + 8) === \"function\" && (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)));\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function (declaration, topLevel, exports) {\n  var starttype = this.type,\n    node = this.startNode(),\n    kind;\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n    case types._break:\n    case types._continue:\n      return this.parseBreakContinueStatement(node, starttype.keyword);\n    case types._debugger:\n      return this.parseDebuggerStatement(node);\n    case types._do:\n      return this.parseDoStatement(node);\n    case types._for:\n      return this.parseForStatement(node);\n    case types._function:\n      if (!declaration && this.options.ecmaVersion >= 6) {\n        this.unexpected();\n      }\n      return this.parseFunctionStatement(node, false);\n    case types._class:\n      if (!declaration) {\n        this.unexpected();\n      }\n      return this.parseClass(node, true);\n    case types._if:\n      return this.parseIfStatement(node);\n    case types._return:\n      return this.parseReturnStatement(node);\n    case types._switch:\n      return this.parseSwitchStatement(node);\n    case types._throw:\n      return this.parseThrowStatement(node);\n    case types._try:\n      return this.parseTryStatement(node);\n    case types._const:\n    case types._var:\n      kind = kind || this.value;\n      if (!declaration && kind !== \"var\") {\n        this.unexpected();\n      }\n      return this.parseVarStatement(node, kind);\n    case types._while:\n      return this.parseWhileStatement(node);\n    case types._with:\n      return this.parseWithStatement(node);\n    case types.braceL:\n      return this.parseBlock();\n    case types.semi:\n      return this.parseEmptyStatement(node);\n    case types._export:\n    case types._import:\n      if (!this.options.allowImportExportEverywhere) {\n        if (!topLevel) {\n          this.raise(this.start, \"'import' and 'export' may only appear at the top level\");\n        }\n        if (!this.inModule) {\n          this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\");\n        }\n      }\n      return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports);\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    default:\n      if (this.isAsyncFunction()) {\n        if (!declaration) {\n          this.unexpected();\n        }\n        this.next();\n        return this.parseFunctionStatement(node, true);\n      }\n      var maybeName = this.value,\n        expr = this.parseExpression();\n      if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon)) {\n        return this.parseLabeledStatement(node, maybeName, expr);\n      } else {\n        return this.parseExpressionStatement(node, expr);\n      }\n  }\n};\npp$1.parseBreakContinueStatement = function (node, keyword) {\n  var this$1 = this;\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.label = null;\n  } else if (this.type !== types.name) {\n    this.unexpected();\n  } else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) {\n        break;\n      }\n      if (node.label && isBreak) {\n        break;\n      }\n    }\n  }\n  if (i === this.labels.length) {\n    this.raise(node.start, \"Unsyntactic \" + keyword);\n  }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\");\n};\npp$1.parseDebuggerStatement = function (node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\");\n};\npp$1.parseDoStatement = function (node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6) {\n    this.eat(types.semi);\n  } else {\n    this.semicolon();\n  }\n  return this.finishNode(node, \"DoWhileStatement\");\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function (node) {\n  this.next();\n  var awaitAt = this.options.ecmaVersion >= 9 && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction) && this.eatContextual(\"await\") ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, null);\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(),\n      kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) && init$1.declarations.length === 1 && !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) {\n            this.unexpected(awaitAt);\n          }\n        } else {\n          node.await = awaitAt > -1;\n        }\n      }\n      return this.parseForIn(node, init$1);\n    }\n    if (awaitAt > -1) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node, init$1);\n  }\n  var refDestructuringErrors = new DestructuringErrors();\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || this.options.ecmaVersion >= 6 && this.isContextual(\"of\")) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) {\n          this.unexpected(awaitAt);\n        }\n      } else {\n        node.await = awaitAt > -1;\n      }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init);\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) {\n    this.unexpected(awaitAt);\n  }\n  return this.parseFor(node, init);\n};\npp$1.parseFunctionStatement = function (node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync);\n};\npp$1.parseIfStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n  return this.finishNode(node, \"IfStatement\");\n};\npp$1.parseReturnStatement = function (node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction) {\n    this.raise(this.start, \"'return' outside of function\");\n  }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) {\n    node.argument = null;\n  } else {\n    node.argument = this.parseExpression();\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ReturnStatement\");\n};\npp$1.parseSwitchStatement = function (node) {\n  var this$1 = this;\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) {\n        this$1.finishNode(cur, \"SwitchCase\");\n      }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) {\n          this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\");\n        }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) {\n        this$1.unexpected();\n      }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) {\n    this.finishNode(cur, \"SwitchCase\");\n  }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\");\n};\npp$1.parseThrowStatement = function (node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) {\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\");\n  }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\");\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\npp$1.parseTryStatement = function (node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      this.enterLexicalScope();\n      this.checkLVal(clause.param, \"let\");\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) {\n        this.unexpected();\n      }\n      clause.param = null;\n      this.enterLexicalScope();\n    }\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer) {\n    this.raise(node.start, \"Missing catch or finally clause\");\n  }\n  return this.finishNode(node, \"TryStatement\");\n};\npp$1.parseVarStatement = function (node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\");\n};\npp$1.parseWhileStatement = function (node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\");\n};\npp$1.parseWithStatement = function (node) {\n  if (this.strict) {\n    this.raise(this.start, \"'with' in strict mode\");\n  }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\");\n};\npp$1.parseEmptyStatement = function (node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\");\n};\npp$1.parseLabeledStatement = function (node, maybeName, expr) {\n  var this$1 = this;\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1) {\n    var label = list[i$1];\n    if (label.name === maybeName) {\n      this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n    }\n  }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else {\n      break;\n    }\n  }\n  this.labels.push({\n    name: maybeName,\n    kind: kind,\n    statementStart: this.start\n  });\n  node.body = this.parseStatement(true);\n  if (node.body.type === \"ClassDeclaration\" || node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" || node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async)) {\n    this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\");\n  }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\");\n};\npp$1.parseExpressionStatement = function (node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\");\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function (createNewLexicalScope) {\n  var this$1 = this;\n  if (createNewLexicalScope === void 0) createNewLexicalScope = true;\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\");\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function (node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\");\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function (node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  if (type === \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" || init.type === \"VariableDeclaration\" && init.declarations[0].init != null && (this.strict || init.declarations[0].id.type !== \"Identifier\")) {\n      this.raise(init.start, \"Invalid assignment in for-in loop head\");\n    }\n  }\n  node.left = init;\n  node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type);\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function (node, isFor, kind) {\n  var this$1 = this;\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\"))) {\n      this$1.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) {\n      break;\n    }\n  }\n  return node;\n};\npp$1.parseVarId = function (decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function (node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync) {\n    node.generator = this.eat(types.star);\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n    }\n  }\n  var oldInGen = this.inGenerator,\n    oldInAsync = this.inAsync,\n    oldYieldPos = this.yieldPos,\n    oldAwaitPos = this.awaitPos,\n    oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n  if (!isStatement) {\n    node.id = this.type === types.name ? this.parseIdent() : null;\n  }\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\");\n};\npp$1.parseFunctionParams = function (node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function (node, isStatement) {\n  var this$1 = this;\n  this.next();\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) {\n        this$1.raise(member.start, \"Duplicate constructor in the same class\");\n      }\n      hadConstructor = true;\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\");\n};\npp$1.parseClassMember = function (classBody) {\n  var this$1 = this;\n  if (this.eat(types.semi)) {\n    return null;\n  }\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if (noLineBreak === void 0) noLineBreak = false;\n    var start = this$1.start,\n      startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) {\n      return false;\n    }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) {\n      return true;\n    }\n    if (method.key) {\n      this$1.unexpected();\n    }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false;\n  };\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) {\n    this.parsePropertyName(method);\n  }\n  var key = method.key;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" || key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") {\n      this.raise(key.start, \"Constructor can't have get/set modifier\");\n    }\n    if (isGenerator) {\n      this.raise(key.start, \"Constructor can't be a generator\");\n    }\n    if (isAsync) {\n      this.raise(key.start, \"Constructor can't be an async method\");\n    }\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n  if (method.kind === \"get\" && method.value.params.length !== 0) {\n    this.raiseRecoverable(method.value.start, \"getter should have no params\");\n  }\n  if (method.kind === \"set\" && method.value.params.length !== 1) {\n    this.raiseRecoverable(method.value.start, \"setter should have exactly one param\");\n  }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\") {\n    this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\");\n  }\n  return method;\n};\npp$1.parseClassMethod = function (classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\npp$1.parseClassId = function (node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\npp$1.parseClassSuper = function (node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function (node, exports) {\n  var this$1 = this;\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) {\n      this.unexpected();\n    }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\");\n  }\n  if (this.eat(types._default)) {\n    // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) {\n        this.next();\n      }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\");\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\") {\n      this.checkVariableExport(exports, node.declaration.declarations);\n    } else {\n      this.checkExport(exports, node.declaration.id.name, node.declaration.id.start);\n    }\n    node.specifiers = [];\n    node.source = null;\n  } else {\n    // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) {\n        this.unexpected();\n      }\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n        this$1.checkUnreserved(spec.local);\n      }\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\");\n};\npp$1.checkExport = function (exports, name, pos) {\n  if (!exports) {\n    return;\n  }\n  if (has(exports, name)) {\n    this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\");\n  }\n  exports[name] = true;\n};\npp$1.checkPatternExport = function (exports, pat) {\n  var this$1 = this;\n  var type = pat.type;\n  if (type === \"Identifier\") {\n    this.checkExport(exports, pat.name, pat.start);\n  } else if (type === \"ObjectPattern\") {\n    for (var i = 0, list = pat.properties; i < list.length; i += 1) {\n      var prop = list[i];\n      this$1.checkPatternExport(exports, prop);\n    }\n  } else if (type === \"ArrayPattern\") {\n    for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n      if (elt) {\n        this$1.checkPatternExport(exports, elt);\n      }\n    }\n  } else if (type === \"Property\") {\n    this.checkPatternExport(exports, pat.value);\n  } else if (type === \"AssignmentPattern\") {\n    this.checkPatternExport(exports, pat.left);\n  } else if (type === \"RestElement\") {\n    this.checkPatternExport(exports, pat.argument);\n  } else if (type === \"ParenthesizedExpression\") {\n    this.checkPatternExport(exports, pat.expression);\n  }\n};\npp$1.checkVariableExport = function (exports, decls) {\n  var this$1 = this;\n  if (!exports) {\n    return;\n  }\n  for (var i = 0, list = decls; i < list.length; i += 1) {\n    var decl = list[i];\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\npp$1.shouldParseExportStatement = function () {\n  return this.type.keyword === \"var\" || this.type.keyword === \"const\" || this.type.keyword === \"class\" || this.type.keyword === \"function\" || this.isLet() || this.isAsyncFunction();\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function (exports) {\n  var this$1 = this;\n  var nodes = [],\n    first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes;\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function (node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\");\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function () {\n  var this$1 = this;\n  var nodes = [],\n    first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) {\n      return nodes;\n    }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes;\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes;\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function (statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function (statement) {\n  return statement.type === \"ExpressionStatement\" && statement.expression.type === \"Literal\" && typeof statement.expression.value === \"string\" && (\n  // Reject parenthesized strings.\n  this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\");\n};\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function (node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n      case \"Identifier\":\n        if (this.inAsync && node.name === \"await\") {\n          this.raise(node.start, \"Can not use 'await' as identifier inside an async function\");\n        }\n        break;\n      case \"ObjectPattern\":\n      case \"ArrayPattern\":\n      case \"RestElement\":\n        break;\n      case \"ObjectExpression\":\n        node.type = \"ObjectPattern\";\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n        for (var i = 0, list = node.properties; i < list.length; i += 1) {\n          var prop = list[i];\n          this$1.toAssignable(prop, isBinding);\n          // Early error:\n          //   AssignmentRestProperty[Yield, Await] :\n          //     `...` DestructuringAssignmentTarget[Yield, Await]\n          //\n          //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n          if (prop.type === \"RestElement\" && (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")) {\n            this$1.raise(prop.argument.start, \"Unexpected token\");\n          }\n        }\n        break;\n      case \"Property\":\n        // AssignmentProperty has type === \"Property\"\n        if (node.kind !== \"init\") {\n          this.raise(node.key.start, \"Object pattern can't contain getter or setter\");\n        }\n        this.toAssignable(node.value, isBinding);\n        break;\n      case \"ArrayExpression\":\n        node.type = \"ArrayPattern\";\n        if (refDestructuringErrors) {\n          this.checkPatternErrors(refDestructuringErrors, true);\n        }\n        this.toAssignableList(node.elements, isBinding);\n        break;\n      case \"SpreadElement\":\n        node.type = \"RestElement\";\n        this.toAssignable(node.argument, isBinding);\n        if (node.argument.type === \"AssignmentPattern\") {\n          this.raise(node.argument.start, \"Rest elements cannot have a default value\");\n        }\n        break;\n      case \"AssignmentExpression\":\n        if (node.operator !== \"=\") {\n          this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\");\n        }\n        node.type = \"AssignmentPattern\";\n        delete node.operator;\n        this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n      case \"AssignmentPattern\":\n        break;\n      case \"ParenthesizedExpression\":\n        this.toAssignable(node.expression, isBinding);\n        break;\n      case \"MemberExpression\":\n        if (!isBinding) {\n          break;\n        }\n      default:\n        this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) {\n    this.checkPatternErrors(refDestructuringErrors, true);\n  }\n  return node;\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function (exprList, isBinding) {\n  var this$1 = this;\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) {\n      this$1.toAssignable(elt, isBinding);\n    }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\") {\n      this.unexpected(last.argument.start);\n    }\n  }\n  return exprList;\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function (refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\");\n};\npp$2.parseRestBinding = function () {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name) {\n    this.unexpected();\n  }\n  node.argument = this.parseBindingAtom();\n  return this.finishNode(node, \"RestElement\");\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function () {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n      case types.bracketL:\n        var node = this.startNode();\n        this.next();\n        node.elements = this.parseBindingList(types.bracketR, true, true);\n        return this.finishNode(node, \"ArrayPattern\");\n      case types.braceL:\n        return this.parseObj(true);\n    }\n  }\n  return this.parseIdent();\n};\npp$2.parseBindingList = function (close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n  var elts = [],\n    first = true;\n  while (!this.eat(close)) {\n    if (first) {\n      first = false;\n    } else {\n      this$1.expect(types.comma);\n    }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break;\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) {\n        this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n      }\n      this$1.expect(close);\n      break;\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts;\n};\npp$2.parseBindingListItem = function (param) {\n  return param;\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function (startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) {\n    return left;\n  }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\");\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function (expr, bindingType, checkClashes) {\n  var this$1 = this;\n  switch (expr.type) {\n    case \"Identifier\":\n      if (this.strict && this.reservedWordsStrictBind.test(expr.name)) {\n        this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\");\n      }\n      if (checkClashes) {\n        if (has(checkClashes, expr.name)) {\n          this.raiseRecoverable(expr.start, \"Argument name clash\");\n        }\n        checkClashes[expr.name] = true;\n      }\n      if (bindingType && bindingType !== \"none\") {\n        if (bindingType === \"var\" && !this.canDeclareVarName(expr.name) || bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)) {\n          this.raiseRecoverable(expr.start, \"Identifier '\" + expr.name + \"' has already been declared\");\n        }\n        if (bindingType === \"var\") {\n          this.declareVarName(expr.name);\n        } else {\n          this.declareLexicalName(expr.name);\n        }\n      }\n      break;\n    case \"MemberExpression\":\n      if (bindingType) {\n        this.raiseRecoverable(expr.start, \"Binding member expression\");\n      }\n      break;\n    case \"ObjectPattern\":\n      for (var i = 0, list = expr.properties; i < list.length; i += 1) {\n        var prop = list[i];\n        this$1.checkLVal(prop, bindingType, checkClashes);\n      }\n      break;\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      this.checkLVal(expr.value, bindingType, checkClashes);\n      break;\n    case \"ArrayPattern\":\n      for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n        var elem = list$1[i$1];\n        if (elem) {\n          this$1.checkLVal(elem, bindingType, checkClashes);\n        }\n      }\n      break;\n    case \"AssignmentPattern\":\n      this.checkLVal(expr.left, bindingType, checkClashes);\n      break;\n    case \"RestElement\":\n      this.checkLVal(expr.argument, bindingType, checkClashes);\n      break;\n    case \"ParenthesizedExpression\":\n      this.checkLVal(expr.expression, bindingType, checkClashes);\n      break;\n    default:\n      this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function (prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\") {\n    return;\n  }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand)) {\n    return;\n  }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n    case \"Identifier\":\n      name = key.name;\n      break;\n    case \"Literal\":\n      name = String(key.value);\n      break;\n    default:\n      return;\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) {\n          refDestructuringErrors.doubleProto = key.start;\n        }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else {\n          this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\");\n        }\n      }\n      propHash.proto = true;\n    }\n    return;\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition) {\n      this.raiseRecoverable(key.start, \"Redefinition of property\");\n    }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function (noIn, refDestructuringErrors) {\n  var this$1 = this;\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) {\n      node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors));\n    }\n    return this.finishNode(node, \"SequenceExpression\");\n  }\n  return expr;\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function (noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) {\n    return this.parseYield();\n  }\n  var ownDestructuringErrors = false,\n    oldParenAssign = -1,\n    oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors();\n    ownDestructuringErrors = true;\n  }\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name) {\n    this.potentialArrowAt = this.start;\n  }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) {\n    left = afterLeftParse.call(this, left, startPos, startLoc);\n  }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) {\n      DestructuringErrors.call(refDestructuringErrors);\n    }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\");\n  } else {\n    if (ownDestructuringErrors) {\n      this.checkExpressionErrors(refDestructuringErrors, true);\n    }\n  }\n  if (oldParenAssign > -1) {\n    refDestructuringErrors.parenthesizedAssign = oldParenAssign;\n  }\n  if (oldTrailingComma > -1) {\n    refDestructuringErrors.trailingComma = oldTrailingComma;\n  }\n  return left;\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\");\n  }\n  return expr;\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function (noIn, refDestructuringErrors) {\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) {\n    return expr;\n  }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn);\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function (left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start,\n        startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn);\n    }\n  }\n  return left;\n};\npp$3.buildBinary = function (startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\");\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function (refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n  var startPos = this.start,\n    startLoc = this.startLoc,\n    expr;\n  if (this.isContextual(\"await\") && (this.inAsync || !this.inFunction && this.options.allowAwaitOutsideFunction)) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(),\n      update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) {\n      this.checkLVal(node.argument);\n    } else if (this.strict && node.operator === \"delete\" && node.argument.type === \"Identifier\") {\n      this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\");\n    } else {\n      sawUnary = true;\n    }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) {\n      return expr;\n    }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n  if (!sawUnary && this.eat(types.starstar)) {\n    return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false);\n  } else {\n    return expr;\n  }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function (refDestructuringErrors) {\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) {\n    return expr;\n  }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) {\n      refDestructuringErrors.parenthesizedAssign = -1;\n    }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) {\n      refDestructuringErrors.parenthesizedBind = -1;\n    }\n  }\n  return result;\n};\npp$3.parseSubscripts = function (base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" && this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  for (var computed = void 0;;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) {\n        this$1.expect(types.bracketR);\n      }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors(),\n        oldYieldPos = this$1.yieldPos,\n        oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true);\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({\n        isTagged: true\n      });\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base;\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function (refDestructuringErrors) {\n  var node,\n    canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n    case types._super:\n      if (!this.inFunction) {\n        this.raise(this.start, \"'super' outside of function or class\");\n      }\n      node = this.startNode();\n      this.next();\n      // The `super` keyword can appear at below:\n      // SuperProperty:\n      //     super [ Expression ]\n      //     super . IdentifierName\n      // SuperCall:\n      //     super Arguments\n      if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL) {\n        this.unexpected();\n      }\n      return this.finishNode(node, \"Super\");\n    case types._this:\n      node = this.startNode();\n      this.next();\n      return this.finishNode(node, \"ThisExpression\");\n    case types.name:\n      var startPos = this.start,\n        startLoc = this.startLoc,\n        containsEsc = this.containsEsc;\n      var id = this.parseIdent(this.type !== types.name);\n      if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function)) {\n        return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true);\n      }\n      if (canBeArrow && !this.canInsertSemicolon()) {\n        if (this.eat(types.arrow)) {\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false);\n        }\n        if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n          id = this.parseIdent();\n          if (this.canInsertSemicolon() || !this.eat(types.arrow)) {\n            this.unexpected();\n          }\n          return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true);\n        }\n      }\n      return id;\n    case types.regexp:\n      var value = this.value;\n      node = this.parseLiteral(value.value);\n      node.regex = {\n        pattern: value.pattern,\n        flags: value.flags\n      };\n      return node;\n    case types.num:\n    case types.string:\n      return this.parseLiteral(this.value);\n    case types._null:\n    case types._true:\n    case types._false:\n      node = this.startNode();\n      node.value = this.type === types._null ? null : this.type === types._true;\n      node.raw = this.type.keyword;\n      this.next();\n      return this.finishNode(node, \"Literal\");\n    case types.parenL:\n      var start = this.start,\n        expr = this.parseParenAndDistinguishExpression(canBeArrow);\n      if (refDestructuringErrors) {\n        if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr)) {\n          refDestructuringErrors.parenthesizedAssign = start;\n        }\n        if (refDestructuringErrors.parenthesizedBind < 0) {\n          refDestructuringErrors.parenthesizedBind = start;\n        }\n      }\n      return expr;\n    case types.bracketL:\n      node = this.startNode();\n      this.next();\n      node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n      return this.finishNode(node, \"ArrayExpression\");\n    case types.braceL:\n      return this.parseObj(false, refDestructuringErrors);\n    case types._function:\n      node = this.startNode();\n      this.next();\n      return this.parseFunction(node, false);\n    case types._class:\n      return this.parseClass(this.startNode(), false);\n    case types._new:\n      return this.parseNew();\n    case types.backQuote:\n      return this.parseTemplate();\n    default:\n      this.unexpected();\n  }\n};\npp$3.parseLiteral = function (value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\");\n};\npp$3.parseParenExpression = function () {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val;\n};\npp$3.parseParenAndDistinguishExpression = function (canBeArrow) {\n  var this$1 = this;\n  var startPos = this.start,\n    startLoc = this.startLoc,\n    val,\n    allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n    var innerStartPos = this.start,\n      innerStartLoc = this.startLoc;\n    var exprList = [],\n      first = true,\n      lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors(),\n      oldYieldPos = this.yieldPos,\n      oldAwaitPos = this.awaitPos,\n      spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break;\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) {\n          this$1.raise(this$1.start, \"Comma is not permitted after the rest element\");\n        }\n        break;\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start,\n      innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList);\n    }\n    if (!exprList.length || lastIsComma) {\n      this.unexpected(this.lastTokStart);\n    }\n    if (spreadStart) {\n      this.unexpected(spreadStart);\n    }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\");\n  } else {\n    return val;\n  }\n};\npp$3.parseParenItem = function (item) {\n  return item;\n};\npp$3.parseParenArrowList = function (startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList);\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\npp$3.parseNew = function () {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc) {\n      this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\");\n    }\n    if (!this.inFunction) {\n      this.raiseRecoverable(node.start, \"new.target can only be used in functions\");\n    }\n    return this.finishNode(node, \"MetaProperty\");\n  }\n  var startPos = this.start,\n    startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) {\n    node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false);\n  } else {\n    node.arguments = empty$1;\n  }\n  return this.finishNode(node, \"NewExpression\");\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function (ref) {\n  var isTagged = ref.isTagged;\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\");\n};\npp$3.parseTemplate = function (ref) {\n  var this$1 = this;\n  if (ref === void 0) ref = {};\n  var isTagged = ref.isTagged;\n  if (isTagged === void 0) isTagged = false;\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({\n    isTagged: isTagged\n  });\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this$1.type === types.eof) {\n      this$1.raise(this$1.pos, \"Unterminated template literal\");\n    }\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({\n      isTagged: isTagged\n    }));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\");\n};\npp$3.isAsyncProp = function (prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" && (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function (isPattern, refDestructuringErrors) {\n  var this$1 = this;\n  var node = this.startNode(),\n    first = true,\n    propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) {\n      this$1.checkPropClash(prop, propHash, refDestructuringErrors);\n    }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\");\n};\npp$3.parseProperty = function (isPattern, refDestructuringErrors) {\n  var prop = this.startNode(),\n    isGenerator,\n    isAsync,\n    startPos,\n    startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\");\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\");\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern) {\n      isGenerator = this.eat(types.star);\n    }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\");\n};\npp$3.parsePropertyValue = function (prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon) {\n    this.unexpected();\n  }\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) {\n      this.unexpected();\n    }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc && this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" && (prop.key.name === \"get\" || prop.key.name === \"set\") && this.type !== types.comma && this.type !== types.braceR) {\n    if (isGenerator || isAsync) {\n      this.unexpected();\n    }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\") {\n        this.raiseRecoverable(start, \"getter should have no params\");\n      } else {\n        this.raiseRecoverable(start, \"setter should have exactly one param\");\n      }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\") {\n        this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\");\n      }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0) {\n        refDestructuringErrors.shorthandAssign = this.start;\n      }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else {\n    this.unexpected();\n  }\n};\npp$3.parsePropertyName = function (prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key;\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true);\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function (node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = false;\n  }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function (isGenerator, isAsync) {\n  var node = this.startNode(),\n    oldInGen = this.inGenerator,\n    oldInAsync = this.inAsync,\n    oldYieldPos = this.yieldPos,\n    oldAwaitPos = this.awaitPos,\n    oldInFunc = this.inFunction;\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = isGenerator;\n  }\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\");\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function (node, params, isAsync) {\n  var oldInGen = this.inGenerator,\n    oldInAsync = this.inAsync,\n    oldYieldPos = this.yieldPos,\n    oldAwaitPos = this.awaitPos,\n    oldInFunc = this.inFunction;\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8) {\n    node.async = !!isAsync;\n  }\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\");\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function (node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict,\n    useStrict = false;\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple) {\n        this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\");\n      }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) {\n      this.strict = true;\n    }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\npp$3.isSimpleParamList = function (params) {\n  for (var i = 0, list = params; i < list.length; i += 1) {\n    var param = list[i];\n    if (param.type !== \"Identifier\") {\n      return false;\n    }\n  }\n  return true;\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function (node, allowDuplicates) {\n  var this$1 = this;\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1) {\n    var param = list[i];\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function (close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n  var elts = [],\n    first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n        break;\n      }\n    } else {\n      first = false;\n    }\n    var elt = void 0;\n    if (allowEmpty && this$1.type === types.comma) {\n      elt = null;\n    } else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0) {\n        refDestructuringErrors.trailingComma = this$1.start;\n      }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts;\n};\npp$3.checkUnreserved = function (ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n  if (this.inGenerator && name === \"yield\") {\n    this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\");\n  }\n  if (this.inAsync && name === \"await\") {\n    this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\");\n  }\n  if (this.isKeyword(name)) {\n    this.raise(start, \"Unexpected keyword '\" + name + \"'\");\n  }\n  if (this.options.ecmaVersion < 6 && this.input.slice(start, end).indexOf(\"\\\\\") !== -1) {\n    return;\n  }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\") {\n      this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\");\n    }\n    this.raiseRecoverable(start, \"The keyword '\" + name + \"' is reserved\");\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function (liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved === \"never\") {\n    liberal = false;\n  }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) {\n    this.checkUnreserved(node);\n  }\n  return node;\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function () {\n  if (!this.yieldPos) {\n    this.yieldPos = this.start;\n  }\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || this.type !== types.star && !this.type.startsExpr) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\");\n};\npp$3.parseAwait = function () {\n  if (!this.awaitPos) {\n    this.awaitPos = this.start;\n  }\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\");\n};\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function (pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos;\n  err.loc = loc;\n  err.raisedAt = this.pos;\n  throw err;\n};\npp$4.raiseRecoverable = pp$4.raise;\npp$4.curPosition = function () {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart);\n  }\n};\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function (target) {\n  var sources = [],\n    len = arguments.length - 1;\n  while (len-- > 0) sources[len] = arguments[len + 1];\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function () {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({\n    var: {},\n    lexical: {},\n    childVar: {},\n    parentLexical: {}\n  });\n};\npp$5.exitFunctionScope = function () {\n  this.scopeStack.pop();\n};\npp$5.enterLexicalScope = function () {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {\n    var: {},\n    lexical: {},\n    childVar: {},\n    parentLexical: {}\n  };\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\npp$5.exitLexicalScope = function () {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function (name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name);\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function (name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name);\n};\npp$5.declareVarName = function (name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\npp$5.declareLexicalName = function (name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations) {\n    this.loc = new SourceLocation(parser, loc);\n  }\n  if (parser.options.directSourceFile) {\n    this.sourceFile = parser.options.directSourceFile;\n  }\n  if (parser.options.ranges) {\n    this.range = [pos, 0];\n  }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\npp$6.startNode = function () {\n  return new Node(this, this.start, this.startLoc);\n};\npp$6.startNodeAt = function (pos, loc) {\n  return new Node(this, pos, loc);\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations) {\n    node.loc.end = loc;\n  }\n  if (this.options.ranges) {\n    node.range[1] = pos;\n  }\n  return node;\n}\npp$6.finishNode = function (node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc);\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function (node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc);\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) {\n    return p.tryReadTemplateToken();\n  }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\nvar pp$7 = Parser.prototype;\npp$7.initialContext = function () {\n  return [types$1.b_stat];\n};\npp$7.braceIsBlock = function (prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat) {\n    return true;\n  }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr)) {\n    return !parent.isExpr;\n  }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed) {\n    return lineBreak.test(this.input.slice(this.lastTokEnd, this.start));\n  }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow) {\n    return true;\n  }\n  if (prevType === types.braceL) {\n    return parent === types$1.b_stat;\n  }\n  if (prevType === types._var || prevType === types.name) {\n    return false;\n  }\n  return !this.exprAllowed;\n};\npp$7.inGeneratorContext = function () {\n  var this$1 = this;\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\") {\n      return context.generator;\n    }\n  }\n  return false;\n};\npp$7.updateContext = function (prevType) {\n  var update,\n    type = this.type;\n  if (type.keyword && prevType === types.dot) {\n    this.exprAllowed = false;\n  } else if (update = type.updateContext) {\n    update.call(this, prevType);\n  } else {\n    this.exprAllowed = type.beforeExpr;\n  }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function () {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return;\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\ntypes.braceL.updateContext = function (prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\ntypes.dollarBraceL.updateContext = function () {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\ntypes.parenL.updateContext = function (prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\ntypes.incDec.updateContext = function () {\n  // tokExprAllowed stays unchanged\n};\ntypes._function.updateContext = types._class.updateContext = function (prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else && !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat)) {\n    this.context.push(types$1.f_expr);\n  } else {\n    this.context.push(types$1.f_stat);\n  }\n  this.exprAllowed = false;\n};\ntypes.backQuote.updateContext = function () {\n  if (this.curContext() === types$1.q_tmpl) {\n    this.context.pop();\n  } else {\n    this.context.push(types$1.q_tmpl);\n  }\n  this.exprAllowed = false;\n};\ntypes.star.updateContext = function (prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr) {\n      this.context[index] = types$1.f_expr_gen;\n    } else {\n      this.context[index] = types$1.f_gen;\n    }\n  }\n  this.exprAllowed = true;\n};\ntypes.name.updateContext = function (prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed || this.value === \"yield\" && this.inGeneratorContext()) {\n      allowed = true;\n    }\n  }\n  this.exprAllowed = allowed;\n};\nvar data = {\n  \"$LONE\": [\"ASCII\", \"ASCII_Hex_Digit\", \"AHex\", \"Alphabetic\", \"Alpha\", \"Any\", \"Assigned\", \"Bidi_Control\", \"Bidi_C\", \"Bidi_Mirrored\", \"Bidi_M\", \"Case_Ignorable\", \"CI\", \"Cased\", \"Changes_When_Casefolded\", \"CWCF\", \"Changes_When_Casemapped\", \"CWCM\", \"Changes_When_Lowercased\", \"CWL\", \"Changes_When_NFKC_Casefolded\", \"CWKCF\", \"Changes_When_Titlecased\", \"CWT\", \"Changes_When_Uppercased\", \"CWU\", \"Dash\", \"Default_Ignorable_Code_Point\", \"DI\", \"Deprecated\", \"Dep\", \"Diacritic\", \"Dia\", \"Emoji\", \"Emoji_Component\", \"Emoji_Modifier\", \"Emoji_Modifier_Base\", \"Emoji_Presentation\", \"Extender\", \"Ext\", \"Grapheme_Base\", \"Gr_Base\", \"Grapheme_Extend\", \"Gr_Ext\", \"Hex_Digit\", \"Hex\", \"IDS_Binary_Operator\", \"IDSB\", \"IDS_Trinary_Operator\", \"IDST\", \"ID_Continue\", \"IDC\", \"ID_Start\", \"IDS\", \"Ideographic\", \"Ideo\", \"Join_Control\", \"Join_C\", \"Logical_Order_Exception\", \"LOE\", \"Lowercase\", \"Lower\", \"Math\", \"Noncharacter_Code_Point\", \"NChar\", \"Pattern_Syntax\", \"Pat_Syn\", \"Pattern_White_Space\", \"Pat_WS\", \"Quotation_Mark\", \"QMark\", \"Radical\", \"Regional_Indicator\", \"RI\", \"Sentence_Terminal\", \"STerm\", \"Soft_Dotted\", \"SD\", \"Terminal_Punctuation\", \"Term\", \"Unified_Ideograph\", \"UIdeo\", \"Uppercase\", \"Upper\", \"Variation_Selector\", \"VS\", \"White_Space\", \"space\", \"XID_Continue\", \"XIDC\", \"XID_Start\", \"XIDS\"],\n  \"General_Category\": [\"Cased_Letter\", \"LC\", \"Close_Punctuation\", \"Pe\", \"Connector_Punctuation\", \"Pc\", \"Control\", \"Cc\", \"cntrl\", \"Currency_Symbol\", \"Sc\", \"Dash_Punctuation\", \"Pd\", \"Decimal_Number\", \"Nd\", \"digit\", \"Enclosing_Mark\", \"Me\", \"Final_Punctuation\", \"Pf\", \"Format\", \"Cf\", \"Initial_Punctuation\", \"Pi\", \"Letter\", \"L\", \"Letter_Number\", \"Nl\", \"Line_Separator\", \"Zl\", \"Lowercase_Letter\", \"Ll\", \"Mark\", \"M\", \"Combining_Mark\", \"Math_Symbol\", \"Sm\", \"Modifier_Letter\", \"Lm\", \"Modifier_Symbol\", \"Sk\", \"Nonspacing_Mark\", \"Mn\", \"Number\", \"N\", \"Open_Punctuation\", \"Ps\", \"Other\", \"C\", \"Other_Letter\", \"Lo\", \"Other_Number\", \"No\", \"Other_Punctuation\", \"Po\", \"Other_Symbol\", \"So\", \"Paragraph_Separator\", \"Zp\", \"Private_Use\", \"Co\", \"Punctuation\", \"P\", \"punct\", \"Separator\", \"Z\", \"Space_Separator\", \"Zs\", \"Spacing_Mark\", \"Mc\", \"Surrogate\", \"Cs\", \"Symbol\", \"S\", \"Titlecase_Letter\", \"Lt\", \"Unassigned\", \"Cn\", \"Uppercase_Letter\", \"Lu\"],\n  \"Script\": [\"Adlam\", \"Adlm\", \"Ahom\", \"Anatolian_Hieroglyphs\", \"Hluw\", \"Arabic\", \"Arab\", \"Armenian\", \"Armn\", \"Avestan\", \"Avst\", \"Balinese\", \"Bali\", \"Bamum\", \"Bamu\", \"Bassa_Vah\", \"Bass\", \"Batak\", \"Batk\", \"Bengali\", \"Beng\", \"Bhaiksuki\", \"Bhks\", \"Bopomofo\", \"Bopo\", \"Brahmi\", \"Brah\", \"Braille\", \"Brai\", \"Buginese\", \"Bugi\", \"Buhid\", \"Buhd\", \"Canadian_Aboriginal\", \"Cans\", \"Carian\", \"Cari\", \"Caucasian_Albanian\", \"Aghb\", \"Chakma\", \"Cakm\", \"Cham\", \"Cherokee\", \"Cher\", \"Common\", \"Zyyy\", \"Coptic\", \"Copt\", \"Qaac\", \"Cuneiform\", \"Xsux\", \"Cypriot\", \"Cprt\", \"Cyrillic\", \"Cyrl\", \"Deseret\", \"Dsrt\", \"Devanagari\", \"Deva\", \"Duployan\", \"Dupl\", \"Egyptian_Hieroglyphs\", \"Egyp\", \"Elbasan\", \"Elba\", \"Ethiopic\", \"Ethi\", \"Georgian\", \"Geor\", \"Glagolitic\", \"Glag\", \"Gothic\", \"Goth\", \"Grantha\", \"Gran\", \"Greek\", \"Grek\", \"Gujarati\", \"Gujr\", \"Gurmukhi\", \"Guru\", \"Han\", \"Hani\", \"Hangul\", \"Hang\", \"Hanunoo\", \"Hano\", \"Hatran\", \"Hatr\", \"Hebrew\", \"Hebr\", \"Hiragana\", \"Hira\", \"Imperial_Aramaic\", \"Armi\", \"Inherited\", \"Zinh\", \"Qaai\", \"Inscriptional_Pahlavi\", \"Phli\", \"Inscriptional_Parthian\", \"Prti\", \"Javanese\", \"Java\", \"Kaithi\", \"Kthi\", \"Kannada\", \"Knda\", \"Katakana\", \"Kana\", \"Kayah_Li\", \"Kali\", \"Kharoshthi\", \"Khar\", \"Khmer\", \"Khmr\", \"Khojki\", \"Khoj\", \"Khudawadi\", \"Sind\", \"Lao\", \"Laoo\", \"Latin\", \"Latn\", \"Lepcha\", \"Lepc\", \"Limbu\", \"Limb\", \"Linear_A\", \"Lina\", \"Linear_B\", \"Linb\", \"Lisu\", \"Lycian\", \"Lyci\", \"Lydian\", \"Lydi\", \"Mahajani\", \"Mahj\", \"Malayalam\", \"Mlym\", \"Mandaic\", \"Mand\", \"Manichaean\", \"Mani\", \"Marchen\", \"Marc\", \"Masaram_Gondi\", \"Gonm\", \"Meetei_Mayek\", \"Mtei\", \"Mende_Kikakui\", \"Mend\", \"Meroitic_Cursive\", \"Merc\", \"Meroitic_Hieroglyphs\", \"Mero\", \"Miao\", \"Plrd\", \"Modi\", \"Mongolian\", \"Mong\", \"Mro\", \"Mroo\", \"Multani\", \"Mult\", \"Myanmar\", \"Mymr\", \"Nabataean\", \"Nbat\", \"New_Tai_Lue\", \"Talu\", \"Newa\", \"Nko\", \"Nkoo\", \"Nushu\", \"Nshu\", \"Ogham\", \"Ogam\", \"Ol_Chiki\", \"Olck\", \"Old_Hungarian\", \"Hung\", \"Old_Italic\", \"Ital\", \"Old_North_Arabian\", \"Narb\", \"Old_Permic\", \"Perm\", \"Old_Persian\", \"Xpeo\", \"Old_South_Arabian\", \"Sarb\", \"Old_Turkic\", \"Orkh\", \"Oriya\", \"Orya\", \"Osage\", \"Osge\", \"Osmanya\", \"Osma\", \"Pahawh_Hmong\", \"Hmng\", \"Palmyrene\", \"Palm\", \"Pau_Cin_Hau\", \"Pauc\", \"Phags_Pa\", \"Phag\", \"Phoenician\", \"Phnx\", \"Psalter_Pahlavi\", \"Phlp\", \"Rejang\", \"Rjng\", \"Runic\", \"Runr\", \"Samaritan\", \"Samr\", \"Saurashtra\", \"Saur\", \"Sharada\", \"Shrd\", \"Shavian\", \"Shaw\", \"Siddham\", \"Sidd\", \"SignWriting\", \"Sgnw\", \"Sinhala\", \"Sinh\", \"Sora_Sompeng\", \"Sora\", \"Soyombo\", \"Soyo\", \"Sundanese\", \"Sund\", \"Syloti_Nagri\", \"Sylo\", \"Syriac\", \"Syrc\", \"Tagalog\", \"Tglg\", \"Tagbanwa\", \"Tagb\", \"Tai_Le\", \"Tale\", \"Tai_Tham\", \"Lana\", \"Tai_Viet\", \"Tavt\", \"Takri\", \"Takr\", \"Tamil\", \"Taml\", \"Tangut\", \"Tang\", \"Telugu\", \"Telu\", \"Thaana\", \"Thaa\", \"Thai\", \"Tibetan\", \"Tibt\", \"Tifinagh\", \"Tfng\", \"Tirhuta\", \"Tirh\", \"Ugaritic\", \"Ugar\", \"Vai\", \"Vaii\", \"Warang_Citi\", \"Wara\", \"Yi\", \"Yiii\", \"Zanabazar_Square\", \"Zanb\"]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\nvar pp$9 = Parser.prototype;\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\nRegExpValidationState.prototype.reset = function reset(start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\nRegExpValidationState.prototype.raise = function raise(message) {\n  this.parser.raiseRecoverable(this.start, \"Invalid regular expression: /\" + this.source + \"/: \" + message);\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at(i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1;\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c;\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c;\n};\nRegExpValidationState.prototype.nextIndex = function nextIndex(i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l;\n  }\n  var c = s.charCodeAt(i),\n    next;\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l || (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1;\n  }\n  return i + 2;\n};\nRegExpValidationState.prototype.current = function current() {\n  return this.at(this.pos);\n};\nRegExpValidationState.prototype.lookahead = function lookahead() {\n  return this.at(this.nextIndex(this.pos));\n};\nRegExpValidationState.prototype.advance = function advance() {\n  this.pos = this.nextIndex(this.pos);\n};\nRegExpValidationState.prototype.eat = function eat(ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true;\n  }\n  return false;\n};\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) {\n    return String.fromCharCode(ch);\n  }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00);\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpFlags = function (state) {\n  var this$1 = this;\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpPattern = function (state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$9.regexp_pattern = function (state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n  this.regexp_disjunction(state);\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$9.regexp_disjunction = function (state) {\n  var this$1 = this;\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this$1.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$9.regexp_alternative = function (state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state)) {}\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$9.regexp_eatTerm = function (state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true;\n  }\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$9.regexp_eatAssertion = function (state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true;\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true;\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true;\n    }\n  }\n  state.pos = start;\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$9.regexp_eatQuantifier = function (state, noError) {\n  if (noError === void 0) noError = false;\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$9.regexp_eatQuantifierPrefix = function (state, noError) {\n  return state.eat(0x2A /* * */) || state.eat(0x2B /* + */) || state.eat(0x3F /* ? */) || this.regexp_eatBracedQuantifier(state, noError);\n};\npp$9.regexp_eatBracedQuantifier = function (state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0,\n      max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true;\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$9.regexp_eatAtom = function (state) {\n  return this.regexp_eatPatternCharacters(state) || state.eat(0x2E /* . */) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state);\n};\npp$9.regexp_eatReverseSolidusAtomEscape = function (state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true;\n    }\n    state.pos = start;\n  }\n  return false;\n};\npp$9.regexp_eatUncapturingGroup = function (state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true;\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false;\n};\npp$9.regexp_eatCapturingGroup = function (state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true;\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$9.regexp_eatExtendedAtom = function (state) {\n  return state.eat(0x2E /* . */) || this.regexp_eatReverseSolidusAtomEscape(state) || this.regexp_eatCharacterClass(state) || this.regexp_eatUncapturingGroup(state) || this.regexp_eatCapturingGroup(state) || this.regexp_eatInvalidBracedQuantifier(state) || this.regexp_eatExtendedPatternCharacter(state);\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$9.regexp_eatInvalidBracedQuantifier = function (state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$9.regexp_eatSyntaxCharacter = function (state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n  return false;\n};\nfunction isSyntaxCharacter(ch) {\n  return ch === 0x24 /* $ */ || ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ || ch === 0x2E /* . */ || ch === 0x3F /* ? */ || ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ || ch >= 0x7B /* { */ && ch <= 0x7D /* } */;\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$9.regexp_eatPatternCharacters = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$9.regexp_eatExtendedPatternCharacter = function (state) {\n  var ch = state.current();\n  if (ch !== -1 && ch !== 0x24 /* $ */ && !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) && ch !== 0x2E /* . */ && ch !== 0x3F /* ? */ && ch !== 0x5B /* [ */ && ch !== 0x5E /* ^ */ && ch !== 0x7C /* | */) {\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$9.regexp_groupSpecifier = function (state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return;\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatGroupName = function (state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true;\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false;\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatRegExpIdentifierName = function (state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n    return true;\n  }\n  return false;\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$9.regexp_eatRegExpIdentifierStart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n  state.pos = start;\n  return false;\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F; /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$9.regexp_eatRegExpIdentifierPart = function (state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true;\n  }\n  state.pos = start;\n  return false;\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D; /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$9.regexp_eatAtomEscape = function (state) {\n  if (this.regexp_eatBackReference(state) || this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state) || state.switchN && this.regexp_eatKGroupName(state)) {\n    return true;\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false;\n};\npp$9.regexp_eatBackReference = function (state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true;\n    }\n    if (n <= state.numCapturingParens) {\n      return true;\n    }\n    state.pos = start;\n  }\n  return false;\n};\npp$9.regexp_eatKGroupName = function (state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true;\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$9.regexp_eatCharacterEscape = function (state) {\n  return this.regexp_eatControlEscape(state) || this.regexp_eatCControlLetter(state) || this.regexp_eatZero(state) || this.regexp_eatHexEscapeSequence(state) || this.regexp_eatRegExpUnicodeEscapeSequence(state) || !state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state) || this.regexp_eatIdentityEscape(state);\n};\npp$9.regexp_eatCControlLetter = function (state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true;\n    }\n    state.pos = start;\n  }\n  return false;\n};\npp$9.regexp_eatZero = function (state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$9.regexp_eatControlEscape = function (state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true;\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true;\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true;\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true;\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$9.regexp_eatControlLetter = function (state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true;\n  }\n  return false;\n};\nfunction isControlLetter(ch) {\n  return ch >= 0x41 /* A */ && ch <= 0x5A /* Z */ || ch >= 0x61 /* a */ && ch <= 0x7A /* z */;\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function (state) {\n  var start = state.pos;\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true;\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true;\n    }\n    if (state.switchU && state.eat(0x7B /* { */) && this.regexp_eatHexDigits(state) && state.eat(0x7D /* } */) && isValidUnicode(state.lastIntValue)) {\n      return true;\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n  return false;\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF;\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$9.regexp_eatIdentityEscape = function (state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true;\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true;\n    }\n    return false;\n  }\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$9.regexp_eatDecimalEscape = function (state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */);\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$9.regexp_eatCharacterClassEscape = function (state) {\n  var ch = state.current();\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true;\n  }\n  if (state.switchU && this.options.ecmaVersion >= 9 && (ch === 0x50 /* P */ || ch === 0x70 /* p */)) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (state.eat(0x7B /* { */) && this.regexp_eatUnicodePropertyValueExpression(state) && state.eat(0x7D /* } */)) {\n      return true;\n    }\n    state.raise(\"Invalid property name\");\n  }\n  return false;\n};\nfunction isCharacterClassEscape(ch) {\n  return ch === 0x64 /* d */ || ch === 0x44 /* D */ || ch === 0x73 /* s */ || ch === 0x53 /* S */ || ch === 0x77 /* w */ || ch === 0x57 /* W */;\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$9.regexp_eatUnicodePropertyValueExpression = function (state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true;\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true;\n  }\n  return false;\n};\npp$9.regexp_validateUnicodePropertyNameAndValue = function (state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\npp$9.regexp_validateUnicodePropertyNameOrValue = function (state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$9.regexp_eatUnicodePropertyName = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F; /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatUnicodePropertyValue = function (state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\";\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch);\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function (state) {\n  return this.regexp_eatUnicodePropertyValue(state);\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$9.regexp_eatCharacterClass = function (state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true;\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$9.regexp_classRanges = function (state) {\n  var this$1 = this;\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$9.regexp_eatClassAtom = function (state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true;\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$9.regexp_eatClassEscape = function (state) {\n  var start = state.pos;\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true;\n  }\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true;\n  }\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true;\n    }\n    state.pos = start;\n  }\n  return this.regexp_eatCharacterClassEscape(state) || this.regexp_eatCharacterEscape(state);\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$9.regexp_eatClassControlLetter = function (state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatHexEscapeSequence = function (state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true;\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$9.regexp_eatDecimalDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start;\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39; /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$9.regexp_eatHexDigits = function (state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start;\n};\nfunction isHexDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */ || ch >= 0x41 /* A */ && ch <= 0x46 /* F */ || ch >= 0x61 /* a */ && ch <= 0x66 /* f */;\n}\n\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */);\n  }\n\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */);\n  }\n\n  return ch - 0x30; /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$9.regexp_eatLegacyOctalEscapeSequence = function (state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true;\n  }\n  return false;\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$9.regexp_eatOctalDigit = function (state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true;\n  }\n  state.lastIntValue = 0;\n  return false;\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37; /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatFixedHexDigits = function (state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false;\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true;\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations) {\n    this.loc = new SourceLocation(p, p.startLoc, p.endLoc);\n  }\n  if (p.options.ranges) {\n    this.range = [p.start, p.end];\n  }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Move to the next token\n\npp$8.next = function () {\n  if (this.options.onToken) {\n    this.options.onToken(new Token(this));\n  }\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\npp$8.getToken = function () {\n  this.next();\n  return new Token(this);\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\") {\n  pp$8[Symbol.iterator] = function () {\n    var this$1 = this;\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        };\n      }\n    };\n  };\n}\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function () {\n  return this.context[this.context.length - 1];\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function () {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) {\n    this.skipSpace();\n  }\n  this.start = this.pos;\n  if (this.options.locations) {\n    this.startLoc = this.curPosition();\n  }\n  if (this.pos >= this.input.length) {\n    return this.finishToken(types.eof);\n  }\n  if (curContext.override) {\n    return curContext.override(this);\n  } else {\n    this.readToken(this.fullCharCodeAtPos());\n  }\n};\npp$8.readToken = function (code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */) {\n    return this.readWord();\n  }\n  return this.getTokenFromCode(code);\n};\npp$8.fullCharCodeAtPos = function () {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) {\n    return code;\n  }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00;\n};\npp$8.skipBlockComment = function () {\n  var this$1 = this;\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos,\n    end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) {\n    this.raise(this.pos - 2, \"Unterminated comment\");\n  }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment) {\n    this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos, startLoc, this.curPosition());\n  }\n};\npp$8.skipLineComment = function (startSkip) {\n  var this$1 = this;\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment) {\n    this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos, startLoc, this.curPosition());\n  }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function () {\n  var this$1 = this;\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n      case 32:\n      case 160:\n        // ' '\n        ++this$1.pos;\n        break;\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n          ++this$1.pos;\n        }\n      case 10:\n      case 8232:\n      case 8233:\n        ++this$1.pos;\n        if (this$1.options.locations) {\n          ++this$1.curLine;\n          this$1.lineStart = this$1.pos;\n        }\n        break;\n      case 47:\n        // '/'\n        switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n          case 42:\n            // '*'\n            this$1.skipBlockComment();\n            break;\n          case 47:\n            this$1.skipLineComment(2);\n            break;\n          default:\n            break loop;\n        }\n        break;\n      default:\n        if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n          ++this$1.pos;\n        } else {\n          break loop;\n        }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function (type, val) {\n  this.end = this.pos;\n  if (this.options.locations) {\n    this.endLoc = this.curPosition();\n  }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function () {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) {\n    return this.readNumber(true);\n  }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) {\n    // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis);\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot);\n  }\n};\npp$8.readToken_slash = function () {\n  // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) {\n    ++this.pos;\n    return this.readRegexp();\n  }\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n  return this.finishOp(types.slash, 1);\n};\npp$8.readToken_mult_modulo_exp = function (code) {\n  // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n  if (next === 61) {\n    return this.finishOp(types.assign, size + 1);\n  }\n  return this.finishOp(tokentype, size);\n};\npp$8.readToken_pipe_amp = function (code) {\n  // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2);\n  }\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1);\n};\npp$8.readToken_caret = function () {\n  // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n  return this.finishOp(types.bitwiseXOR, 1);\n};\npp$8.readToken_plus_min = function (code) {\n  // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken();\n    }\n    return this.finishOp(types.incDec, 2);\n  }\n  if (next === 61) {\n    return this.finishOp(types.assign, 2);\n  }\n  return this.finishOp(types.plusMin, 1);\n};\npp$8.readToken_lt_gt = function (code) {\n  // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) {\n      return this.finishOp(types.assign, size + 1);\n    }\n    return this.finishOp(types.bitShift, size);\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken();\n  }\n  if (next === 61) {\n    size = 2;\n  }\n  return this.finishOp(types.relational, size);\n};\npp$8.readToken_eq_excl = function (code) {\n  // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) {\n    return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2);\n  }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) {\n    // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow);\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1);\n};\npp$8.getTokenFromCode = function (code) {\n  switch (code) {\n    // The interpretation of a dot depends on whether it is followed\n    // by a digit or another two dots.\n    case 46:\n      // '.'\n      return this.readToken_dot();\n\n    // Punctuation tokens.\n    case 40:\n      ++this.pos;\n      return this.finishToken(types.parenL);\n    case 41:\n      ++this.pos;\n      return this.finishToken(types.parenR);\n    case 59:\n      ++this.pos;\n      return this.finishToken(types.semi);\n    case 44:\n      ++this.pos;\n      return this.finishToken(types.comma);\n    case 91:\n      ++this.pos;\n      return this.finishToken(types.bracketL);\n    case 93:\n      ++this.pos;\n      return this.finishToken(types.bracketR);\n    case 123:\n      ++this.pos;\n      return this.finishToken(types.braceL);\n    case 125:\n      ++this.pos;\n      return this.finishToken(types.braceR);\n    case 58:\n      ++this.pos;\n      return this.finishToken(types.colon);\n    case 63:\n      ++this.pos;\n      return this.finishToken(types.question);\n    case 96:\n      // '`'\n      if (this.options.ecmaVersion < 6) {\n        break;\n      }\n      ++this.pos;\n      return this.finishToken(types.backQuote);\n    case 48:\n      // '0'\n      var next = this.input.charCodeAt(this.pos + 1);\n      if (next === 120 || next === 88) {\n        return this.readRadixNumber(16);\n      } // '0x', '0X' - hex number\n      if (this.options.ecmaVersion >= 6) {\n        if (next === 111 || next === 79) {\n          return this.readRadixNumber(8);\n        } // '0o', '0O' - octal number\n        if (next === 98 || next === 66) {\n          return this.readRadixNumber(2);\n        } // '0b', '0B' - binary number\n      }\n\n    // Anything else beginning with a digit is an integer, octal\n    // number, or float.\n    case 49:\n    case 50:\n    case 51:\n    case 52:\n    case 53:\n    case 54:\n    case 55:\n    case 56:\n    case 57:\n      // 1-9\n      return this.readNumber(false);\n\n    // Quotes produce strings.\n    case 34:\n    case 39:\n      // '\"', \"'\"\n      return this.readString(code);\n\n    // Operators are parsed inline in tiny state machines. '=' (61) is\n    // often referred to. `finishOp` simply skips the amount of\n    // characters it is given as second argument, and returns a token\n    // of the type given by its first argument.\n\n    case 47:\n      // '/'\n      return this.readToken_slash();\n    case 37:\n    case 42:\n      // '%*'\n      return this.readToken_mult_modulo_exp(code);\n    case 124:\n    case 38:\n      // '|&'\n      return this.readToken_pipe_amp(code);\n    case 94:\n      // '^'\n      return this.readToken_caret();\n    case 43:\n    case 45:\n      // '+-'\n      return this.readToken_plus_min(code);\n    case 60:\n    case 62:\n      // '<>'\n      return this.readToken_lt_gt(code);\n    case 61:\n    case 33:\n      // '=!'\n      return this.readToken_eq_excl(code);\n    case 126:\n      // '~'\n      return this.finishOp(types.prefix, 1);\n  }\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\npp$8.finishOp = function (type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str);\n};\npp$8.readRegexp = function () {\n  var this$1 = this;\n  var escaped,\n    inClass,\n    start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(start, \"Unterminated regular expression\");\n    }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) {\n      this$1.raise(start, \"Unterminated regular expression\");\n    }\n    if (!escaped) {\n      if (ch === \"[\") {\n        inClass = true;\n      } else if (ch === \"]\" && inClass) {\n        inClass = false;\n      } else if (ch === \"/\" && !inClass) {\n        break;\n      }\n      escaped = ch === \"\\\\\";\n    } else {\n      escaped = false;\n    }\n    ++this$1.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) {\n    this.unexpected(flagsStart);\n  }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n  return this.finishToken(types.regexp, {\n    pattern: pattern,\n    flags: flags,\n    value: value\n  });\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function (radix, len) {\n  var this$1 = this;\n  var start = this.pos,\n    total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos),\n      val = void 0;\n    if (code >= 97) {\n      val = code - 97 + 10;\n    } // a\n    else if (code >= 65) {\n      val = code - 65 + 10;\n    } // A\n    else if (code >= 48 && code <= 57) {\n      val = code - 48;\n    } // 0-9\n    else {\n      val = Infinity;\n    }\n    if (val >= radix) {\n      break;\n    }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) {\n    return null;\n  }\n  return total;\n};\npp$8.readRadixNumber = function (radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) {\n    this.raise(this.start + 2, \"Expected number in radix \" + radix);\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n  return this.finishToken(types.num, val);\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function (startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) {\n    this.raise(start, \"Invalid number\");\n  }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) {\n    this.raise(start, \"Invalid number\");\n  }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) {\n    octal = false;\n  }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) {\n    // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) {\n    // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) {\n      ++this.pos;\n    } // '+-'\n    if (this.readInt(10) === null) {\n      this.raise(start, \"Invalid number\");\n    }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) {\n    this.raise(this.pos, \"Identifier directly after number\");\n  }\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val);\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function () {\n  var ch = this.input.charCodeAt(this.pos),\n    code;\n  if (ch === 123) {\n    // '{'\n    if (this.options.ecmaVersion < 6) {\n      this.unexpected();\n    }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) {\n      this.invalidStringToken(codePos, \"Code point out of bounds\");\n    }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code;\n};\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) {\n    return String.fromCharCode(code);\n  }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00);\n}\npp$8.readString = function (quote) {\n  var this$1 = this;\n  var out = \"\",\n    chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(this$1.start, \"Unterminated string constant\");\n    }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) {\n      break;\n    }\n    if (ch === 92) {\n      // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) {\n        this$1.raise(this$1.start, \"Unterminated string constant\");\n      }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out);\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\npp$8.tryReadTemplateToken = function () {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err;\n    }\n  }\n  this.inTemplateElement = false;\n};\npp$8.invalidStringToken = function (position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR;\n  } else {\n    this.raise(position, message);\n  }\n};\npp$8.readTmplToken = function () {\n  var this$1 = this;\n  var out = \"\",\n    chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) {\n      this$1.raise(this$1.start, \"Unterminated template\");\n    }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) {\n      // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL);\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote);\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out);\n    }\n    if (ch === 92) {\n      // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n        case 13:\n          if (this$1.input.charCodeAt(this$1.pos) === 10) {\n            ++this$1.pos;\n          }\n        case 10:\n          out += \"\\n\";\n          break;\n        default:\n          out += String.fromCharCode(ch);\n          break;\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function () {\n  var this$1 = this;\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n      case \"\\\\\":\n        ++this$1.pos;\n        break;\n      case \"$\":\n        if (this$1.input[this$1.pos + 1] !== \"{\") {\n          break;\n        }\n      // falls through\n\n      case \"`\":\n        return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos));\n\n      // no default\n    }\n  }\n\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function (inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n    case 110:\n      return \"\\n\";\n    // 'n' -> '\\n'\n    case 114:\n      return \"\\r\";\n    // 'r' -> '\\r'\n    case 120:\n      return String.fromCharCode(this.readHexChar(2));\n    // 'x'\n    case 117:\n      return codePointToString(this.readCodePoint());\n    // 'u'\n    case 116:\n      return \"\\t\";\n    // 't' -> '\\t'\n    case 98:\n      return \"\\b\";\n    // 'b' -> '\\b'\n    case 118:\n      return \"\\u000b\";\n    // 'v' -> '\\u000b'\n    case 102:\n      return \"\\f\";\n    // 'f' -> '\\f'\n    case 13:\n      if (this.input.charCodeAt(this.pos) === 10) {\n        ++this.pos;\n      }\n    // '\\r\\n'\n    case 10:\n      // ' \\n'\n      if (this.options.locations) {\n        this.lineStart = this.pos;\n        ++this.curLine;\n      }\n      return \"\";\n    default:\n      if (ch >= 48 && ch <= 55) {\n        var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n        var octal = parseInt(octalStr, 8);\n        if (octal > 255) {\n          octalStr = octalStr.slice(0, -1);\n          octal = parseInt(octalStr, 8);\n        }\n        this.pos += octalStr.length - 1;\n        ch = this.input.charCodeAt(this.pos);\n        if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n          this.invalidStringToken(this.pos - 1 - octalStr.length, inTemplate ? \"Octal literal in template string\" : \"Octal literal in strict mode\");\n        }\n        return String.fromCharCode(octal);\n      }\n      return String.fromCharCode(ch);\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function (len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) {\n    this.invalidStringToken(codePos, \"Bad character escape sequence\");\n  }\n  return n;\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function () {\n  var this$1 = this;\n  this.containsEsc = false;\n  var word = \"\",\n    first = true,\n    chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) {\n      // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) !== 117)\n        // \"u\"\n        {\n          this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\");\n        }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral)) {\n        this$1.invalidStringToken(escStart, \"Invalid Unicode escape\");\n      }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break;\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos);\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function () {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) {\n      this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word);\n    }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word);\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.7.3\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse();\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression();\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input);\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };","map":{"version":3,"names":["reservedWords","strict","strictBind","ecma5AndLessKeywords","keywords","keywordRelationalOperator","nonASCIIidentifierStartChars","nonASCIIidentifierChars","nonASCIIidentifierStart","RegExp","nonASCIIidentifier","astralIdentifierStartCodes","astralIdentifierCodes","isInAstralSet","code","set","pos","i","length","isIdentifierStart","astral","test","String","fromCharCode","isIdentifierChar","TokenType","label","conf","keyword","beforeExpr","startsExpr","isLoop","isAssign","prefix","postfix","binop","updateContext","name","prec","keywords$1","kw","options","types","num","regexp","string","eof","bracketL","bracketR","braceL","braceR","parenL","parenR","comma","semi","colon","dot","question","arrow","template","invalidTemplate","ellipsis","backQuote","dollarBraceL","eq","assign","incDec","logicalOR","logicalAND","bitwiseOR","bitwiseXOR","bitwiseAND","equality","relational","bitShift","plusMin","modulo","star","slash","starstar","_break","_case","_catch","_continue","_debugger","_default","_do","_else","_finally","_for","_function","_if","_return","_switch","_throw","_try","_var","_const","_while","_with","_new","_this","_super","_class","_extends","_export","_import","_null","_true","_false","_in","_instanceof","_typeof","_void","_delete","lineBreak","lineBreakG","source","isNewLine","ecma2019String","nonASCIIwhitespace","skipWhiteSpace","ref","Object","prototype","hasOwnProperty","toString","has","obj","propName","call","isArray","Array","Position","line","col","column","offset","n","SourceLocation","p","start","end","sourceFile","getLineInfo","input","cur","lastIndex","match","exec","index","defaultOptions","ecmaVersion","sourceType","onInsertedSemicolon","onTrailingComma","allowReserved","allowReturnOutsideFunction","allowImportExportEverywhere","allowAwaitOutsideFunction","allowHashBang","locations","onToken","onComment","ranges","program","directSourceFile","preserveParens","plugins","getOptions","opts","opt","tokens","token","push","pushComment","array","block","text","startLoc","endLoc","comment","type","value","loc","range","keywordRegexp","words","replace","Parser","startPos","reserved","v","reservedStrict","reservedWordsStrict","reservedWordsStrictBind","containsEsc","loadPlugins","lineStart","lastIndexOf","curLine","slice","split","curPosition","lastTokEndLoc","lastTokStartLoc","lastTokStart","lastTokEnd","context","initialContext","exprAllowed","inModule","strictDirective","potentialArrowAt","inFunction","inGenerator","inAsync","yieldPos","awaitPos","labels","skipLineComment","scopeStack","enterFunctionScope","regexpState","isKeyword","word","isReservedWord","extend","f","pluginConfigs","this$1","plugin","Error","parse","node","startNode","nextToken","parseTopLevel","pp","literal","eat","next","isContextual","eatContextual","expectContextual","unexpected","canInsertSemicolon","insertSemicolon","semicolon","afterTrailingComma","tokType","notNext","expect","raise","DestructuringErrors","shorthandAssign","trailingComma","parenthesizedAssign","parenthesizedBind","doubleProto","checkPatternErrors","refDestructuringErrors","raiseRecoverable","parens","checkExpressionErrors","andThrow","checkYieldAwaitInDefaultParams","isSimpleAssignTarget","expr","expression","pp$1","exports","body","stmt","parseStatement","adaptDirectivePrologue","finishNode","loopLabel","kind","switchLabel","isLet","skip","nextCh","charCodeAt","ident","isAsyncFunction","charAt","declaration","topLevel","starttype","parseBreakContinueStatement","parseDebuggerStatement","parseDoStatement","parseForStatement","parseFunctionStatement","parseClass","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","parseImport","parseExport","maybeName","parseExpression","parseLabeledStatement","parseExpressionStatement","isBreak","parseIdent","lab","pop","parseParenExpression","awaitAt","enterLexicalScope","parseFor","init$1","parseVar","declarations","init","await","parseForIn","toAssignable","checkLVal","isAsync","parseFunction","consequent","alternate","argument","discriminant","cases","sawDefault","isCase","exitLexicalScope","empty","handler","clause","param","parseBindingAtom","finalizer","object","i$1","list","label$1","statementStart","generator","async","createNewLexicalScope","update","id","left","right","parseMaybeAssign","isFor","decl","parseVarId","isStatement","allowExpressionBody","initFunction","oldInGen","oldInAsync","oldYieldPos","oldAwaitPos","oldInFunc","parseFunctionParams","parseFunctionBody","params","parseBindingList","parseClassId","parseClassSuper","classBody","hadConstructor","member","parseClassMember","method","tryContextual","k","noLineBreak","key","computed","startNodeAt","static","isGenerator","parsePropertyName","parseClassMethod","parseMethod","superClass","parseExprSubscripts","parseExprAtom","checkExport","fNode","cNode","shouldParseExportStatement","checkVariableExport","specifiers","parseExportSpecifiers","spec","checkUnreserved","local","checkPatternExport","pat","properties","prop","list$1","elements","elt","decls","nodes","first","exported","parseImportSpecifiers","node$1","node$2","imported","statements","isDirectiveCandidate","directive","raw","statement","pp$2","isBinding","toAssignableList","operator","exprList","last","parseSpread","parseRestBinding","parseObj","close","allowEmpty","allowTrailingComma","elts","rest","parseBindingListItem","elem","parseMaybeDefault","bindingType","checkClashes","canDeclareVarName","canDeclareLexicalName","declareVarName","declareLexicalName","pp$3","checkPropClash","propHash","shorthand","proto","other","redefinition","get","noIn","expressions","afterLeftParse","parseYield","ownDestructuringErrors","oldParenAssign","oldTrailingComma","parseMaybeConditional","parseExprOps","parseMaybeUnary","parseExprOp","leftStartPos","leftStartLoc","minPrec","logical","op","buildBinary","sawUnary","parseAwait","skipArrowSubscripts","result","parseSubscripts","base","noCalls","maybeAsyncArrow","property","parseExprList","parseArrowExpression","callee","arguments","tag","quasi","parseTemplate","isTagged","canBeArrow","parseLiteral","regex","pattern","flags","parseParenAndDistinguishExpression","parseNew","val","innerStartPos","innerStartLoc","lastIsComma","spreadStart","parseParenItem","innerEndPos","innerEndLoc","parseParenArrowList","finishNodeAt","par","item","empty$1","meta","parseTemplateElement","cooked","tail","curElt","quasis","isAsyncProp","isPattern","parseProperty","parsePropertyValue","paramCount","isArrowFunction","isExpression","oldStrict","useStrict","checkParams","nonSimple","isSimpleParamList","oldLabels","exitFunctionScope","allowDuplicates","nameHash","indexOf","re","liberal","delegate","pp$4","message","err","SyntaxError","raisedAt","pp$5","target","sources","len","var","lexical","childVar","parentLexical","parentScope","childScope","currentScope","Node","parser","pp$6","TokContext","isExpr","preserveSpace","override","types$1","b_stat","b_expr","b_tmpl","p_stat","p_expr","q_tmpl","tryReadTemplateToken","f_stat","f_expr","f_expr_gen","f_gen","pp$7","braceIsBlock","prevType","parent","curContext","inGeneratorContext","out","statementParens","allowed","data","apply","$LONE","General_Category","gc","sc","Script_Extensions","scx","Script","pp$9","RegExpValidationState","validFlags","switchU","switchN","lastIntValue","lastStringValue","lastAssertionIsQuantifiable","numCapturingParens","maxBackReference","groupNames","backReferenceNames","reset","unicode","at","s","l","c","nextIndex","current","lookahead","advance","ch","codePointToString$1","validateRegExpFlags","state","flag","validateRegExpPattern","regexp_pattern","regexp_disjunction","regexp_alternative","regexp_eatQuantifier","regexp_eatTerm","regexp_eatAssertion","regexp_eatAtom","regexp_eatExtendedAtom","lookbehind","noError","regexp_eatQuantifierPrefix","regexp_eatBracedQuantifier","min","max","regexp_eatDecimalDigits","regexp_eatPatternCharacters","regexp_eatReverseSolidusAtomEscape","regexp_eatCharacterClass","regexp_eatUncapturingGroup","regexp_eatCapturingGroup","regexp_eatAtomEscape","regexp_groupSpecifier","regexp_eatInvalidBracedQuantifier","regexp_eatExtendedPatternCharacter","regexp_eatSyntaxCharacter","isSyntaxCharacter","regexp_eatGroupName","regexp_eatRegExpIdentifierName","regexp_eatRegExpIdentifierStart","regexp_eatRegExpIdentifierPart","regexp_eatRegExpUnicodeEscapeSequence","isRegExpIdentifierStart","isRegExpIdentifierPart","regexp_eatBackReference","regexp_eatCharacterClassEscape","regexp_eatCharacterEscape","regexp_eatKGroupName","regexp_eatDecimalEscape","regexp_eatControlEscape","regexp_eatCControlLetter","regexp_eatZero","regexp_eatHexEscapeSequence","regexp_eatLegacyOctalEscapeSequence","regexp_eatIdentityEscape","regexp_eatControlLetter","isDecimalDigit","isControlLetter","regexp_eatFixedHexDigits","lead","leadSurrogateEnd","trail","regexp_eatHexDigits","isValidUnicode","isCharacterClassEscape","regexp_eatUnicodePropertyValueExpression","regexp_eatUnicodePropertyName","regexp_eatUnicodePropertyValue","regexp_validateUnicodePropertyNameAndValue","regexp_eatLoneUnicodePropertyNameOrValue","nameOrValue","regexp_validateUnicodePropertyNameOrValue","isUnicodePropertyNameCharacter","isUnicodePropertyValueCharacter","regexp_classRanges","regexp_eatClassAtom","regexp_eatClassEscape","ch$1","isOctalDigit","regexp_eatClassControlLetter","isHexDigit","hexToInt","regexp_eatOctalDigit","n1","n2","Token","pp$8","getToken","Symbol","iterator","done","skipSpace","finishToken","readToken","fullCharCodeAtPos","readWord","getTokenFromCode","skipBlockComment","startSkip","loop","readToken_dot","readNumber","next2","readToken_slash","readRegexp","finishOp","readToken_mult_modulo_exp","size","tokentype","readToken_pipe_amp","readToken_caret","readToken_plus_min","readToken_lt_gt","readToken_eq_excl","readRadixNumber","readString","codePointToString","str","escaped","inClass","flagsStart","readWord1","e","readInt","radix","total","Infinity","startsWithDot","octal","parseInt","parseFloat","readCodePoint","codePos","readHexChar","invalidStringToken","quote","chunkStart","readEscapedChar","INVALID_TEMPLATE_ESCAPE_ERROR","inTemplateElement","readTmplToken","readInvalidTemplateToken","position","inTemplate","octalStr","substr","escStart","esc","version","parseExpressionAt","tokenizer","parse_dammit","LooseParser","pluginsLoose","addLooseExports","Parser$$1","plugins$$1","tokTypes","keywordTypes","tokContexts"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/acorn/dist/acorn.es.js"],"sourcesContent":["// Reserved word lists for various dialects of the language\n\nvar reservedWords = {\n  3: \"abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile\",\n  5: \"class enum extends super const export import\",\n  6: \"enum\",\n  strict: \"implements interface let package private protected public static yield\",\n  strictBind: \"eval arguments\"\n};\n\n// And the keywords\n\nvar ecma5AndLessKeywords = \"break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this\";\n\nvar keywords = {\n  5: ecma5AndLessKeywords,\n  6: ecma5AndLessKeywords + \" const class extends export import super\"\n};\n\nvar keywordRelationalOperator = /^in(stanceof)?$/;\n\n// ## Character categories\n\n// Big ugly regular expressions that match characters in the\n// whitespace, identifier, and identifier-start categories. These\n// are only applied when a character is found to actually have a\n// code point above 128.\n// Generated by `bin/generate-identifier-regex.js`.\n\nvar nonASCIIidentifierStartChars = \"\\xaa\\xb5\\xba\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u02c1\\u02c6-\\u02d1\\u02e0-\\u02e4\\u02ec\\u02ee\\u0370-\\u0374\\u0376\\u0377\\u037a-\\u037d\\u037f\\u0386\\u0388-\\u038a\\u038c\\u038e-\\u03a1\\u03a3-\\u03f5\\u03f7-\\u0481\\u048a-\\u052f\\u0531-\\u0556\\u0559\\u0560-\\u0588\\u05d0-\\u05ea\\u05ef-\\u05f2\\u0620-\\u064a\\u066e\\u066f\\u0671-\\u06d3\\u06d5\\u06e5\\u06e6\\u06ee\\u06ef\\u06fa-\\u06fc\\u06ff\\u0710\\u0712-\\u072f\\u074d-\\u07a5\\u07b1\\u07ca-\\u07ea\\u07f4\\u07f5\\u07fa\\u0800-\\u0815\\u081a\\u0824\\u0828\\u0840-\\u0858\\u0860-\\u086a\\u08a0-\\u08b4\\u08b6-\\u08bd\\u0904-\\u0939\\u093d\\u0950\\u0958-\\u0961\\u0971-\\u0980\\u0985-\\u098c\\u098f\\u0990\\u0993-\\u09a8\\u09aa-\\u09b0\\u09b2\\u09b6-\\u09b9\\u09bd\\u09ce\\u09dc\\u09dd\\u09df-\\u09e1\\u09f0\\u09f1\\u09fc\\u0a05-\\u0a0a\\u0a0f\\u0a10\\u0a13-\\u0a28\\u0a2a-\\u0a30\\u0a32\\u0a33\\u0a35\\u0a36\\u0a38\\u0a39\\u0a59-\\u0a5c\\u0a5e\\u0a72-\\u0a74\\u0a85-\\u0a8d\\u0a8f-\\u0a91\\u0a93-\\u0aa8\\u0aaa-\\u0ab0\\u0ab2\\u0ab3\\u0ab5-\\u0ab9\\u0abd\\u0ad0\\u0ae0\\u0ae1\\u0af9\\u0b05-\\u0b0c\\u0b0f\\u0b10\\u0b13-\\u0b28\\u0b2a-\\u0b30\\u0b32\\u0b33\\u0b35-\\u0b39\\u0b3d\\u0b5c\\u0b5d\\u0b5f-\\u0b61\\u0b71\\u0b83\\u0b85-\\u0b8a\\u0b8e-\\u0b90\\u0b92-\\u0b95\\u0b99\\u0b9a\\u0b9c\\u0b9e\\u0b9f\\u0ba3\\u0ba4\\u0ba8-\\u0baa\\u0bae-\\u0bb9\\u0bd0\\u0c05-\\u0c0c\\u0c0e-\\u0c10\\u0c12-\\u0c28\\u0c2a-\\u0c39\\u0c3d\\u0c58-\\u0c5a\\u0c60\\u0c61\\u0c80\\u0c85-\\u0c8c\\u0c8e-\\u0c90\\u0c92-\\u0ca8\\u0caa-\\u0cb3\\u0cb5-\\u0cb9\\u0cbd\\u0cde\\u0ce0\\u0ce1\\u0cf1\\u0cf2\\u0d05-\\u0d0c\\u0d0e-\\u0d10\\u0d12-\\u0d3a\\u0d3d\\u0d4e\\u0d54-\\u0d56\\u0d5f-\\u0d61\\u0d7a-\\u0d7f\\u0d85-\\u0d96\\u0d9a-\\u0db1\\u0db3-\\u0dbb\\u0dbd\\u0dc0-\\u0dc6\\u0e01-\\u0e30\\u0e32\\u0e33\\u0e40-\\u0e46\\u0e81\\u0e82\\u0e84\\u0e87\\u0e88\\u0e8a\\u0e8d\\u0e94-\\u0e97\\u0e99-\\u0e9f\\u0ea1-\\u0ea3\\u0ea5\\u0ea7\\u0eaa\\u0eab\\u0ead-\\u0eb0\\u0eb2\\u0eb3\\u0ebd\\u0ec0-\\u0ec4\\u0ec6\\u0edc-\\u0edf\\u0f00\\u0f40-\\u0f47\\u0f49-\\u0f6c\\u0f88-\\u0f8c\\u1000-\\u102a\\u103f\\u1050-\\u1055\\u105a-\\u105d\\u1061\\u1065\\u1066\\u106e-\\u1070\\u1075-\\u1081\\u108e\\u10a0-\\u10c5\\u10c7\\u10cd\\u10d0-\\u10fa\\u10fc-\\u1248\\u124a-\\u124d\\u1250-\\u1256\\u1258\\u125a-\\u125d\\u1260-\\u1288\\u128a-\\u128d\\u1290-\\u12b0\\u12b2-\\u12b5\\u12b8-\\u12be\\u12c0\\u12c2-\\u12c5\\u12c8-\\u12d6\\u12d8-\\u1310\\u1312-\\u1315\\u1318-\\u135a\\u1380-\\u138f\\u13a0-\\u13f5\\u13f8-\\u13fd\\u1401-\\u166c\\u166f-\\u167f\\u1681-\\u169a\\u16a0-\\u16ea\\u16ee-\\u16f8\\u1700-\\u170c\\u170e-\\u1711\\u1720-\\u1731\\u1740-\\u1751\\u1760-\\u176c\\u176e-\\u1770\\u1780-\\u17b3\\u17d7\\u17dc\\u1820-\\u1878\\u1880-\\u18a8\\u18aa\\u18b0-\\u18f5\\u1900-\\u191e\\u1950-\\u196d\\u1970-\\u1974\\u1980-\\u19ab\\u19b0-\\u19c9\\u1a00-\\u1a16\\u1a20-\\u1a54\\u1aa7\\u1b05-\\u1b33\\u1b45-\\u1b4b\\u1b83-\\u1ba0\\u1bae\\u1baf\\u1bba-\\u1be5\\u1c00-\\u1c23\\u1c4d-\\u1c4f\\u1c5a-\\u1c7d\\u1c80-\\u1c88\\u1c90-\\u1cba\\u1cbd-\\u1cbf\\u1ce9-\\u1cec\\u1cee-\\u1cf1\\u1cf5\\u1cf6\\u1d00-\\u1dbf\\u1e00-\\u1f15\\u1f18-\\u1f1d\\u1f20-\\u1f45\\u1f48-\\u1f4d\\u1f50-\\u1f57\\u1f59\\u1f5b\\u1f5d\\u1f5f-\\u1f7d\\u1f80-\\u1fb4\\u1fb6-\\u1fbc\\u1fbe\\u1fc2-\\u1fc4\\u1fc6-\\u1fcc\\u1fd0-\\u1fd3\\u1fd6-\\u1fdb\\u1fe0-\\u1fec\\u1ff2-\\u1ff4\\u1ff6-\\u1ffc\\u2071\\u207f\\u2090-\\u209c\\u2102\\u2107\\u210a-\\u2113\\u2115\\u2118-\\u211d\\u2124\\u2126\\u2128\\u212a-\\u2139\\u213c-\\u213f\\u2145-\\u2149\\u214e\\u2160-\\u2188\\u2c00-\\u2c2e\\u2c30-\\u2c5e\\u2c60-\\u2ce4\\u2ceb-\\u2cee\\u2cf2\\u2cf3\\u2d00-\\u2d25\\u2d27\\u2d2d\\u2d30-\\u2d67\\u2d6f\\u2d80-\\u2d96\\u2da0-\\u2da6\\u2da8-\\u2dae\\u2db0-\\u2db6\\u2db8-\\u2dbe\\u2dc0-\\u2dc6\\u2dc8-\\u2dce\\u2dd0-\\u2dd6\\u2dd8-\\u2dde\\u3005-\\u3007\\u3021-\\u3029\\u3031-\\u3035\\u3038-\\u303c\\u3041-\\u3096\\u309b-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u31a0-\\u31ba\\u31f0-\\u31ff\\u3400-\\u4db5\\u4e00-\\u9fef\\ua000-\\ua48c\\ua4d0-\\ua4fd\\ua500-\\ua60c\\ua610-\\ua61f\\ua62a\\ua62b\\ua640-\\ua66e\\ua67f-\\ua69d\\ua6a0-\\ua6ef\\ua717-\\ua71f\\ua722-\\ua788\\ua78b-\\ua7b9\\ua7f7-\\ua801\\ua803-\\ua805\\ua807-\\ua80a\\ua80c-\\ua822\\ua840-\\ua873\\ua882-\\ua8b3\\ua8f2-\\ua8f7\\ua8fb\\ua8fd\\ua8fe\\ua90a-\\ua925\\ua930-\\ua946\\ua960-\\ua97c\\ua984-\\ua9b2\\ua9cf\\ua9e0-\\ua9e4\\ua9e6-\\ua9ef\\ua9fa-\\ua9fe\\uaa00-\\uaa28\\uaa40-\\uaa42\\uaa44-\\uaa4b\\uaa60-\\uaa76\\uaa7a\\uaa7e-\\uaaaf\\uaab1\\uaab5\\uaab6\\uaab9-\\uaabd\\uaac0\\uaac2\\uaadb-\\uaadd\\uaae0-\\uaaea\\uaaf2-\\uaaf4\\uab01-\\uab06\\uab09-\\uab0e\\uab11-\\uab16\\uab20-\\uab26\\uab28-\\uab2e\\uab30-\\uab5a\\uab5c-\\uab65\\uab70-\\uabe2\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufb00-\\ufb06\\ufb13-\\ufb17\\ufb1d\\ufb1f-\\ufb28\\ufb2a-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40\\ufb41\\ufb43\\ufb44\\ufb46-\\ufbb1\\ufbd3-\\ufd3d\\ufd50-\\ufd8f\\ufd92-\\ufdc7\\ufdf0-\\ufdfb\\ufe70-\\ufe74\\ufe76-\\ufefc\\uff21-\\uff3a\\uff41-\\uff5a\\uff66-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc\";\nvar nonASCIIidentifierChars = \"\\u200c\\u200d\\xb7\\u0300-\\u036f\\u0387\\u0483-\\u0487\\u0591-\\u05bd\\u05bf\\u05c1\\u05c2\\u05c4\\u05c5\\u05c7\\u0610-\\u061a\\u064b-\\u0669\\u0670\\u06d6-\\u06dc\\u06df-\\u06e4\\u06e7\\u06e8\\u06ea-\\u06ed\\u06f0-\\u06f9\\u0711\\u0730-\\u074a\\u07a6-\\u07b0\\u07c0-\\u07c9\\u07eb-\\u07f3\\u07fd\\u0816-\\u0819\\u081b-\\u0823\\u0825-\\u0827\\u0829-\\u082d\\u0859-\\u085b\\u08d3-\\u08e1\\u08e3-\\u0903\\u093a-\\u093c\\u093e-\\u094f\\u0951-\\u0957\\u0962\\u0963\\u0966-\\u096f\\u0981-\\u0983\\u09bc\\u09be-\\u09c4\\u09c7\\u09c8\\u09cb-\\u09cd\\u09d7\\u09e2\\u09e3\\u09e6-\\u09ef\\u09fe\\u0a01-\\u0a03\\u0a3c\\u0a3e-\\u0a42\\u0a47\\u0a48\\u0a4b-\\u0a4d\\u0a51\\u0a66-\\u0a71\\u0a75\\u0a81-\\u0a83\\u0abc\\u0abe-\\u0ac5\\u0ac7-\\u0ac9\\u0acb-\\u0acd\\u0ae2\\u0ae3\\u0ae6-\\u0aef\\u0afa-\\u0aff\\u0b01-\\u0b03\\u0b3c\\u0b3e-\\u0b44\\u0b47\\u0b48\\u0b4b-\\u0b4d\\u0b56\\u0b57\\u0b62\\u0b63\\u0b66-\\u0b6f\\u0b82\\u0bbe-\\u0bc2\\u0bc6-\\u0bc8\\u0bca-\\u0bcd\\u0bd7\\u0be6-\\u0bef\\u0c00-\\u0c04\\u0c3e-\\u0c44\\u0c46-\\u0c48\\u0c4a-\\u0c4d\\u0c55\\u0c56\\u0c62\\u0c63\\u0c66-\\u0c6f\\u0c81-\\u0c83\\u0cbc\\u0cbe-\\u0cc4\\u0cc6-\\u0cc8\\u0cca-\\u0ccd\\u0cd5\\u0cd6\\u0ce2\\u0ce3\\u0ce6-\\u0cef\\u0d00-\\u0d03\\u0d3b\\u0d3c\\u0d3e-\\u0d44\\u0d46-\\u0d48\\u0d4a-\\u0d4d\\u0d57\\u0d62\\u0d63\\u0d66-\\u0d6f\\u0d82\\u0d83\\u0dca\\u0dcf-\\u0dd4\\u0dd6\\u0dd8-\\u0ddf\\u0de6-\\u0def\\u0df2\\u0df3\\u0e31\\u0e34-\\u0e3a\\u0e47-\\u0e4e\\u0e50-\\u0e59\\u0eb1\\u0eb4-\\u0eb9\\u0ebb\\u0ebc\\u0ec8-\\u0ecd\\u0ed0-\\u0ed9\\u0f18\\u0f19\\u0f20-\\u0f29\\u0f35\\u0f37\\u0f39\\u0f3e\\u0f3f\\u0f71-\\u0f84\\u0f86\\u0f87\\u0f8d-\\u0f97\\u0f99-\\u0fbc\\u0fc6\\u102b-\\u103e\\u1040-\\u1049\\u1056-\\u1059\\u105e-\\u1060\\u1062-\\u1064\\u1067-\\u106d\\u1071-\\u1074\\u1082-\\u108d\\u108f-\\u109d\\u135d-\\u135f\\u1369-\\u1371\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17b4-\\u17d3\\u17dd\\u17e0-\\u17e9\\u180b-\\u180d\\u1810-\\u1819\\u18a9\\u1920-\\u192b\\u1930-\\u193b\\u1946-\\u194f\\u19d0-\\u19da\\u1a17-\\u1a1b\\u1a55-\\u1a5e\\u1a60-\\u1a7c\\u1a7f-\\u1a89\\u1a90-\\u1a99\\u1ab0-\\u1abd\\u1b00-\\u1b04\\u1b34-\\u1b44\\u1b50-\\u1b59\\u1b6b-\\u1b73\\u1b80-\\u1b82\\u1ba1-\\u1bad\\u1bb0-\\u1bb9\\u1be6-\\u1bf3\\u1c24-\\u1c37\\u1c40-\\u1c49\\u1c50-\\u1c59\\u1cd0-\\u1cd2\\u1cd4-\\u1ce8\\u1ced\\u1cf2-\\u1cf4\\u1cf7-\\u1cf9\\u1dc0-\\u1df9\\u1dfb-\\u1dff\\u203f\\u2040\\u2054\\u20d0-\\u20dc\\u20e1\\u20e5-\\u20f0\\u2cef-\\u2cf1\\u2d7f\\u2de0-\\u2dff\\u302a-\\u302f\\u3099\\u309a\\ua620-\\ua629\\ua66f\\ua674-\\ua67d\\ua69e\\ua69f\\ua6f0\\ua6f1\\ua802\\ua806\\ua80b\\ua823-\\ua827\\ua880\\ua881\\ua8b4-\\ua8c5\\ua8d0-\\ua8d9\\ua8e0-\\ua8f1\\ua8ff-\\ua909\\ua926-\\ua92d\\ua947-\\ua953\\ua980-\\ua983\\ua9b3-\\ua9c0\\ua9d0-\\ua9d9\\ua9e5\\ua9f0-\\ua9f9\\uaa29-\\uaa36\\uaa43\\uaa4c\\uaa4d\\uaa50-\\uaa59\\uaa7b-\\uaa7d\\uaab0\\uaab2-\\uaab4\\uaab7\\uaab8\\uaabe\\uaabf\\uaac1\\uaaeb-\\uaaef\\uaaf5\\uaaf6\\uabe3-\\uabea\\uabec\\uabed\\uabf0-\\uabf9\\ufb1e\\ufe00-\\ufe0f\\ufe20-\\ufe2f\\ufe33\\ufe34\\ufe4d-\\ufe4f\\uff10-\\uff19\\uff3f\";\n\nvar nonASCIIidentifierStart = new RegExp(\"[\" + nonASCIIidentifierStartChars + \"]\");\nvar nonASCIIidentifier = new RegExp(\"[\" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + \"]\");\n\nnonASCIIidentifierStartChars = nonASCIIidentifierChars = null;\n\n// These are a run-length and offset encoded representation of the\n// >0xffff code points that are a valid part of identifiers. The\n// offset starts at 0x10000, and each pair of numbers represents an\n// offset to the next range, and then a size of the range. They were\n// generated by bin/generate-identifier-regex.js\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierStartCodes = [0,11,2,25,2,18,2,1,2,14,3,13,35,122,70,52,268,28,4,48,48,31,14,29,6,37,11,29,3,35,5,7,2,4,43,157,19,35,5,35,5,39,9,51,157,310,10,21,11,7,153,5,3,0,2,43,2,1,4,0,3,22,11,22,10,30,66,18,2,1,11,21,11,25,71,55,7,1,65,0,16,3,2,2,2,28,43,28,4,28,36,7,2,27,28,53,11,21,11,18,14,17,111,72,56,50,14,50,14,35,477,28,11,0,9,21,190,52,76,44,33,24,27,35,30,0,12,34,4,0,13,47,15,3,22,0,2,0,36,17,2,24,85,6,2,0,2,3,2,14,2,9,8,46,39,7,3,1,3,21,2,6,2,1,2,4,4,0,19,0,13,4,159,52,19,3,54,47,21,1,2,0,185,46,42,3,37,47,21,0,60,42,86,26,230,43,117,63,32,0,257,0,11,39,8,0,22,0,12,39,3,3,20,0,35,56,264,8,2,36,18,0,50,29,113,6,2,1,2,37,22,0,26,5,2,1,2,31,15,0,328,18,270,921,103,110,18,195,2749,1070,4050,582,8634,568,8,30,114,29,19,47,17,3,32,20,6,18,689,63,129,68,12,0,67,12,65,1,31,6129,15,754,9486,286,82,395,2309,106,6,12,4,8,8,9,5991,84,2,70,2,1,3,0,3,1,3,3,2,11,2,0,2,6,2,64,2,3,3,7,2,6,2,27,2,3,2,4,2,0,4,6,2,339,3,24,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,30,2,24,2,7,4149,196,60,67,1213,3,2,26,2,1,2,0,3,0,2,9,2,3,2,0,2,0,7,0,5,0,2,0,2,0,2,2,2,1,2,0,3,0,2,0,2,0,2,0,2,0,2,1,2,0,3,3,2,6,2,3,2,3,2,0,2,9,2,16,6,2,2,4,2,16,4421,42710,42,4148,12,221,3,5761,15,7472,3104,541];\n\n// eslint-disable-next-line comma-spacing\nvar astralIdentifierCodes = [509,0,227,0,150,4,294,9,1368,2,2,1,6,3,41,2,5,0,166,1,574,3,9,9,525,10,176,2,54,14,32,9,16,3,46,10,54,9,7,2,37,13,2,9,6,1,45,0,13,2,49,13,9,3,4,9,83,11,7,0,161,11,6,9,7,3,56,1,2,6,3,1,3,2,10,0,11,1,3,6,4,4,193,17,10,9,5,0,82,19,13,9,214,6,3,8,28,1,83,16,16,9,82,12,9,9,84,14,5,9,243,14,166,9,280,9,41,6,2,3,9,0,10,10,47,15,406,7,2,7,17,9,57,21,2,13,123,5,4,0,2,1,2,6,2,0,9,9,49,4,2,1,2,4,9,9,330,3,19306,9,135,4,60,6,26,9,1016,45,17,3,19723,1,5319,4,4,5,9,7,3,6,31,3,149,2,1418,49,513,54,5,49,9,0,15,0,23,4,2,14,1361,6,2,16,3,6,2,1,2,4,2214,6,110,6,6,9,792487,239];\n\n// This has a complexity linear to the value of the code. The\n// assumption is that looking up astral identifier characters is\n// rare.\nfunction isInAstralSet(code, set) {\n  var pos = 0x10000;\n  for (var i = 0; i < set.length; i += 2) {\n    pos += set[i];\n    if (pos > code) { return false }\n    pos += set[i + 1];\n    if (pos >= code) { return true }\n  }\n}\n\n// Test whether a given character code starts an identifier.\n\nfunction isIdentifierStart(code, astral) {\n  if (code < 65) { return code === 36 }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifierStart.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes)\n}\n\n// Test whether a given character is part of an identifier.\n\nfunction isIdentifierChar(code, astral) {\n  if (code < 48) { return code === 36 }\n  if (code < 58) { return true }\n  if (code < 65) { return false }\n  if (code < 91) { return true }\n  if (code < 97) { return code === 95 }\n  if (code < 123) { return true }\n  if (code <= 0xffff) { return code >= 0xaa && nonASCIIidentifier.test(String.fromCharCode(code)) }\n  if (astral === false) { return false }\n  return isInAstralSet(code, astralIdentifierStartCodes) || isInAstralSet(code, astralIdentifierCodes)\n}\n\n// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nvar TokenType = function TokenType(label, conf) {\n  if ( conf === void 0 ) conf = {};\n\n  this.label = label;\n  this.keyword = conf.keyword;\n  this.beforeExpr = !!conf.beforeExpr;\n  this.startsExpr = !!conf.startsExpr;\n  this.isLoop = !!conf.isLoop;\n  this.isAssign = !!conf.isAssign;\n  this.prefix = !!conf.prefix;\n  this.postfix = !!conf.postfix;\n  this.binop = conf.binop || null;\n  this.updateContext = null;\n};\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nvar beforeExpr = {beforeExpr: true};\nvar startsExpr = {startsExpr: true};\n\n// Map keyword names to token types.\n\nvar keywords$1 = {};\n\n// Succinct definitions of keyword token types\nfunction kw(name, options) {\n  if ( options === void 0 ) options = {};\n\n  options.keyword = name;\n  return keywords$1[name] = new TokenType(name, options)\n}\n\nvar types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  invalidTemplate: new TokenType(\"invalidTemplate\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"!/~\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=/===/!==\", 6),\n  relational: binop(\"</>/<=/>=\", 7),\n  bitShift: binop(\"<</>>/>>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10),\n  starstar: new TokenType(\"**\", {beforeExpr: true}),\n\n  // Keyword token types.\n  _break: kw(\"break\"),\n  _case: kw(\"case\", beforeExpr),\n  _catch: kw(\"catch\"),\n  _continue: kw(\"continue\"),\n  _debugger: kw(\"debugger\"),\n  _default: kw(\"default\", beforeExpr),\n  _do: kw(\"do\", {isLoop: true, beforeExpr: true}),\n  _else: kw(\"else\", beforeExpr),\n  _finally: kw(\"finally\"),\n  _for: kw(\"for\", {isLoop: true}),\n  _function: kw(\"function\", startsExpr),\n  _if: kw(\"if\"),\n  _return: kw(\"return\", beforeExpr),\n  _switch: kw(\"switch\"),\n  _throw: kw(\"throw\", beforeExpr),\n  _try: kw(\"try\"),\n  _var: kw(\"var\"),\n  _const: kw(\"const\"),\n  _while: kw(\"while\", {isLoop: true}),\n  _with: kw(\"with\"),\n  _new: kw(\"new\", {beforeExpr: true, startsExpr: true}),\n  _this: kw(\"this\", startsExpr),\n  _super: kw(\"super\", startsExpr),\n  _class: kw(\"class\", startsExpr),\n  _extends: kw(\"extends\", beforeExpr),\n  _export: kw(\"export\"),\n  _import: kw(\"import\"),\n  _null: kw(\"null\", startsExpr),\n  _true: kw(\"true\", startsExpr),\n  _false: kw(\"false\", startsExpr),\n  _in: kw(\"in\", {beforeExpr: true, binop: 7}),\n  _instanceof: kw(\"instanceof\", {beforeExpr: true, binop: 7}),\n  _typeof: kw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _void: kw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  _delete: kw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n};\n\n// Matches a whole line break (where CRLF is considered a single\n// line break). Used to count lines.\n\nvar lineBreak = /\\r\\n?|\\n|\\u2028|\\u2029/;\nvar lineBreakG = new RegExp(lineBreak.source, \"g\");\n\nfunction isNewLine(code, ecma2019String) {\n  return code === 10 || code === 13 || (!ecma2019String && (code === 0x2028 || code === 0x2029))\n}\n\nvar nonASCIIwhitespace = /[\\u1680\\u180e\\u2000-\\u200a\\u202f\\u205f\\u3000\\ufeff]/;\n\nvar skipWhiteSpace = /(?:\\s|\\/\\/.*|\\/\\*[^]*?\\*\\/)*/g;\n\nvar ref = Object.prototype;\nvar hasOwnProperty = ref.hasOwnProperty;\nvar toString = ref.toString;\n\n// Checks if an object has a property.\n\nfunction has(obj, propName) {\n  return hasOwnProperty.call(obj, propName)\n}\n\nvar isArray = Array.isArray || (function (obj) { return (\n  toString.call(obj) === \"[object Array]\"\n); });\n\n// These are used when `options.locations` is on, for the\n// `startLoc` and `endLoc` properties.\n\nvar Position = function Position(line, col) {\n  this.line = line;\n  this.column = col;\n};\n\nPosition.prototype.offset = function offset (n) {\n  return new Position(this.line, this.column + n)\n};\n\nvar SourceLocation = function SourceLocation(p, start, end) {\n  this.start = start;\n  this.end = end;\n  if (p.sourceFile !== null) { this.source = p.sourceFile; }\n};\n\n// The `getLineInfo` function is mostly useful when the\n// `locations` option is off (for performance reasons) and you\n// want to find the line/column position for a given character\n// offset. `input` should be the code string that the offset refers\n// into.\n\nfunction getLineInfo(input, offset) {\n  for (var line = 1, cur = 0;;) {\n    lineBreakG.lastIndex = cur;\n    var match = lineBreakG.exec(input);\n    if (match && match.index < offset) {\n      ++line;\n      cur = match.index + match[0].length;\n    } else {\n      return new Position(line, offset - cur)\n    }\n  }\n}\n\n// A second optional argument can be given to further configure\n// the parser process. These options are recognized:\n\nvar defaultOptions = {\n  // `ecmaVersion` indicates the ECMAScript version to parse. Must\n  // be either 3, 5, 6 (2015), 7 (2016), or 8 (2017). This influences support\n  // for strict mode, the set of reserved words, and support for\n  // new syntax features. The default is 7.\n  ecmaVersion: 7,\n  // `sourceType` indicates the mode the code should be parsed in.\n  // Can be either `\"script\"` or `\"module\"`. This influences global\n  // strict mode and parsing of `import` and `export` declarations.\n  sourceType: \"script\",\n  // `onInsertedSemicolon` can be a callback that will be called\n  // when a semicolon is automatically inserted. It will be passed\n  // th position of the comma as an offset, and if `locations` is\n  // enabled, it is given the location as a `{line, column}` object\n  // as second argument.\n  onInsertedSemicolon: null,\n  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for\n  // trailing commas.\n  onTrailingComma: null,\n  // By default, reserved words are only enforced if ecmaVersion >= 5.\n  // Set `allowReserved` to a boolean value to explicitly turn this on\n  // an off. When this option has the value \"never\", reserved words\n  // and keywords can also not be used as property names.\n  allowReserved: null,\n  // When enabled, a return at the top level is not considered an\n  // error.\n  allowReturnOutsideFunction: false,\n  // When enabled, import/export statements are not constrained to\n  // appearing at the top of the program.\n  allowImportExportEverywhere: false,\n  // When enabled, await identifiers are allowed to appear at the top-level scope,\n  // but they are still not allowed in non-async functions.\n  allowAwaitOutsideFunction: false,\n  // When enabled, hashbang directive in the beginning of file\n  // is allowed and treated as a line comment.\n  allowHashBang: false,\n  // When `locations` is on, `loc` properties holding objects with\n  // `start` and `end` properties in `{line, column}` form (with\n  // line being 1-based and column 0-based) will be attached to the\n  // nodes.\n  locations: false,\n  // A function can be passed as `onToken` option, which will\n  // cause Acorn to call that function with object in the same\n  // format as tokens returned from `tokenizer().getToken()`. Note\n  // that you are not allowed to call the parser from the\n  // callback—that will corrupt its internal state.\n  onToken: null,\n  // A function can be passed as `onComment` option, which will\n  // cause Acorn to call that function with `(block, text, start,\n  // end)` parameters whenever a comment is skipped. `block` is a\n  // boolean indicating whether this is a block (`/* */`) comment,\n  // `text` is the content of the comment, and `start` and `end` are\n  // character offsets that denote the start and end of the comment.\n  // When the `locations` option is on, two more parameters are\n  // passed, the full `{line, column}` locations of the start and\n  // end of the comments. Note that you are not allowed to call the\n  // parser from the callback—that will corrupt its internal state.\n  onComment: null,\n  // Nodes have their start and end characters offsets recorded in\n  // `start` and `end` properties (directly on the node, rather than\n  // the `loc` object, which holds line/column data. To also add a\n  // [semi-standardized][range] `range` property holding a `[start,\n  // end]` array with the same numbers, set the `ranges` option to\n  // `true`.\n  //\n  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678\n  ranges: false,\n  // It is possible to parse multiple files into a single AST by\n  // passing the tree produced by parsing the first file as\n  // `program` option in subsequent parses. This will add the\n  // toplevel forms of the parsed file to the `Program` (top) node\n  // of an existing parse tree.\n  program: null,\n  // When `locations` is on, you can pass this to record the source\n  // file in every node's `loc` object.\n  sourceFile: null,\n  // This value, if given, is stored in every node, whether\n  // `locations` is on or off.\n  directSourceFile: null,\n  // When enabled, parenthesized expressions are represented by\n  // (non-standard) ParenthesizedExpression nodes\n  preserveParens: false,\n  plugins: {}\n};\n\n// Interpret and default an options object\n\nfunction getOptions(opts) {\n  var options = {};\n\n  for (var opt in defaultOptions)\n    { options[opt] = opts && has(opts, opt) ? opts[opt] : defaultOptions[opt]; }\n\n  if (options.ecmaVersion >= 2015)\n    { options.ecmaVersion -= 2009; }\n\n  if (options.allowReserved == null)\n    { options.allowReserved = options.ecmaVersion < 5; }\n\n  if (isArray(options.onToken)) {\n    var tokens = options.onToken;\n    options.onToken = function (token) { return tokens.push(token); };\n  }\n  if (isArray(options.onComment))\n    { options.onComment = pushComment(options, options.onComment); }\n\n  return options\n}\n\nfunction pushComment(options, array) {\n  return function(block, text, start, end, startLoc, endLoc) {\n    var comment = {\n      type: block ? \"Block\" : \"Line\",\n      value: text,\n      start: start,\n      end: end\n    };\n    if (options.locations)\n      { comment.loc = new SourceLocation(this, startLoc, endLoc); }\n    if (options.ranges)\n      { comment.range = [start, end]; }\n    array.push(comment);\n  }\n}\n\n// Registered plugins\nvar plugins = {};\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(?:\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nvar Parser = function Parser(options, input, startPos) {\n  this.options = options = getOptions(options);\n  this.sourceFile = options.sourceFile;\n  this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5]);\n  var reserved = \"\";\n  if (!options.allowReserved) {\n    for (var v = options.ecmaVersion;; v--)\n      { if (reserved = reservedWords[v]) { break } }\n    if (options.sourceType === \"module\") { reserved += \" await\"; }\n  }\n  this.reservedWords = keywordRegexp(reserved);\n  var reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict;\n  this.reservedWordsStrict = keywordRegexp(reservedStrict);\n  this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind);\n  this.input = String(input);\n\n  // Used to signal to callers of `readWord1` whether the word\n  // contained any escape sequences. This is needed because words with\n  // escape sequences must not be interpreted as keywords.\n  this.containsEsc = false;\n\n  // Load plugins\n  this.loadPlugins(options.plugins);\n\n  // Set up token state\n\n  // The current position of the tokenizer in the input.\n  if (startPos) {\n    this.pos = startPos;\n    this.lineStart = this.input.lastIndexOf(\"\\n\", startPos - 1) + 1;\n    this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length;\n  } else {\n    this.pos = this.lineStart = 0;\n    this.curLine = 1;\n  }\n\n  // Properties of the current token:\n  // Its type\n  this.type = types.eof;\n  // For tokens that include more information than their type, the value\n  this.value = null;\n  // Its start and end offset\n  this.start = this.end = this.pos;\n  // And, if locations are used, the {line, column} object\n  // corresponding to those offsets\n  this.startLoc = this.endLoc = this.curPosition();\n\n  // Position information for the previous token\n  this.lastTokEndLoc = this.lastTokStartLoc = null;\n  this.lastTokStart = this.lastTokEnd = this.pos;\n\n  // The context stack is used to superficially track syntactic\n  // context to predict whether a regular expression is allowed in a\n  // given position.\n  this.context = this.initialContext();\n  this.exprAllowed = true;\n\n  // Figure out if it's a module code.\n  this.inModule = options.sourceType === \"module\";\n  this.strict = this.inModule || this.strictDirective(this.pos);\n\n  // Used to signify the start of a potential arrow function\n  this.potentialArrowAt = -1;\n\n  // Flags to track whether we are in a function, a generator, an async function.\n  this.inFunction = this.inGenerator = this.inAsync = false;\n  // Positions to delayed-check that yield/await does not exist in default parameters.\n  this.yieldPos = this.awaitPos = 0;\n  // Labels in scope.\n  this.labels = [];\n\n  // If enabled, skip leading hashbang line.\n  if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === \"#!\")\n    { this.skipLineComment(2); }\n\n  // Scope tracking for duplicate variable names (see scope.js)\n  this.scopeStack = [];\n  this.enterFunctionScope();\n\n  // For RegExp validation\n  this.regexpState = null;\n};\n\n// DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\nParser.prototype.isKeyword = function isKeyword (word) { return this.keywords.test(word) };\nParser.prototype.isReservedWord = function isReservedWord (word) { return this.reservedWords.test(word) };\n\nParser.prototype.extend = function extend (name, f) {\n  this[name] = f(this[name]);\n};\n\nParser.prototype.loadPlugins = function loadPlugins (pluginConfigs) {\n    var this$1 = this;\n\n  for (var name in pluginConfigs) {\n    var plugin = plugins[name];\n    if (!plugin) { throw new Error(\"Plugin '\" + name + \"' not found\") }\n    plugin(this$1, pluginConfigs[name]);\n  }\n};\n\nParser.prototype.parse = function parse () {\n  var node = this.options.program || this.startNode();\n  this.nextToken();\n  return this.parseTopLevel(node)\n};\n\nvar pp = Parser.prototype;\n\n// ## Parser utilities\n\nvar literal = /^(?:'((?:\\\\.|[^'])*?)'|\"((?:\\\\.|[^\"])*?)\"|;)/;\npp.strictDirective = function(start) {\n  var this$1 = this;\n\n  for (;;) {\n    skipWhiteSpace.lastIndex = start;\n    start += skipWhiteSpace.exec(this$1.input)[0].length;\n    var match = literal.exec(this$1.input.slice(start));\n    if (!match) { return false }\n    if ((match[1] || match[2]) === \"use strict\") { return true }\n    start += match[0].length;\n  }\n};\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next();\n    return true\n  } else {\n    return false\n  }\n};\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === types.name && this.value === name && !this.containsEsc\n};\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  if (!this.isContextual(name)) { return false }\n  this.next();\n  return true\n};\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) { this.unexpected(); }\n};\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === types.eof ||\n    this.type === types.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      { this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc); }\n    return true\n  }\n};\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(types.semi) && !this.insertSemicolon()) { this.unexpected(); }\n};\n\npp.afterTrailingComma = function(tokType, notNext) {\n  if (this.type === tokType) {\n    if (this.options.onTrailingComma)\n      { this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc); }\n    if (!notNext)\n      { this.next(); }\n    return true\n  }\n};\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected();\n};\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\");\n};\n\nfunction DestructuringErrors() {\n  this.shorthandAssign =\n  this.trailingComma =\n  this.parenthesizedAssign =\n  this.parenthesizedBind =\n  this.doubleProto =\n    -1;\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, isAssign) {\n  if (!refDestructuringErrors) { return }\n  if (refDestructuringErrors.trailingComma > -1)\n    { this.raiseRecoverable(refDestructuringErrors.trailingComma, \"Comma is not permitted after the rest element\"); }\n  var parens = isAssign ? refDestructuringErrors.parenthesizedAssign : refDestructuringErrors.parenthesizedBind;\n  if (parens > -1) { this.raiseRecoverable(parens, \"Parenthesized pattern\"); }\n};\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  if (!refDestructuringErrors) { return false }\n  var shorthandAssign = refDestructuringErrors.shorthandAssign;\n  var doubleProto = refDestructuringErrors.doubleProto;\n  if (!andThrow) { return shorthandAssign >= 0 || doubleProto >= 0 }\n  if (shorthandAssign >= 0)\n    { this.raise(shorthandAssign, \"Shorthand property assignments are valid only in destructuring patterns\"); }\n  if (doubleProto >= 0)\n    { this.raiseRecoverable(doubleProto, \"Redefinition of __proto__ property\"); }\n};\n\npp.checkYieldAwaitInDefaultParams = function() {\n  if (this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos))\n    { this.raise(this.yieldPos, \"Yield expression cannot be a default value\"); }\n  if (this.awaitPos)\n    { this.raise(this.awaitPos, \"Await expression cannot be a default value\"); }\n};\n\npp.isSimpleAssignTarget = function(expr) {\n  if (expr.type === \"ParenthesizedExpression\")\n    { return this.isSimpleAssignTarget(expr.expression) }\n  return expr.type === \"Identifier\" || expr.type === \"MemberExpression\"\n};\n\nvar pp$1 = Parser.prototype;\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp$1.parseTopLevel = function(node) {\n  var this$1 = this;\n\n  var exports = {};\n  if (!node.body) { node.body = []; }\n  while (this.type !== types.eof) {\n    var stmt = this$1.parseStatement(true, true, exports);\n    node.body.push(stmt);\n  }\n  this.adaptDirectivePrologue(node.body);\n  this.next();\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType;\n  }\n  return this.finishNode(node, \"Program\")\n};\n\nvar loopLabel = {kind: \"loop\"};\nvar switchLabel = {kind: \"switch\"};\n\npp$1.isLet = function() {\n  if (this.options.ecmaVersion < 6 || !this.isContextual(\"let\")) { return false }\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length, nextCh = this.input.charCodeAt(next);\n  if (nextCh === 91 || nextCh === 123) { return true } // '{' and '['\n  if (isIdentifierStart(nextCh, true)) {\n    var pos = next + 1;\n    while (isIdentifierChar(this.input.charCodeAt(pos), true)) { ++pos; }\n    var ident = this.input.slice(next, pos);\n    if (!keywordRelationalOperator.test(ident)) { return true }\n  }\n  return false\n};\n\n// check 'async [no LineTerminator here] function'\n// - 'async /*foo*/ function' is OK.\n// - 'async /*\\n*/ function' is invalid.\npp$1.isAsyncFunction = function() {\n  if (this.options.ecmaVersion < 8 || !this.isContextual(\"async\"))\n    { return false }\n\n  skipWhiteSpace.lastIndex = this.pos;\n  var skip = skipWhiteSpace.exec(this.input);\n  var next = this.pos + skip[0].length;\n  return !lineBreak.test(this.input.slice(this.pos, next)) &&\n    this.input.slice(next, next + 8) === \"function\" &&\n    (next + 8 === this.input.length || !isIdentifierChar(this.input.charAt(next + 8)))\n};\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp$1.parseStatement = function(declaration, topLevel, exports) {\n  var starttype = this.type, node = this.startNode(), kind;\n\n  if (this.isLet()) {\n    starttype = types._var;\n    kind = \"let\";\n  }\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case types._break: case types._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case types._debugger: return this.parseDebuggerStatement(node)\n  case types._do: return this.parseDoStatement(node)\n  case types._for: return this.parseForStatement(node)\n  case types._function:\n    if (!declaration && this.options.ecmaVersion >= 6) { this.unexpected(); }\n    return this.parseFunctionStatement(node, false)\n  case types._class:\n    if (!declaration) { this.unexpected(); }\n    return this.parseClass(node, true)\n  case types._if: return this.parseIfStatement(node)\n  case types._return: return this.parseReturnStatement(node)\n  case types._switch: return this.parseSwitchStatement(node)\n  case types._throw: return this.parseThrowStatement(node)\n  case types._try: return this.parseTryStatement(node)\n  case types._const: case types._var:\n    kind = kind || this.value;\n    if (!declaration && kind !== \"var\") { this.unexpected(); }\n    return this.parseVarStatement(node, kind)\n  case types._while: return this.parseWhileStatement(node)\n  case types._with: return this.parseWithStatement(node)\n  case types.braceL: return this.parseBlock()\n  case types.semi: return this.parseEmptyStatement(node)\n  case types._export:\n  case types._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        { this.raise(this.start, \"'import' and 'export' may only appear at the top level\"); }\n      if (!this.inModule)\n        { this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\"); }\n    }\n    return starttype === types._import ? this.parseImport(node) : this.parseExport(node, exports)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    if (this.isAsyncFunction()) {\n      if (!declaration) { this.unexpected(); }\n      this.next();\n      return this.parseFunctionStatement(node, true)\n    }\n\n    var maybeName = this.value, expr = this.parseExpression();\n    if (starttype === types.name && expr.type === \"Identifier\" && this.eat(types.colon))\n      { return this.parseLabeledStatement(node, maybeName, expr) }\n    else { return this.parseExpressionStatement(node, expr) }\n  }\n};\n\npp$1.parseBreakContinueStatement = function(node, keyword) {\n  var this$1 = this;\n\n  var isBreak = keyword === \"break\";\n  this.next();\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.label = null; }\n  else if (this.type !== types.name) { this.unexpected(); }\n  else {\n    node.label = this.parseIdent();\n    this.semicolon();\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  var i = 0;\n  for (; i < this.labels.length; ++i) {\n    var lab = this$1.labels[i];\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) { break }\n      if (node.label && isBreak) { break }\n    }\n  }\n  if (i === this.labels.length) { this.raise(node.start, \"Unsyntactic \" + keyword); }\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n};\n\npp$1.parseDebuggerStatement = function(node) {\n  this.next();\n  this.semicolon();\n  return this.finishNode(node, \"DebuggerStatement\")\n};\n\npp$1.parseDoStatement = function(node) {\n  this.next();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  this.expect(types._while);\n  node.test = this.parseParenExpression();\n  if (this.options.ecmaVersion >= 6)\n    { this.eat(types.semi); }\n  else\n    { this.semicolon(); }\n  return this.finishNode(node, \"DoWhileStatement\")\n};\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp$1.parseForStatement = function(node) {\n  this.next();\n  var awaitAt = (this.options.ecmaVersion >= 9 && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction)) && this.eatContextual(\"await\")) ? this.lastTokStart : -1;\n  this.labels.push(loopLabel);\n  this.enterLexicalScope();\n  this.expect(types.parenL);\n  if (this.type === types.semi) {\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, null)\n  }\n  var isLet = this.isLet();\n  if (this.type === types._var || this.type === types._const || isLet) {\n    var init$1 = this.startNode(), kind = isLet ? \"let\" : this.value;\n    this.next();\n    this.parseVar(init$1, true, kind);\n    this.finishNode(init$1, \"VariableDeclaration\");\n    if ((this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init$1.declarations.length === 1 &&\n        !(kind !== \"var\" && init$1.declarations[0].init)) {\n      if (this.options.ecmaVersion >= 9) {\n        if (this.type === types._in) {\n          if (awaitAt > -1) { this.unexpected(awaitAt); }\n        } else { node.await = awaitAt > -1; }\n      }\n      return this.parseForIn(node, init$1)\n    }\n    if (awaitAt > -1) { this.unexpected(awaitAt); }\n    return this.parseFor(node, init$1)\n  }\n  var refDestructuringErrors = new DestructuringErrors;\n  var init = this.parseExpression(true, refDestructuringErrors);\n  if (this.type === types._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    if (this.options.ecmaVersion >= 9) {\n      if (this.type === types._in) {\n        if (awaitAt > -1) { this.unexpected(awaitAt); }\n      } else { node.await = awaitAt > -1; }\n    }\n    this.toAssignable(init, false, refDestructuringErrors);\n    this.checkLVal(init);\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true);\n  }\n  if (awaitAt > -1) { this.unexpected(awaitAt); }\n  return this.parseFor(node, init)\n};\n\npp$1.parseFunctionStatement = function(node, isAsync) {\n  this.next();\n  return this.parseFunction(node, true, false, isAsync)\n};\n\npp$1.parseIfStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  // allow function declarations in branches, but only in non-strict mode\n  node.consequent = this.parseStatement(!this.strict && this.type === types._function);\n  node.alternate = this.eat(types._else) ? this.parseStatement(!this.strict && this.type === types._function) : null;\n  return this.finishNode(node, \"IfStatement\")\n};\n\npp$1.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    { this.raise(this.start, \"'return' outside of function\"); }\n  this.next();\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(types.semi) || this.insertSemicolon()) { node.argument = null; }\n  else { node.argument = this.parseExpression(); this.semicolon(); }\n  return this.finishNode(node, \"ReturnStatement\")\n};\n\npp$1.parseSwitchStatement = function(node) {\n  var this$1 = this;\n\n  this.next();\n  node.discriminant = this.parseParenExpression();\n  node.cases = [];\n  this.expect(types.braceL);\n  this.labels.push(switchLabel);\n  this.enterLexicalScope();\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  var cur;\n  for (var sawDefault = false; this.type !== types.braceR;) {\n    if (this$1.type === types._case || this$1.type === types._default) {\n      var isCase = this$1.type === types._case;\n      if (cur) { this$1.finishNode(cur, \"SwitchCase\"); }\n      node.cases.push(cur = this$1.startNode());\n      cur.consequent = [];\n      this$1.next();\n      if (isCase) {\n        cur.test = this$1.parseExpression();\n      } else {\n        if (sawDefault) { this$1.raiseRecoverable(this$1.lastTokStart, \"Multiple default clauses\"); }\n        sawDefault = true;\n        cur.test = null;\n      }\n      this$1.expect(types.colon);\n    } else {\n      if (!cur) { this$1.unexpected(); }\n      cur.consequent.push(this$1.parseStatement(true));\n    }\n  }\n  this.exitLexicalScope();\n  if (cur) { this.finishNode(cur, \"SwitchCase\"); }\n  this.next(); // Closing brace\n  this.labels.pop();\n  return this.finishNode(node, \"SwitchStatement\")\n};\n\npp$1.parseThrowStatement = function(node) {\n  this.next();\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    { this.raise(this.lastTokEnd, \"Illegal newline after throw\"); }\n  node.argument = this.parseExpression();\n  this.semicolon();\n  return this.finishNode(node, \"ThrowStatement\")\n};\n\n// Reused empty array added for node fields that are always empty.\n\nvar empty = [];\n\npp$1.parseTryStatement = function(node) {\n  this.next();\n  node.block = this.parseBlock();\n  node.handler = null;\n  if (this.type === types._catch) {\n    var clause = this.startNode();\n    this.next();\n    if (this.eat(types.parenL)) {\n      clause.param = this.parseBindingAtom();\n      this.enterLexicalScope();\n      this.checkLVal(clause.param, \"let\");\n      this.expect(types.parenR);\n    } else {\n      if (this.options.ecmaVersion < 10) { this.unexpected(); }\n      clause.param = null;\n      this.enterLexicalScope();\n    }\n    clause.body = this.parseBlock(false);\n    this.exitLexicalScope();\n    node.handler = this.finishNode(clause, \"CatchClause\");\n  }\n  node.finalizer = this.eat(types._finally) ? this.parseBlock() : null;\n  if (!node.handler && !node.finalizer)\n    { this.raise(node.start, \"Missing catch or finally clause\"); }\n  return this.finishNode(node, \"TryStatement\")\n};\n\npp$1.parseVarStatement = function(node, kind) {\n  this.next();\n  this.parseVar(node, false, kind);\n  this.semicolon();\n  return this.finishNode(node, \"VariableDeclaration\")\n};\n\npp$1.parseWhileStatement = function(node) {\n  this.next();\n  node.test = this.parseParenExpression();\n  this.labels.push(loopLabel);\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"WhileStatement\")\n};\n\npp$1.parseWithStatement = function(node) {\n  if (this.strict) { this.raise(this.start, \"'with' in strict mode\"); }\n  this.next();\n  node.object = this.parseParenExpression();\n  node.body = this.parseStatement(false);\n  return this.finishNode(node, \"WithStatement\")\n};\n\npp$1.parseEmptyStatement = function(node) {\n  this.next();\n  return this.finishNode(node, \"EmptyStatement\")\n};\n\npp$1.parseLabeledStatement = function(node, maybeName, expr) {\n  var this$1 = this;\n\n  for (var i$1 = 0, list = this$1.labels; i$1 < list.length; i$1 += 1)\n    {\n    var label = list[i$1];\n\n    if (label.name === maybeName)\n      { this$1.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\");\n  } }\n  var kind = this.type.isLoop ? \"loop\" : this.type === types._switch ? \"switch\" : null;\n  for (var i = this.labels.length - 1; i >= 0; i--) {\n    var label$1 = this$1.labels[i];\n    if (label$1.statementStart === node.start) {\n      // Update information about previous labels on this node\n      label$1.statementStart = this$1.start;\n      label$1.kind = kind;\n    } else { break }\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start});\n  node.body = this.parseStatement(true);\n  if (node.body.type === \"ClassDeclaration\" ||\n      node.body.type === \"VariableDeclaration\" && node.body.kind !== \"var\" ||\n      node.body.type === \"FunctionDeclaration\" && (this.strict || node.body.generator || node.body.async))\n    { this.raiseRecoverable(node.body.start, \"Invalid labeled declaration\"); }\n  this.labels.pop();\n  node.label = expr;\n  return this.finishNode(node, \"LabeledStatement\")\n};\n\npp$1.parseExpressionStatement = function(node, expr) {\n  node.expression = expr;\n  this.semicolon();\n  return this.finishNode(node, \"ExpressionStatement\")\n};\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp$1.parseBlock = function(createNewLexicalScope) {\n  var this$1 = this;\n  if ( createNewLexicalScope === void 0 ) createNewLexicalScope = true;\n\n  var node = this.startNode();\n  node.body = [];\n  this.expect(types.braceL);\n  if (createNewLexicalScope) {\n    this.enterLexicalScope();\n  }\n  while (!this.eat(types.braceR)) {\n    var stmt = this$1.parseStatement(true);\n    node.body.push(stmt);\n  }\n  if (createNewLexicalScope) {\n    this.exitLexicalScope();\n  }\n  return this.finishNode(node, \"BlockStatement\")\n};\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp$1.parseFor = function(node, init) {\n  node.init = init;\n  this.expect(types.semi);\n  node.test = this.type === types.semi ? null : this.parseExpression();\n  this.expect(types.semi);\n  node.update = this.type === types.parenR ? null : this.parseExpression();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, \"ForStatement\")\n};\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp$1.parseForIn = function(node, init) {\n  var type = this.type === types._in ? \"ForInStatement\" : \"ForOfStatement\";\n  this.next();\n  if (type === \"ForInStatement\") {\n    if (init.type === \"AssignmentPattern\" ||\n      (init.type === \"VariableDeclaration\" && init.declarations[0].init != null &&\n       (this.strict || init.declarations[0].id.type !== \"Identifier\")))\n      { this.raise(init.start, \"Invalid assignment in for-in loop head\"); }\n  }\n  node.left = init;\n  node.right = type === \"ForInStatement\" ? this.parseExpression() : this.parseMaybeAssign();\n  this.expect(types.parenR);\n  this.exitLexicalScope();\n  node.body = this.parseStatement(false);\n  this.labels.pop();\n  return this.finishNode(node, type)\n};\n\n// Parse a list of variable declarations.\n\npp$1.parseVar = function(node, isFor, kind) {\n  var this$1 = this;\n\n  node.declarations = [];\n  node.kind = kind;\n  for (;;) {\n    var decl = this$1.startNode();\n    this$1.parseVarId(decl, kind);\n    if (this$1.eat(types.eq)) {\n      decl.init = this$1.parseMaybeAssign(isFor);\n    } else if (kind === \"const\" && !(this$1.type === types._in || (this$1.options.ecmaVersion >= 6 && this$1.isContextual(\"of\")))) {\n      this$1.unexpected();\n    } else if (decl.id.type !== \"Identifier\" && !(isFor && (this$1.type === types._in || this$1.isContextual(\"of\")))) {\n      this$1.raise(this$1.lastTokEnd, \"Complex binding patterns require an initialization value\");\n    } else {\n      decl.init = null;\n    }\n    node.declarations.push(this$1.finishNode(decl, \"VariableDeclarator\"));\n    if (!this$1.eat(types.comma)) { break }\n  }\n  return node\n};\n\npp$1.parseVarId = function(decl, kind) {\n  decl.id = this.parseBindingAtom(kind);\n  this.checkLVal(decl.id, kind, false);\n};\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseFunction = function(node, isStatement, allowExpressionBody, isAsync) {\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !isAsync)\n    { node.generator = this.eat(types.star); }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  if (isStatement) {\n    node.id = isStatement === \"nullableID\" && this.type !== types.name ? null : this.parseIdent();\n    if (node.id) {\n      this.checkLVal(node.id, this.inModule && !this.inFunction ? \"let\" : \"var\");\n    }\n  }\n\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  if (!isStatement)\n    { node.id = this.type === types.name ? this.parseIdent() : null; }\n\n  this.parseFunctionParams(node);\n  this.parseFunctionBody(node, allowExpressionBody);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n};\n\npp$1.parseFunctionParams = function(node) {\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n};\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp$1.parseClass = function(node, isStatement) {\n  var this$1 = this;\n\n  this.next();\n\n  this.parseClassId(node, isStatement);\n  this.parseClassSuper(node);\n  var classBody = this.startNode();\n  var hadConstructor = false;\n  classBody.body = [];\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    var member = this$1.parseClassMember(classBody);\n    if (member && member.type === \"MethodDefinition\" && member.kind === \"constructor\") {\n      if (hadConstructor) { this$1.raise(member.start, \"Duplicate constructor in the same class\"); }\n      hadConstructor = true;\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\");\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n};\n\npp$1.parseClassMember = function(classBody) {\n  var this$1 = this;\n\n  if (this.eat(types.semi)) { return null }\n\n  var method = this.startNode();\n  var tryContextual = function (k, noLineBreak) {\n    if ( noLineBreak === void 0 ) noLineBreak = false;\n\n    var start = this$1.start, startLoc = this$1.startLoc;\n    if (!this$1.eatContextual(k)) { return false }\n    if (this$1.type !== types.parenL && (!noLineBreak || !this$1.canInsertSemicolon())) { return true }\n    if (method.key) { this$1.unexpected(); }\n    method.computed = false;\n    method.key = this$1.startNodeAt(start, startLoc);\n    method.key.name = k;\n    this$1.finishNode(method.key, \"Identifier\");\n    return false\n  };\n\n  method.kind = \"method\";\n  method.static = tryContextual(\"static\");\n  var isGenerator = this.eat(types.star);\n  var isAsync = false;\n  if (!isGenerator) {\n    if (this.options.ecmaVersion >= 8 && tryContextual(\"async\", true)) {\n      isAsync = true;\n      isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    } else if (tryContextual(\"get\")) {\n      method.kind = \"get\";\n    } else if (tryContextual(\"set\")) {\n      method.kind = \"set\";\n    }\n  }\n  if (!method.key) { this.parsePropertyName(method); }\n  var key = method.key;\n  if (!method.computed && !method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n      key.type === \"Literal\" && key.value === \"constructor\")) {\n    if (method.kind !== \"method\") { this.raise(key.start, \"Constructor can't have get/set modifier\"); }\n    if (isGenerator) { this.raise(key.start, \"Constructor can't be a generator\"); }\n    if (isAsync) { this.raise(key.start, \"Constructor can't be an async method\"); }\n    method.kind = \"constructor\";\n  } else if (method.static && key.type === \"Identifier\" && key.name === \"prototype\") {\n    this.raise(key.start, \"Classes may not have a static property named prototype\");\n  }\n  this.parseClassMethod(classBody, method, isGenerator, isAsync);\n  if (method.kind === \"get\" && method.value.params.length !== 0)\n    { this.raiseRecoverable(method.value.start, \"getter should have no params\"); }\n  if (method.kind === \"set\" && method.value.params.length !== 1)\n    { this.raiseRecoverable(method.value.start, \"setter should have exactly one param\"); }\n  if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n    { this.raiseRecoverable(method.value.params[0].start, \"Setter cannot use rest params\"); }\n  return method\n};\n\npp$1.parseClassMethod = function(classBody, method, isGenerator, isAsync) {\n  method.value = this.parseMethod(isGenerator, isAsync);\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"));\n};\n\npp$1.parseClassId = function(node, isStatement) {\n  node.id = this.type === types.name ? this.parseIdent() : isStatement === true ? this.unexpected() : null;\n};\n\npp$1.parseClassSuper = function(node) {\n  node.superClass = this.eat(types._extends) ? this.parseExprSubscripts() : null;\n};\n\n// Parses module export declaration.\n\npp$1.parseExport = function(node, exports) {\n  var this$1 = this;\n\n  this.next();\n  // export * from '...'\n  if (this.eat(types.star)) {\n    this.expectContextual(\"from\");\n    if (this.type !== types.string) { this.unexpected(); }\n    node.source = this.parseExprAtom();\n    this.semicolon();\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(types._default)) { // export default ...\n    this.checkExport(exports, \"default\", this.lastTokStart);\n    var isAsync;\n    if (this.type === types._function || (isAsync = this.isAsyncFunction())) {\n      var fNode = this.startNode();\n      this.next();\n      if (isAsync) { this.next(); }\n      node.declaration = this.parseFunction(fNode, \"nullableID\", false, isAsync);\n    } else if (this.type === types._class) {\n      var cNode = this.startNode();\n      node.declaration = this.parseClass(cNode, \"nullableID\");\n    } else {\n      node.declaration = this.parseMaybeAssign();\n      this.semicolon();\n    }\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true);\n    if (node.declaration.type === \"VariableDeclaration\")\n      { this.checkVariableExport(exports, node.declaration.declarations); }\n    else\n      { this.checkExport(exports, node.declaration.id.name, node.declaration.id.start); }\n    node.specifiers = [];\n    node.source = null;\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null;\n    node.specifiers = this.parseExportSpecifiers(exports);\n    if (this.eatContextual(\"from\")) {\n      if (this.type !== types.string) { this.unexpected(); }\n      node.source = this.parseExprAtom();\n    } else {\n      // check for keywords used as local names\n      for (var i = 0, list = node.specifiers; i < list.length; i += 1) {\n        var spec = list[i];\n\n        this$1.checkUnreserved(spec.local);\n      }\n\n      node.source = null;\n    }\n    this.semicolon();\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n};\n\npp$1.checkExport = function(exports, name, pos) {\n  if (!exports) { return }\n  if (has(exports, name))\n    { this.raiseRecoverable(pos, \"Duplicate export '\" + name + \"'\"); }\n  exports[name] = true;\n};\n\npp$1.checkPatternExport = function(exports, pat) {\n  var this$1 = this;\n\n  var type = pat.type;\n  if (type === \"Identifier\")\n    { this.checkExport(exports, pat.name, pat.start); }\n  else if (type === \"ObjectPattern\")\n    { for (var i = 0, list = pat.properties; i < list.length; i += 1)\n      {\n        var prop = list[i];\n\n        this$1.checkPatternExport(exports, prop);\n      } }\n  else if (type === \"ArrayPattern\")\n    { for (var i$1 = 0, list$1 = pat.elements; i$1 < list$1.length; i$1 += 1) {\n      var elt = list$1[i$1];\n\n        if (elt) { this$1.checkPatternExport(exports, elt); }\n    } }\n  else if (type === \"Property\")\n    { this.checkPatternExport(exports, pat.value); }\n  else if (type === \"AssignmentPattern\")\n    { this.checkPatternExport(exports, pat.left); }\n  else if (type === \"RestElement\")\n    { this.checkPatternExport(exports, pat.argument); }\n  else if (type === \"ParenthesizedExpression\")\n    { this.checkPatternExport(exports, pat.expression); }\n};\n\npp$1.checkVariableExport = function(exports, decls) {\n  var this$1 = this;\n\n  if (!exports) { return }\n  for (var i = 0, list = decls; i < list.length; i += 1)\n    {\n    var decl = list[i];\n\n    this$1.checkPatternExport(exports, decl.id);\n  }\n};\n\npp$1.shouldParseExportStatement = function() {\n  return this.type.keyword === \"var\" ||\n    this.type.keyword === \"const\" ||\n    this.type.keyword === \"class\" ||\n    this.type.keyword === \"function\" ||\n    this.isLet() ||\n    this.isAsyncFunction()\n};\n\n// Parses a comma-separated list of module exports.\n\npp$1.parseExportSpecifiers = function(exports) {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  // export { x, y as z } [from '...']\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node = this$1.startNode();\n    node.local = this$1.parseIdent(true);\n    node.exported = this$1.eatContextual(\"as\") ? this$1.parseIdent(true) : node.local;\n    this$1.checkExport(exports, node.exported.name, node.exported.start);\n    nodes.push(this$1.finishNode(node, \"ExportSpecifier\"));\n  }\n  return nodes\n};\n\n// Parses import declaration.\n\npp$1.parseImport = function(node) {\n  this.next();\n  // import '...'\n  if (this.type === types.string) {\n    node.specifiers = empty;\n    node.source = this.parseExprAtom();\n  } else {\n    node.specifiers = this.parseImportSpecifiers();\n    this.expectContextual(\"from\");\n    node.source = this.type === types.string ? this.parseExprAtom() : this.unexpected();\n  }\n  this.semicolon();\n  return this.finishNode(node, \"ImportDeclaration\")\n};\n\n// Parses a comma-separated list of module imports.\n\npp$1.parseImportSpecifiers = function() {\n  var this$1 = this;\n\n  var nodes = [], first = true;\n  if (this.type === types.name) {\n    // import defaultObj, { x, y as z } from '...'\n    var node = this.startNode();\n    node.local = this.parseIdent();\n    this.checkLVal(node.local, \"let\");\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"));\n    if (!this.eat(types.comma)) { return nodes }\n  }\n  if (this.type === types.star) {\n    var node$1 = this.startNode();\n    this.next();\n    this.expectContextual(\"as\");\n    node$1.local = this.parseIdent();\n    this.checkLVal(node$1.local, \"let\");\n    nodes.push(this.finishNode(node$1, \"ImportNamespaceSpecifier\"));\n    return nodes\n  }\n  this.expect(types.braceL);\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var node$2 = this$1.startNode();\n    node$2.imported = this$1.parseIdent(true);\n    if (this$1.eatContextual(\"as\")) {\n      node$2.local = this$1.parseIdent();\n    } else {\n      this$1.checkUnreserved(node$2.imported);\n      node$2.local = node$2.imported;\n    }\n    this$1.checkLVal(node$2.local, \"let\");\n    nodes.push(this$1.finishNode(node$2, \"ImportSpecifier\"));\n  }\n  return nodes\n};\n\n// Set `ExpressionStatement#directive` property for directive prologues.\npp$1.adaptDirectivePrologue = function(statements) {\n  for (var i = 0; i < statements.length && this.isDirectiveCandidate(statements[i]); ++i) {\n    statements[i].directive = statements[i].expression.raw.slice(1, -1);\n  }\n};\npp$1.isDirectiveCandidate = function(statement) {\n  return (\n    statement.type === \"ExpressionStatement\" &&\n    statement.expression.type === \"Literal\" &&\n    typeof statement.expression.value === \"string\" &&\n    // Reject parenthesized strings.\n    (this.input[statement.start] === \"\\\"\" || this.input[statement.start] === \"'\")\n  )\n};\n\nvar pp$2 = Parser.prototype;\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp$2.toAssignable = function(node, isBinding, refDestructuringErrors) {\n  var this$1 = this;\n\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n      if (this.inAsync && node.name === \"await\")\n        { this.raise(node.start, \"Can not use 'await' as identifier inside an async function\"); }\n      break\n\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n    case \"RestElement\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      for (var i = 0, list = node.properties; i < list.length; i += 1) {\n        var prop = list[i];\n\n      this$1.toAssignable(prop, isBinding);\n        // Early error:\n        //   AssignmentRestProperty[Yield, Await] :\n        //     `...` DestructuringAssignmentTarget[Yield, Await]\n        //\n        //   It is a Syntax Error if |DestructuringAssignmentTarget| is an |ArrayLiteral| or an |ObjectLiteral|.\n        if (\n          prop.type === \"RestElement\" &&\n          (prop.argument.type === \"ArrayPattern\" || prop.argument.type === \"ObjectPattern\")\n        ) {\n          this$1.raise(prop.argument.start, \"Unexpected token\");\n        }\n      }\n      break\n\n    case \"Property\":\n      // AssignmentProperty has type === \"Property\"\n      if (node.kind !== \"init\") { this.raise(node.key.start, \"Object pattern can't contain getter or setter\"); }\n      this.toAssignable(node.value, isBinding);\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\";\n      if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n      this.toAssignableList(node.elements, isBinding);\n      break\n\n    case \"SpreadElement\":\n      node.type = \"RestElement\";\n      this.toAssignable(node.argument, isBinding);\n      if (node.argument.type === \"AssignmentPattern\")\n        { this.raise(node.argument.start, \"Rest elements cannot have a default value\"); }\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator !== \"=\") { this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\"); }\n      node.type = \"AssignmentPattern\";\n      delete node.operator;\n      this.toAssignable(node.left, isBinding);\n      // falls through to AssignmentPattern\n\n    case \"AssignmentPattern\":\n      break\n\n    case \"ParenthesizedExpression\":\n      this.toAssignable(node.expression, isBinding);\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) { break }\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\");\n    }\n  } else if (refDestructuringErrors) { this.checkPatternErrors(refDestructuringErrors, true); }\n  return node\n};\n\n// Convert list of expression atoms to binding list.\n\npp$2.toAssignableList = function(exprList, isBinding) {\n  var this$1 = this;\n\n  var end = exprList.length;\n  for (var i = 0; i < end; i++) {\n    var elt = exprList[i];\n    if (elt) { this$1.toAssignable(elt, isBinding); }\n  }\n  if (end) {\n    var last = exprList[end - 1];\n    if (this.options.ecmaVersion === 6 && isBinding && last && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      { this.unexpected(last.argument.start); }\n  }\n  return exprList\n};\n\n// Parses spread element.\n\npp$2.parseSpread = function(refDestructuringErrors) {\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n  return this.finishNode(node, \"SpreadElement\")\n};\n\npp$2.parseRestBinding = function() {\n  var node = this.startNode();\n  this.next();\n\n  // RestElement inside of a function parameter must be an identifier\n  if (this.options.ecmaVersion === 6 && this.type !== types.name)\n    { this.unexpected(); }\n\n  node.argument = this.parseBindingAtom();\n\n  return this.finishNode(node, \"RestElement\")\n};\n\n// Parses lvalue (assignable) atom.\n\npp$2.parseBindingAtom = function() {\n  if (this.options.ecmaVersion >= 6) {\n    switch (this.type) {\n    case types.bracketL:\n      var node = this.startNode();\n      this.next();\n      node.elements = this.parseBindingList(types.bracketR, true, true);\n      return this.finishNode(node, \"ArrayPattern\")\n\n    case types.braceL:\n      return this.parseObj(true)\n    }\n  }\n  return this.parseIdent()\n};\n\npp$2.parseBindingList = function(close, allowEmpty, allowTrailingComma) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (first) { first = false; }\n    else { this$1.expect(types.comma); }\n    if (allowEmpty && this$1.type === types.comma) {\n      elts.push(null);\n    } else if (allowTrailingComma && this$1.afterTrailingComma(close)) {\n      break\n    } else if (this$1.type === types.ellipsis) {\n      var rest = this$1.parseRestBinding();\n      this$1.parseBindingListItem(rest);\n      elts.push(rest);\n      if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n      this$1.expect(close);\n      break\n    } else {\n      var elem = this$1.parseMaybeDefault(this$1.start, this$1.startLoc);\n      this$1.parseBindingListItem(elem);\n      elts.push(elem);\n    }\n  }\n  return elts\n};\n\npp$2.parseBindingListItem = function(param) {\n  return param\n};\n\n// Parses assignment pattern around given atom if possible.\n\npp$2.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom();\n  if (this.options.ecmaVersion < 6 || !this.eat(types.eq)) { return left }\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.right = this.parseMaybeAssign();\n  return this.finishNode(node, \"AssignmentPattern\")\n};\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n// bindingType can be either:\n// 'var' indicating that the lval creates a 'var' binding\n// 'let' indicating that the lval creates a lexical ('let' or 'const') binding\n// 'none' indicating that the binding should be checked for illegal identifiers, but not for duplicate references\n\npp$2.checkLVal = function(expr, bindingType, checkClashes) {\n  var this$1 = this;\n\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      { this.raiseRecoverable(expr.start, (bindingType ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\"); }\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        { this.raiseRecoverable(expr.start, \"Argument name clash\"); }\n      checkClashes[expr.name] = true;\n    }\n    if (bindingType && bindingType !== \"none\") {\n      if (\n        bindingType === \"var\" && !this.canDeclareVarName(expr.name) ||\n        bindingType !== \"var\" && !this.canDeclareLexicalName(expr.name)\n      ) {\n        this.raiseRecoverable(expr.start, (\"Identifier '\" + (expr.name) + \"' has already been declared\"));\n      }\n      if (bindingType === \"var\") {\n        this.declareVarName(expr.name);\n      } else {\n        this.declareLexicalName(expr.name);\n      }\n    }\n    break\n\n  case \"MemberExpression\":\n    if (bindingType) { this.raiseRecoverable(expr.start, \"Binding member expression\"); }\n    break\n\n  case \"ObjectPattern\":\n    for (var i = 0, list = expr.properties; i < list.length; i += 1)\n      {\n    var prop = list[i];\n\n    this$1.checkLVal(prop, bindingType, checkClashes);\n  }\n    break\n\n  case \"Property\":\n    // AssignmentProperty has type === \"Property\"\n    this.checkLVal(expr.value, bindingType, checkClashes);\n    break\n\n  case \"ArrayPattern\":\n    for (var i$1 = 0, list$1 = expr.elements; i$1 < list$1.length; i$1 += 1) {\n      var elem = list$1[i$1];\n\n    if (elem) { this$1.checkLVal(elem, bindingType, checkClashes); }\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, bindingType, checkClashes);\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, bindingType, checkClashes);\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, bindingType, checkClashes);\n    break\n\n  default:\n    this.raise(expr.start, (bindingType ? \"Binding\" : \"Assigning to\") + \" rvalue\");\n  }\n};\n\n// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nvar pp$3 = Parser.prototype;\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp$3.checkPropClash = function(prop, propHash, refDestructuringErrors) {\n  if (this.options.ecmaVersion >= 9 && prop.type === \"SpreadElement\")\n    { return }\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    { return }\n  var key = prop.key;\n  var name;\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  var kind = prop.kind;\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) {\n        if (refDestructuringErrors && refDestructuringErrors.doubleProto < 0) { refDestructuringErrors.doubleProto = key.start; }\n        // Backwards-compat kludge. Can be removed in version 6.0\n        else { this.raiseRecoverable(key.start, \"Redefinition of __proto__ property\"); }\n      }\n      propHash.proto = true;\n    }\n    return\n  }\n  name = \"$\" + name;\n  var other = propHash[name];\n  if (other) {\n    var redefinition;\n    if (kind === \"init\") {\n      redefinition = this.strict && other.init || other.get || other.set;\n    } else {\n      redefinition = other.init || other[kind];\n    }\n    if (redefinition)\n      { this.raiseRecoverable(key.start, \"Redefinition of property\"); }\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    };\n  }\n  other[kind] = true;\n};\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp$3.parseExpression = function(noIn, refDestructuringErrors) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeAssign(noIn, refDestructuringErrors);\n  if (this.type === types.comma) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.expressions = [expr];\n    while (this.eat(types.comma)) { node.expressions.push(this$1.parseMaybeAssign(noIn, refDestructuringErrors)); }\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n};\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp$3.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.inGenerator && this.isContextual(\"yield\")) { return this.parseYield() }\n\n  var ownDestructuringErrors = false, oldParenAssign = -1, oldTrailingComma = -1;\n  if (refDestructuringErrors) {\n    oldParenAssign = refDestructuringErrors.parenthesizedAssign;\n    oldTrailingComma = refDestructuringErrors.trailingComma;\n    refDestructuringErrors.parenthesizedAssign = refDestructuringErrors.trailingComma = -1;\n  } else {\n    refDestructuringErrors = new DestructuringErrors;\n    ownDestructuringErrors = true;\n  }\n\n  var startPos = this.start, startLoc = this.startLoc;\n  if (this.type === types.parenL || this.type === types.name)\n    { this.potentialArrowAt = this.start; }\n  var left = this.parseMaybeConditional(noIn, refDestructuringErrors);\n  if (afterLeftParse) { left = afterLeftParse.call(this, left, startPos, startLoc); }\n  if (this.type.isAssign) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.operator = this.value;\n    node.left = this.type === types.eq ? this.toAssignable(left, false, refDestructuringErrors) : left;\n    if (!ownDestructuringErrors) { DestructuringErrors.call(refDestructuringErrors); }\n    refDestructuringErrors.shorthandAssign = -1; // reset because shorthand default was used correctly\n    this.checkLVal(left);\n    this.next();\n    node.right = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (ownDestructuringErrors) { this.checkExpressionErrors(refDestructuringErrors, true); }\n  }\n  if (oldParenAssign > -1) { refDestructuringErrors.parenthesizedAssign = oldParenAssign; }\n  if (oldTrailingComma > -1) { refDestructuringErrors.trailingComma = oldTrailingComma; }\n  return left\n};\n\n// Parse a ternary conditional (`?:`) operator.\n\npp$3.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprOps(noIn, refDestructuringErrors);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  if (this.eat(types.question)) {\n    var node = this.startNodeAt(startPos, startLoc);\n    node.test = expr;\n    node.consequent = this.parseMaybeAssign();\n    this.expect(types.colon);\n    node.alternate = this.parseMaybeAssign(noIn);\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n};\n\n// Start the precedence parser.\n\npp$3.parseExprOps = function(noIn, refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseMaybeUnary(refDestructuringErrors, false);\n  if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n  return expr.start === startPos && expr.type === \"ArrowFunctionExpression\" ? expr : this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n};\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp$3.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  var prec = this.type.binop;\n  if (prec != null && (!noIn || this.type !== types._in)) {\n    if (prec > minPrec) {\n      var logical = this.type === types.logicalOR || this.type === types.logicalAND;\n      var op = this.value;\n      this.next();\n      var startPos = this.start, startLoc = this.startLoc;\n      var right = this.parseExprOp(this.parseMaybeUnary(null, false), startPos, startLoc, prec, noIn);\n      var node = this.buildBinary(leftStartPos, leftStartLoc, left, right, op, logical);\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n};\n\npp$3.buildBinary = function(startPos, startLoc, left, right, op, logical) {\n  var node = this.startNodeAt(startPos, startLoc);\n  node.left = left;\n  node.operator = op;\n  node.right = right;\n  return this.finishNode(node, logical ? \"LogicalExpression\" : \"BinaryExpression\")\n};\n\n// Parse unary operators, both prefix and postfix.\n\npp$3.parseMaybeUnary = function(refDestructuringErrors, sawUnary) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, expr;\n  if (this.isContextual(\"await\") && (this.inAsync || (!this.inFunction && this.options.allowAwaitOutsideFunction))) {\n    expr = this.parseAwait();\n    sawUnary = true;\n  } else if (this.type.prefix) {\n    var node = this.startNode(), update = this.type === types.incDec;\n    node.operator = this.value;\n    node.prefix = true;\n    this.next();\n    node.argument = this.parseMaybeUnary(null, true);\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    if (update) { this.checkLVal(node.argument); }\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      { this.raiseRecoverable(node.start, \"Deleting local variable in strict mode\"); }\n    else { sawUnary = true; }\n    expr = this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\");\n  } else {\n    expr = this.parseExprSubscripts(refDestructuringErrors);\n    if (this.checkExpressionErrors(refDestructuringErrors)) { return expr }\n    while (this.type.postfix && !this.canInsertSemicolon()) {\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.operator = this$1.value;\n      node$1.prefix = false;\n      node$1.argument = expr;\n      this$1.checkLVal(expr);\n      this$1.next();\n      expr = this$1.finishNode(node$1, \"UpdateExpression\");\n    }\n  }\n\n  if (!sawUnary && this.eat(types.starstar))\n    { return this.buildBinary(startPos, startLoc, expr, this.parseMaybeUnary(null, false), \"**\", false) }\n  else\n    { return expr }\n};\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp$3.parseExprSubscripts = function(refDestructuringErrors) {\n  var startPos = this.start, startLoc = this.startLoc;\n  var expr = this.parseExprAtom(refDestructuringErrors);\n  var skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) { return expr }\n  var result = this.parseSubscripts(expr, startPos, startLoc);\n  if (refDestructuringErrors && result.type === \"MemberExpression\") {\n    if (refDestructuringErrors.parenthesizedAssign >= result.start) { refDestructuringErrors.parenthesizedAssign = -1; }\n    if (refDestructuringErrors.parenthesizedBind >= result.start) { refDestructuringErrors.parenthesizedBind = -1; }\n  }\n  return result\n};\n\npp$3.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  var this$1 = this;\n\n  var maybeAsyncArrow = this.options.ecmaVersion >= 8 && base.type === \"Identifier\" && base.name === \"async\" &&\n      this.lastTokEnd === base.end && !this.canInsertSemicolon() && this.input.slice(base.start, base.end) === \"async\";\n  for (var computed = (void 0);;) {\n    if ((computed = this$1.eat(types.bracketL)) || this$1.eat(types.dot)) {\n      var node = this$1.startNodeAt(startPos, startLoc);\n      node.object = base;\n      node.property = computed ? this$1.parseExpression() : this$1.parseIdent(true);\n      node.computed = !!computed;\n      if (computed) { this$1.expect(types.bracketR); }\n      base = this$1.finishNode(node, \"MemberExpression\");\n    } else if (!noCalls && this$1.eat(types.parenL)) {\n      var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this$1.yieldPos, oldAwaitPos = this$1.awaitPos;\n      this$1.yieldPos = 0;\n      this$1.awaitPos = 0;\n      var exprList = this$1.parseExprList(types.parenR, this$1.options.ecmaVersion >= 8, false, refDestructuringErrors);\n      if (maybeAsyncArrow && !this$1.canInsertSemicolon() && this$1.eat(types.arrow)) {\n        this$1.checkPatternErrors(refDestructuringErrors, false);\n        this$1.checkYieldAwaitInDefaultParams();\n        this$1.yieldPos = oldYieldPos;\n        this$1.awaitPos = oldAwaitPos;\n        return this$1.parseArrowExpression(this$1.startNodeAt(startPos, startLoc), exprList, true)\n      }\n      this$1.checkExpressionErrors(refDestructuringErrors, true);\n      this$1.yieldPos = oldYieldPos || this$1.yieldPos;\n      this$1.awaitPos = oldAwaitPos || this$1.awaitPos;\n      var node$1 = this$1.startNodeAt(startPos, startLoc);\n      node$1.callee = base;\n      node$1.arguments = exprList;\n      base = this$1.finishNode(node$1, \"CallExpression\");\n    } else if (this$1.type === types.backQuote) {\n      var node$2 = this$1.startNodeAt(startPos, startLoc);\n      node$2.tag = base;\n      node$2.quasi = this$1.parseTemplate({isTagged: true});\n      base = this$1.finishNode(node$2, \"TaggedTemplateExpression\");\n    } else {\n      return base\n    }\n  }\n};\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp$3.parseExprAtom = function(refDestructuringErrors) {\n  var node, canBeArrow = this.potentialArrowAt === this.start;\n  switch (this.type) {\n  case types._super:\n    if (!this.inFunction)\n      { this.raise(this.start, \"'super' outside of function or class\"); }\n    node = this.startNode();\n    this.next();\n    // The `super` keyword can appear at below:\n    // SuperProperty:\n    //     super [ Expression ]\n    //     super . IdentifierName\n    // SuperCall:\n    //     super Arguments\n    if (this.type !== types.dot && this.type !== types.bracketL && this.type !== types.parenL)\n      { this.unexpected(); }\n    return this.finishNode(node, \"Super\")\n\n  case types._this:\n    node = this.startNode();\n    this.next();\n    return this.finishNode(node, \"ThisExpression\")\n\n  case types.name:\n    var startPos = this.start, startLoc = this.startLoc, containsEsc = this.containsEsc;\n    var id = this.parseIdent(this.type !== types.name);\n    if (this.options.ecmaVersion >= 8 && !containsEsc && id.name === \"async\" && !this.canInsertSemicolon() && this.eat(types._function))\n      { return this.parseFunction(this.startNodeAt(startPos, startLoc), false, false, true) }\n    if (canBeArrow && !this.canInsertSemicolon()) {\n      if (this.eat(types.arrow))\n        { return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], false) }\n      if (this.options.ecmaVersion >= 8 && id.name === \"async\" && this.type === types.name && !containsEsc) {\n        id = this.parseIdent();\n        if (this.canInsertSemicolon() || !this.eat(types.arrow))\n          { this.unexpected(); }\n        return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id], true)\n      }\n    }\n    return id\n\n  case types.regexp:\n    var value = this.value;\n    node = this.parseLiteral(value.value);\n    node.regex = {pattern: value.pattern, flags: value.flags};\n    return node\n\n  case types.num: case types.string:\n    return this.parseLiteral(this.value)\n\n  case types._null: case types._true: case types._false:\n    node = this.startNode();\n    node.value = this.type === types._null ? null : this.type === types._true;\n    node.raw = this.type.keyword;\n    this.next();\n    return this.finishNode(node, \"Literal\")\n\n  case types.parenL:\n    var start = this.start, expr = this.parseParenAndDistinguishExpression(canBeArrow);\n    if (refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(expr))\n        { refDestructuringErrors.parenthesizedAssign = start; }\n      if (refDestructuringErrors.parenthesizedBind < 0)\n        { refDestructuringErrors.parenthesizedBind = start; }\n    }\n    return expr\n\n  case types.bracketL:\n    node = this.startNode();\n    this.next();\n    node.elements = this.parseExprList(types.bracketR, true, true, refDestructuringErrors);\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case types.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case types._function:\n    node = this.startNode();\n    this.next();\n    return this.parseFunction(node, false)\n\n  case types._class:\n    return this.parseClass(this.startNode(), false)\n\n  case types._new:\n    return this.parseNew()\n\n  case types.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected();\n  }\n};\n\npp$3.parseLiteral = function(value) {\n  var node = this.startNode();\n  node.value = value;\n  node.raw = this.input.slice(this.start, this.end);\n  this.next();\n  return this.finishNode(node, \"Literal\")\n};\n\npp$3.parseParenExpression = function() {\n  this.expect(types.parenL);\n  var val = this.parseExpression();\n  this.expect(types.parenR);\n  return val\n};\n\npp$3.parseParenAndDistinguishExpression = function(canBeArrow) {\n  var this$1 = this;\n\n  var startPos = this.start, startLoc = this.startLoc, val, allowTrailingComma = this.options.ecmaVersion >= 8;\n  if (this.options.ecmaVersion >= 6) {\n    this.next();\n\n    var innerStartPos = this.start, innerStartLoc = this.startLoc;\n    var exprList = [], first = true, lastIsComma = false;\n    var refDestructuringErrors = new DestructuringErrors, oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, spreadStart;\n    this.yieldPos = 0;\n    this.awaitPos = 0;\n    while (this.type !== types.parenR) {\n      first ? first = false : this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(types.parenR, true)) {\n        lastIsComma = true;\n        break\n      } else if (this$1.type === types.ellipsis) {\n        spreadStart = this$1.start;\n        exprList.push(this$1.parseParenItem(this$1.parseRestBinding()));\n        if (this$1.type === types.comma) { this$1.raise(this$1.start, \"Comma is not permitted after the rest element\"); }\n        break\n      } else {\n        exprList.push(this$1.parseMaybeAssign(false, refDestructuringErrors, this$1.parseParenItem));\n      }\n    }\n    var innerEndPos = this.start, innerEndLoc = this.startLoc;\n    this.expect(types.parenR);\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(types.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, false);\n      this.checkYieldAwaitInDefaultParams();\n      this.yieldPos = oldYieldPos;\n      this.awaitPos = oldAwaitPos;\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length || lastIsComma) { this.unexpected(this.lastTokStart); }\n    if (spreadStart) { this.unexpected(spreadStart); }\n    this.checkExpressionErrors(refDestructuringErrors, true);\n    this.yieldPos = oldYieldPos || this.yieldPos;\n    this.awaitPos = oldAwaitPos || this.awaitPos;\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc);\n      val.expressions = exprList;\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc);\n    } else {\n      val = exprList[0];\n    }\n  } else {\n    val = this.parseParenExpression();\n  }\n\n  if (this.options.preserveParens) {\n    var par = this.startNodeAt(startPos, startLoc);\n    par.expression = val;\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n};\n\npp$3.parseParenItem = function(item) {\n  return item\n};\n\npp$3.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n};\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nvar empty$1 = [];\n\npp$3.parseNew = function() {\n  var node = this.startNode();\n  var meta = this.parseIdent(true);\n  if (this.options.ecmaVersion >= 6 && this.eat(types.dot)) {\n    node.meta = meta;\n    var containsEsc = this.containsEsc;\n    node.property = this.parseIdent(true);\n    if (node.property.name !== \"target\" || containsEsc)\n      { this.raiseRecoverable(node.property.start, \"The only valid meta property for new is new.target\"); }\n    if (!this.inFunction)\n      { this.raiseRecoverable(node.start, \"new.target can only be used in functions\"); }\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  var startPos = this.start, startLoc = this.startLoc;\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true);\n  if (this.eat(types.parenL)) { node.arguments = this.parseExprList(types.parenR, this.options.ecmaVersion >= 8, false); }\n  else { node.arguments = empty$1; }\n  return this.finishNode(node, \"NewExpression\")\n};\n\n// Parse template expression.\n\npp$3.parseTemplateElement = function(ref) {\n  var isTagged = ref.isTagged;\n\n  var elem = this.startNode();\n  if (this.type === types.invalidTemplate) {\n    if (!isTagged) {\n      this.raiseRecoverable(this.start, \"Bad escape sequence in untagged template literal\");\n    }\n    elem.value = {\n      raw: this.value,\n      cooked: null\n    };\n  } else {\n    elem.value = {\n      raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, \"\\n\"),\n      cooked: this.value\n    };\n  }\n  this.next();\n  elem.tail = this.type === types.backQuote;\n  return this.finishNode(elem, \"TemplateElement\")\n};\n\npp$3.parseTemplate = function(ref) {\n  var this$1 = this;\n  if ( ref === void 0 ) ref = {};\n  var isTagged = ref.isTagged; if ( isTagged === void 0 ) isTagged = false;\n\n  var node = this.startNode();\n  this.next();\n  node.expressions = [];\n  var curElt = this.parseTemplateElement({isTagged: isTagged});\n  node.quasis = [curElt];\n  while (!curElt.tail) {\n    if (this$1.type === types.eof) { this$1.raise(this$1.pos, \"Unterminated template literal\"); }\n    this$1.expect(types.dollarBraceL);\n    node.expressions.push(this$1.parseExpression());\n    this$1.expect(types.braceR);\n    node.quasis.push(curElt = this$1.parseTemplateElement({isTagged: isTagged}));\n  }\n  this.next();\n  return this.finishNode(node, \"TemplateLiteral\")\n};\n\npp$3.isAsyncProp = function(prop) {\n  return !prop.computed && prop.key.type === \"Identifier\" && prop.key.name === \"async\" &&\n    (this.type === types.name || this.type === types.num || this.type === types.string || this.type === types.bracketL || this.type.keyword || (this.options.ecmaVersion >= 9 && this.type === types.star)) &&\n    !lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n};\n\n// Parse an object literal or binding pattern.\n\npp$3.parseObj = function(isPattern, refDestructuringErrors) {\n  var this$1 = this;\n\n  var node = this.startNode(), first = true, propHash = {};\n  node.properties = [];\n  this.next();\n  while (!this.eat(types.braceR)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (this$1.afterTrailingComma(types.braceR)) { break }\n    } else { first = false; }\n\n    var prop = this$1.parseProperty(isPattern, refDestructuringErrors);\n    if (!isPattern) { this$1.checkPropClash(prop, propHash, refDestructuringErrors); }\n    node.properties.push(prop);\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n};\n\npp$3.parseProperty = function(isPattern, refDestructuringErrors) {\n  var prop = this.startNode(), isGenerator, isAsync, startPos, startLoc;\n  if (this.options.ecmaVersion >= 9 && this.eat(types.ellipsis)) {\n    if (isPattern) {\n      prop.argument = this.parseIdent(false);\n      if (this.type === types.comma) {\n        this.raise(this.start, \"Comma is not permitted after the rest element\");\n      }\n      return this.finishNode(prop, \"RestElement\")\n    }\n    // To disallow parenthesized identifier via `this.toAssignable()`.\n    if (this.type === types.parenL && refDestructuringErrors) {\n      if (refDestructuringErrors.parenthesizedAssign < 0) {\n        refDestructuringErrors.parenthesizedAssign = this.start;\n      }\n      if (refDestructuringErrors.parenthesizedBind < 0) {\n        refDestructuringErrors.parenthesizedBind = this.start;\n      }\n    }\n    // Parse argument.\n    prop.argument = this.parseMaybeAssign(false, refDestructuringErrors);\n    // To disallow trailing comma via `this.toAssignable()`.\n    if (this.type === types.comma && refDestructuringErrors && refDestructuringErrors.trailingComma < 0) {\n      refDestructuringErrors.trailingComma = this.start;\n    }\n    // Finish\n    return this.finishNode(prop, \"SpreadElement\")\n  }\n  if (this.options.ecmaVersion >= 6) {\n    prop.method = false;\n    prop.shorthand = false;\n    if (isPattern || refDestructuringErrors) {\n      startPos = this.start;\n      startLoc = this.startLoc;\n    }\n    if (!isPattern)\n      { isGenerator = this.eat(types.star); }\n  }\n  var containsEsc = this.containsEsc;\n  this.parsePropertyName(prop);\n  if (!isPattern && !containsEsc && this.options.ecmaVersion >= 8 && !isGenerator && this.isAsyncProp(prop)) {\n    isAsync = true;\n    isGenerator = this.options.ecmaVersion >= 9 && this.eat(types.star);\n    this.parsePropertyName(prop, refDestructuringErrors);\n  } else {\n    isAsync = false;\n  }\n  this.parsePropertyValue(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc);\n  return this.finishNode(prop, \"Property\")\n};\n\npp$3.parsePropertyValue = function(prop, isPattern, isGenerator, isAsync, startPos, startLoc, refDestructuringErrors, containsEsc) {\n  if ((isGenerator || isAsync) && this.type === types.colon)\n    { this.unexpected(); }\n\n  if (this.eat(types.colon)) {\n    prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors);\n    prop.kind = \"init\";\n  } else if (this.options.ecmaVersion >= 6 && this.type === types.parenL) {\n    if (isPattern) { this.unexpected(); }\n    prop.kind = \"init\";\n    prop.method = true;\n    prop.value = this.parseMethod(isGenerator, isAsync);\n  } else if (!isPattern && !containsEsc &&\n             this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n             (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n             (this.type !== types.comma && this.type !== types.braceR)) {\n    if (isGenerator || isAsync) { this.unexpected(); }\n    prop.kind = prop.key.name;\n    this.parsePropertyName(prop);\n    prop.value = this.parseMethod(false);\n    var paramCount = prop.kind === \"get\" ? 0 : 1;\n    if (prop.value.params.length !== paramCount) {\n      var start = prop.value.start;\n      if (prop.kind === \"get\")\n        { this.raiseRecoverable(start, \"getter should have no params\"); }\n      else\n        { this.raiseRecoverable(start, \"setter should have exactly one param\"); }\n    } else {\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        { this.raiseRecoverable(prop.value.params[0].start, \"Setter cannot use rest params\"); }\n    }\n  } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n    this.checkUnreserved(prop.key);\n    prop.kind = \"init\";\n    if (isPattern) {\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else if (this.type === types.eq && refDestructuringErrors) {\n      if (refDestructuringErrors.shorthandAssign < 0)\n        { refDestructuringErrors.shorthandAssign = this.start; }\n      prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key);\n    } else {\n      prop.value = prop.key;\n    }\n    prop.shorthand = true;\n  } else { this.unexpected(); }\n};\n\npp$3.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(types.bracketL)) {\n      prop.computed = true;\n      prop.key = this.parseMaybeAssign();\n      this.expect(types.bracketR);\n      return prop.key\n    } else {\n      prop.computed = false;\n    }\n  }\n  return prop.key = this.type === types.num || this.type === types.string ? this.parseExprAtom() : this.parseIdent(true)\n};\n\n// Initialize empty function node.\n\npp$3.initFunction = function(node) {\n  node.id = null;\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false;\n    node.expression = false;\n  }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = false; }\n};\n\n// Parse object or class method.\n\npp$3.parseMethod = function(isGenerator, isAsync) {\n  var node = this.startNode(), oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 6)\n    { node.generator = isGenerator; }\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = node.generator;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n  this.enterFunctionScope();\n\n  this.expect(types.parenL);\n  node.params = this.parseBindingList(types.parenR, false, this.options.ecmaVersion >= 8);\n  this.checkYieldAwaitInDefaultParams();\n  this.parseFunctionBody(node, false);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"FunctionExpression\")\n};\n\n// Parse arrow function expression with given parameters.\n\npp$3.parseArrowExpression = function(node, params, isAsync) {\n  var oldInGen = this.inGenerator, oldInAsync = this.inAsync,\n      oldYieldPos = this.yieldPos, oldAwaitPos = this.awaitPos, oldInFunc = this.inFunction;\n\n  this.enterFunctionScope();\n  this.initFunction(node);\n  if (this.options.ecmaVersion >= 8)\n    { node.async = !!isAsync; }\n\n  this.inGenerator = false;\n  this.inAsync = node.async;\n  this.yieldPos = 0;\n  this.awaitPos = 0;\n  this.inFunction = true;\n\n  node.params = this.toAssignableList(params, true);\n  this.parseFunctionBody(node, true);\n\n  this.inGenerator = oldInGen;\n  this.inAsync = oldInAsync;\n  this.yieldPos = oldYieldPos;\n  this.awaitPos = oldAwaitPos;\n  this.inFunction = oldInFunc;\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n};\n\n// Parse function body and check parameters.\n\npp$3.parseFunctionBody = function(node, isArrowFunction) {\n  var isExpression = isArrowFunction && this.type !== types.braceL;\n  var oldStrict = this.strict, useStrict = false;\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign();\n    node.expression = true;\n    this.checkParams(node, false);\n  } else {\n    var nonSimple = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(node.params);\n    if (!oldStrict || nonSimple) {\n      useStrict = this.strictDirective(this.end);\n      // If this is a strict mode function, verify that argument names\n      // are not repeated, and it does not try to bind the words `eval`\n      // or `arguments`.\n      if (useStrict && nonSimple)\n        { this.raiseRecoverable(node.start, \"Illegal 'use strict' directive in function with non-simple parameter list\"); }\n    }\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    var oldLabels = this.labels;\n    this.labels = [];\n    if (useStrict) { this.strict = true; }\n\n    // Add the params to varDeclaredNames to ensure that an error is thrown\n    // if a let/const declaration in the function clashes with one of the params.\n    this.checkParams(node, !oldStrict && !useStrict && !isArrowFunction && this.isSimpleParamList(node.params));\n    node.body = this.parseBlock(false);\n    node.expression = false;\n    this.adaptDirectivePrologue(node.body.body);\n    this.labels = oldLabels;\n  }\n  this.exitFunctionScope();\n\n  if (this.strict && node.id) {\n    // Ensure the function name isn't a forbidden identifier in strict mode, e.g. 'eval'\n    this.checkLVal(node.id, \"none\");\n  }\n  this.strict = oldStrict;\n};\n\npp$3.isSimpleParamList = function(params) {\n  for (var i = 0, list = params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    if (param.type !== \"Identifier\") { return false\n  } }\n  return true\n};\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp$3.checkParams = function(node, allowDuplicates) {\n  var this$1 = this;\n\n  var nameHash = {};\n  for (var i = 0, list = node.params; i < list.length; i += 1)\n    {\n    var param = list[i];\n\n    this$1.checkLVal(param, \"var\", allowDuplicates ? null : nameHash);\n  }\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp$3.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  var this$1 = this;\n\n  var elts = [], first = true;\n  while (!this.eat(close)) {\n    if (!first) {\n      this$1.expect(types.comma);\n      if (allowTrailingComma && this$1.afterTrailingComma(close)) { break }\n    } else { first = false; }\n\n    var elt = (void 0);\n    if (allowEmpty && this$1.type === types.comma)\n      { elt = null; }\n    else if (this$1.type === types.ellipsis) {\n      elt = this$1.parseSpread(refDestructuringErrors);\n      if (refDestructuringErrors && this$1.type === types.comma && refDestructuringErrors.trailingComma < 0)\n        { refDestructuringErrors.trailingComma = this$1.start; }\n    } else {\n      elt = this$1.parseMaybeAssign(false, refDestructuringErrors);\n    }\n    elts.push(elt);\n  }\n  return elts\n};\n\npp$3.checkUnreserved = function(ref) {\n  var start = ref.start;\n  var end = ref.end;\n  var name = ref.name;\n\n  if (this.inGenerator && name === \"yield\")\n    { this.raiseRecoverable(start, \"Can not use 'yield' as identifier inside a generator\"); }\n  if (this.inAsync && name === \"await\")\n    { this.raiseRecoverable(start, \"Can not use 'await' as identifier inside an async function\"); }\n  if (this.isKeyword(name))\n    { this.raise(start, (\"Unexpected keyword '\" + name + \"'\")); }\n  if (this.options.ecmaVersion < 6 &&\n    this.input.slice(start, end).indexOf(\"\\\\\") !== -1) { return }\n  var re = this.strict ? this.reservedWordsStrict : this.reservedWords;\n  if (re.test(name)) {\n    if (!this.inAsync && name === \"await\")\n      { this.raiseRecoverable(start, \"Can not use keyword 'await' outside an async function\"); }\n    this.raiseRecoverable(start, (\"The keyword '\" + name + \"' is reserved\"));\n  }\n};\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp$3.parseIdent = function(liberal, isBinding) {\n  var node = this.startNode();\n  if (liberal && this.options.allowReserved === \"never\") { liberal = false; }\n  if (this.type === types.name) {\n    node.name = this.value;\n  } else if (this.type.keyword) {\n    node.name = this.type.keyword;\n\n    // To fix https://github.com/acornjs/acorn/issues/575\n    // `class` and `function` keywords push new context into this.context.\n    // But there is no chance to pop the context if the keyword is consumed as an identifier such as a property name.\n    // If the previous token is a dot, this does not apply because the context-managing code already ignored the keyword\n    if ((node.name === \"class\" || node.name === \"function\") &&\n        (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46)) {\n      this.context.pop();\n    }\n  } else {\n    this.unexpected();\n  }\n  this.next();\n  this.finishNode(node, \"Identifier\");\n  if (!liberal) { this.checkUnreserved(node); }\n  return node\n};\n\n// Parses yield expression inside generator.\n\npp$3.parseYield = function() {\n  if (!this.yieldPos) { this.yieldPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  if (this.type === types.semi || this.canInsertSemicolon() || (this.type !== types.star && !this.type.startsExpr)) {\n    node.delegate = false;\n    node.argument = null;\n  } else {\n    node.delegate = this.eat(types.star);\n    node.argument = this.parseMaybeAssign();\n  }\n  return this.finishNode(node, \"YieldExpression\")\n};\n\npp$3.parseAwait = function() {\n  if (!this.awaitPos) { this.awaitPos = this.start; }\n\n  var node = this.startNode();\n  this.next();\n  node.argument = this.parseMaybeUnary(null, true);\n  return this.finishNode(node, \"AwaitExpression\")\n};\n\nvar pp$4 = Parser.prototype;\n\n// This function is used to raise exceptions on parse errors. It\n// takes an offset integer (into the current `input`) to indicate\n// the location of the error, attaches the position to the end\n// of the error message, and then raises a `SyntaxError` with that\n// message.\n\npp$4.raise = function(pos, message) {\n  var loc = getLineInfo(this.input, pos);\n  message += \" (\" + loc.line + \":\" + loc.column + \")\";\n  var err = new SyntaxError(message);\n  err.pos = pos; err.loc = loc; err.raisedAt = this.pos;\n  throw err\n};\n\npp$4.raiseRecoverable = pp$4.raise;\n\npp$4.curPosition = function() {\n  if (this.options.locations) {\n    return new Position(this.curLine, this.pos - this.lineStart)\n  }\n};\n\nvar pp$5 = Parser.prototype;\n\n// Object.assign polyfill\nvar assign = Object.assign || function(target) {\n  var sources = [], len = arguments.length - 1;\n  while ( len-- > 0 ) sources[ len ] = arguments[ len + 1 ];\n\n  for (var i = 0, list = sources; i < list.length; i += 1) {\n    var source = list[i];\n\n    for (var key in source) {\n      if (has(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target\n};\n\n// The functions in this module keep track of declared variables in the current scope in order to detect duplicate variable names.\n\npp$5.enterFunctionScope = function() {\n  // var: a hash of var-declared names in the current lexical scope\n  // lexical: a hash of lexically-declared names in the current lexical scope\n  // childVar: a hash of var-declared names in all child lexical scopes of the current lexical scope (within the current function scope)\n  // parentLexical: a hash of lexically-declared names in all parent lexical scopes of the current lexical scope (within the current function scope)\n  this.scopeStack.push({var: {}, lexical: {}, childVar: {}, parentLexical: {}});\n};\n\npp$5.exitFunctionScope = function() {\n  this.scopeStack.pop();\n};\n\npp$5.enterLexicalScope = function() {\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n  var childScope = {var: {}, lexical: {}, childVar: {}, parentLexical: {}};\n\n  this.scopeStack.push(childScope);\n  assign(childScope.parentLexical, parentScope.lexical, parentScope.parentLexical);\n};\n\npp$5.exitLexicalScope = function() {\n  var childScope = this.scopeStack.pop();\n  var parentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  assign(parentScope.childVar, childScope.var, childScope.childVar);\n};\n\n/**\n * A name can be declared with `var` if there are no variables with the same name declared with `let`/`const`\n * in the current lexical scope or any of the parent lexical scopes in this function.\n */\npp$5.canDeclareVarName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.parentLexical, name)\n};\n\n/**\n * A name can be declared with `let`/`const` if there are no variables with the same name declared with `let`/`const`\n * in the current scope, and there are no variables with the same name declared with `var` in the current scope or in\n * any child lexical scopes in this function.\n */\npp$5.canDeclareLexicalName = function(name) {\n  var currentScope = this.scopeStack[this.scopeStack.length - 1];\n\n  return !has(currentScope.lexical, name) && !has(currentScope.var, name) && !has(currentScope.childVar, name)\n};\n\npp$5.declareVarName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].var[name] = true;\n};\n\npp$5.declareLexicalName = function(name) {\n  this.scopeStack[this.scopeStack.length - 1].lexical[name] = true;\n};\n\nvar Node = function Node(parser, pos, loc) {\n  this.type = \"\";\n  this.start = pos;\n  this.end = 0;\n  if (parser.options.locations)\n    { this.loc = new SourceLocation(parser, loc); }\n  if (parser.options.directSourceFile)\n    { this.sourceFile = parser.options.directSourceFile; }\n  if (parser.options.ranges)\n    { this.range = [pos, 0]; }\n};\n\n// Start an AST node, attaching a start offset.\n\nvar pp$6 = Parser.prototype;\n\npp$6.startNode = function() {\n  return new Node(this, this.start, this.startLoc)\n};\n\npp$6.startNodeAt = function(pos, loc) {\n  return new Node(this, pos, loc)\n};\n\n// Finish an AST node, adding `type` and `end` properties.\n\nfunction finishNodeAt(node, type, pos, loc) {\n  node.type = type;\n  node.end = pos;\n  if (this.options.locations)\n    { node.loc.end = loc; }\n  if (this.options.ranges)\n    { node.range[1] = pos; }\n  return node\n}\n\npp$6.finishNode = function(node, type) {\n  return finishNodeAt.call(this, node, type, this.lastTokEnd, this.lastTokEndLoc)\n};\n\n// Finish node at given position\n\npp$6.finishNodeAt = function(node, type, pos, loc) {\n  return finishNodeAt.call(this, node, type, pos, loc)\n};\n\n// The algorithm used to determine whether a regexp can appear at a\n// given point in the program is loosely based on sweet.js' approach.\n// See https://github.com/mozilla/sweet.js/wiki/design\n\nvar TokContext = function TokContext(token, isExpr, preserveSpace, override, generator) {\n  this.token = token;\n  this.isExpr = !!isExpr;\n  this.preserveSpace = !!preserveSpace;\n  this.override = override;\n  this.generator = !!generator;\n};\n\nvar types$1 = {\n  b_stat: new TokContext(\"{\", false),\n  b_expr: new TokContext(\"{\", true),\n  b_tmpl: new TokContext(\"${\", false),\n  p_stat: new TokContext(\"(\", false),\n  p_expr: new TokContext(\"(\", true),\n  q_tmpl: new TokContext(\"`\", true, true, function (p) { return p.tryReadTemplateToken(); }),\n  f_stat: new TokContext(\"function\", false),\n  f_expr: new TokContext(\"function\", true),\n  f_expr_gen: new TokContext(\"function\", true, false, null, true),\n  f_gen: new TokContext(\"function\", false, false, null, true)\n};\n\nvar pp$7 = Parser.prototype;\n\npp$7.initialContext = function() {\n  return [types$1.b_stat]\n};\n\npp$7.braceIsBlock = function(prevType) {\n  var parent = this.curContext();\n  if (parent === types$1.f_expr || parent === types$1.f_stat)\n    { return true }\n  if (prevType === types.colon && (parent === types$1.b_stat || parent === types$1.b_expr))\n    { return !parent.isExpr }\n\n  // The check for `tt.name && exprAllowed` detects whether we are\n  // after a `yield` or `of` construct. See the `updateContext` for\n  // `tt.name`.\n  if (prevType === types._return || prevType === types.name && this.exprAllowed)\n    { return lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) }\n  if (prevType === types._else || prevType === types.semi || prevType === types.eof || prevType === types.parenR || prevType === types.arrow)\n    { return true }\n  if (prevType === types.braceL)\n    { return parent === types$1.b_stat }\n  if (prevType === types._var || prevType === types.name)\n    { return false }\n  return !this.exprAllowed\n};\n\npp$7.inGeneratorContext = function() {\n  var this$1 = this;\n\n  for (var i = this.context.length - 1; i >= 1; i--) {\n    var context = this$1.context[i];\n    if (context.token === \"function\")\n      { return context.generator }\n  }\n  return false\n};\n\npp$7.updateContext = function(prevType) {\n  var update, type = this.type;\n  if (type.keyword && prevType === types.dot)\n    { this.exprAllowed = false; }\n  else if (update = type.updateContext)\n    { update.call(this, prevType); }\n  else\n    { this.exprAllowed = type.beforeExpr; }\n};\n\n// Token-specific context update code\n\ntypes.parenR.updateContext = types.braceR.updateContext = function() {\n  if (this.context.length === 1) {\n    this.exprAllowed = true;\n    return\n  }\n  var out = this.context.pop();\n  if (out === types$1.b_stat && this.curContext().token === \"function\") {\n    out = this.context.pop();\n  }\n  this.exprAllowed = !out.isExpr;\n};\n\ntypes.braceL.updateContext = function(prevType) {\n  this.context.push(this.braceIsBlock(prevType) ? types$1.b_stat : types$1.b_expr);\n  this.exprAllowed = true;\n};\n\ntypes.dollarBraceL.updateContext = function() {\n  this.context.push(types$1.b_tmpl);\n  this.exprAllowed = true;\n};\n\ntypes.parenL.updateContext = function(prevType) {\n  var statementParens = prevType === types._if || prevType === types._for || prevType === types._with || prevType === types._while;\n  this.context.push(statementParens ? types$1.p_stat : types$1.p_expr);\n  this.exprAllowed = true;\n};\n\ntypes.incDec.updateContext = function() {\n  // tokExprAllowed stays unchanged\n};\n\ntypes._function.updateContext = types._class.updateContext = function(prevType) {\n  if (prevType.beforeExpr && prevType !== types.semi && prevType !== types._else &&\n      !((prevType === types.colon || prevType === types.braceL) && this.curContext() === types$1.b_stat))\n    { this.context.push(types$1.f_expr); }\n  else\n    { this.context.push(types$1.f_stat); }\n  this.exprAllowed = false;\n};\n\ntypes.backQuote.updateContext = function() {\n  if (this.curContext() === types$1.q_tmpl)\n    { this.context.pop(); }\n  else\n    { this.context.push(types$1.q_tmpl); }\n  this.exprAllowed = false;\n};\n\ntypes.star.updateContext = function(prevType) {\n  if (prevType === types._function) {\n    var index = this.context.length - 1;\n    if (this.context[index] === types$1.f_expr)\n      { this.context[index] = types$1.f_expr_gen; }\n    else\n      { this.context[index] = types$1.f_gen; }\n  }\n  this.exprAllowed = true;\n};\n\ntypes.name.updateContext = function(prevType) {\n  var allowed = false;\n  if (this.options.ecmaVersion >= 6 && prevType !== types.dot) {\n    if (this.value === \"of\" && !this.exprAllowed ||\n        this.value === \"yield\" && this.inGeneratorContext())\n      { allowed = true; }\n  }\n  this.exprAllowed = allowed;\n};\n\nvar data = {\n  \"$LONE\": [\n    \"ASCII\",\n    \"ASCII_Hex_Digit\",\n    \"AHex\",\n    \"Alphabetic\",\n    \"Alpha\",\n    \"Any\",\n    \"Assigned\",\n    \"Bidi_Control\",\n    \"Bidi_C\",\n    \"Bidi_Mirrored\",\n    \"Bidi_M\",\n    \"Case_Ignorable\",\n    \"CI\",\n    \"Cased\",\n    \"Changes_When_Casefolded\",\n    \"CWCF\",\n    \"Changes_When_Casemapped\",\n    \"CWCM\",\n    \"Changes_When_Lowercased\",\n    \"CWL\",\n    \"Changes_When_NFKC_Casefolded\",\n    \"CWKCF\",\n    \"Changes_When_Titlecased\",\n    \"CWT\",\n    \"Changes_When_Uppercased\",\n    \"CWU\",\n    \"Dash\",\n    \"Default_Ignorable_Code_Point\",\n    \"DI\",\n    \"Deprecated\",\n    \"Dep\",\n    \"Diacritic\",\n    \"Dia\",\n    \"Emoji\",\n    \"Emoji_Component\",\n    \"Emoji_Modifier\",\n    \"Emoji_Modifier_Base\",\n    \"Emoji_Presentation\",\n    \"Extender\",\n    \"Ext\",\n    \"Grapheme_Base\",\n    \"Gr_Base\",\n    \"Grapheme_Extend\",\n    \"Gr_Ext\",\n    \"Hex_Digit\",\n    \"Hex\",\n    \"IDS_Binary_Operator\",\n    \"IDSB\",\n    \"IDS_Trinary_Operator\",\n    \"IDST\",\n    \"ID_Continue\",\n    \"IDC\",\n    \"ID_Start\",\n    \"IDS\",\n    \"Ideographic\",\n    \"Ideo\",\n    \"Join_Control\",\n    \"Join_C\",\n    \"Logical_Order_Exception\",\n    \"LOE\",\n    \"Lowercase\",\n    \"Lower\",\n    \"Math\",\n    \"Noncharacter_Code_Point\",\n    \"NChar\",\n    \"Pattern_Syntax\",\n    \"Pat_Syn\",\n    \"Pattern_White_Space\",\n    \"Pat_WS\",\n    \"Quotation_Mark\",\n    \"QMark\",\n    \"Radical\",\n    \"Regional_Indicator\",\n    \"RI\",\n    \"Sentence_Terminal\",\n    \"STerm\",\n    \"Soft_Dotted\",\n    \"SD\",\n    \"Terminal_Punctuation\",\n    \"Term\",\n    \"Unified_Ideograph\",\n    \"UIdeo\",\n    \"Uppercase\",\n    \"Upper\",\n    \"Variation_Selector\",\n    \"VS\",\n    \"White_Space\",\n    \"space\",\n    \"XID_Continue\",\n    \"XIDC\",\n    \"XID_Start\",\n    \"XIDS\"\n  ],\n  \"General_Category\": [\n    \"Cased_Letter\",\n    \"LC\",\n    \"Close_Punctuation\",\n    \"Pe\",\n    \"Connector_Punctuation\",\n    \"Pc\",\n    \"Control\",\n    \"Cc\",\n    \"cntrl\",\n    \"Currency_Symbol\",\n    \"Sc\",\n    \"Dash_Punctuation\",\n    \"Pd\",\n    \"Decimal_Number\",\n    \"Nd\",\n    \"digit\",\n    \"Enclosing_Mark\",\n    \"Me\",\n    \"Final_Punctuation\",\n    \"Pf\",\n    \"Format\",\n    \"Cf\",\n    \"Initial_Punctuation\",\n    \"Pi\",\n    \"Letter\",\n    \"L\",\n    \"Letter_Number\",\n    \"Nl\",\n    \"Line_Separator\",\n    \"Zl\",\n    \"Lowercase_Letter\",\n    \"Ll\",\n    \"Mark\",\n    \"M\",\n    \"Combining_Mark\",\n    \"Math_Symbol\",\n    \"Sm\",\n    \"Modifier_Letter\",\n    \"Lm\",\n    \"Modifier_Symbol\",\n    \"Sk\",\n    \"Nonspacing_Mark\",\n    \"Mn\",\n    \"Number\",\n    \"N\",\n    \"Open_Punctuation\",\n    \"Ps\",\n    \"Other\",\n    \"C\",\n    \"Other_Letter\",\n    \"Lo\",\n    \"Other_Number\",\n    \"No\",\n    \"Other_Punctuation\",\n    \"Po\",\n    \"Other_Symbol\",\n    \"So\",\n    \"Paragraph_Separator\",\n    \"Zp\",\n    \"Private_Use\",\n    \"Co\",\n    \"Punctuation\",\n    \"P\",\n    \"punct\",\n    \"Separator\",\n    \"Z\",\n    \"Space_Separator\",\n    \"Zs\",\n    \"Spacing_Mark\",\n    \"Mc\",\n    \"Surrogate\",\n    \"Cs\",\n    \"Symbol\",\n    \"S\",\n    \"Titlecase_Letter\",\n    \"Lt\",\n    \"Unassigned\",\n    \"Cn\",\n    \"Uppercase_Letter\",\n    \"Lu\"\n  ],\n  \"Script\": [\n    \"Adlam\",\n    \"Adlm\",\n    \"Ahom\",\n    \"Anatolian_Hieroglyphs\",\n    \"Hluw\",\n    \"Arabic\",\n    \"Arab\",\n    \"Armenian\",\n    \"Armn\",\n    \"Avestan\",\n    \"Avst\",\n    \"Balinese\",\n    \"Bali\",\n    \"Bamum\",\n    \"Bamu\",\n    \"Bassa_Vah\",\n    \"Bass\",\n    \"Batak\",\n    \"Batk\",\n    \"Bengali\",\n    \"Beng\",\n    \"Bhaiksuki\",\n    \"Bhks\",\n    \"Bopomofo\",\n    \"Bopo\",\n    \"Brahmi\",\n    \"Brah\",\n    \"Braille\",\n    \"Brai\",\n    \"Buginese\",\n    \"Bugi\",\n    \"Buhid\",\n    \"Buhd\",\n    \"Canadian_Aboriginal\",\n    \"Cans\",\n    \"Carian\",\n    \"Cari\",\n    \"Caucasian_Albanian\",\n    \"Aghb\",\n    \"Chakma\",\n    \"Cakm\",\n    \"Cham\",\n    \"Cherokee\",\n    \"Cher\",\n    \"Common\",\n    \"Zyyy\",\n    \"Coptic\",\n    \"Copt\",\n    \"Qaac\",\n    \"Cuneiform\",\n    \"Xsux\",\n    \"Cypriot\",\n    \"Cprt\",\n    \"Cyrillic\",\n    \"Cyrl\",\n    \"Deseret\",\n    \"Dsrt\",\n    \"Devanagari\",\n    \"Deva\",\n    \"Duployan\",\n    \"Dupl\",\n    \"Egyptian_Hieroglyphs\",\n    \"Egyp\",\n    \"Elbasan\",\n    \"Elba\",\n    \"Ethiopic\",\n    \"Ethi\",\n    \"Georgian\",\n    \"Geor\",\n    \"Glagolitic\",\n    \"Glag\",\n    \"Gothic\",\n    \"Goth\",\n    \"Grantha\",\n    \"Gran\",\n    \"Greek\",\n    \"Grek\",\n    \"Gujarati\",\n    \"Gujr\",\n    \"Gurmukhi\",\n    \"Guru\",\n    \"Han\",\n    \"Hani\",\n    \"Hangul\",\n    \"Hang\",\n    \"Hanunoo\",\n    \"Hano\",\n    \"Hatran\",\n    \"Hatr\",\n    \"Hebrew\",\n    \"Hebr\",\n    \"Hiragana\",\n    \"Hira\",\n    \"Imperial_Aramaic\",\n    \"Armi\",\n    \"Inherited\",\n    \"Zinh\",\n    \"Qaai\",\n    \"Inscriptional_Pahlavi\",\n    \"Phli\",\n    \"Inscriptional_Parthian\",\n    \"Prti\",\n    \"Javanese\",\n    \"Java\",\n    \"Kaithi\",\n    \"Kthi\",\n    \"Kannada\",\n    \"Knda\",\n    \"Katakana\",\n    \"Kana\",\n    \"Kayah_Li\",\n    \"Kali\",\n    \"Kharoshthi\",\n    \"Khar\",\n    \"Khmer\",\n    \"Khmr\",\n    \"Khojki\",\n    \"Khoj\",\n    \"Khudawadi\",\n    \"Sind\",\n    \"Lao\",\n    \"Laoo\",\n    \"Latin\",\n    \"Latn\",\n    \"Lepcha\",\n    \"Lepc\",\n    \"Limbu\",\n    \"Limb\",\n    \"Linear_A\",\n    \"Lina\",\n    \"Linear_B\",\n    \"Linb\",\n    \"Lisu\",\n    \"Lycian\",\n    \"Lyci\",\n    \"Lydian\",\n    \"Lydi\",\n    \"Mahajani\",\n    \"Mahj\",\n    \"Malayalam\",\n    \"Mlym\",\n    \"Mandaic\",\n    \"Mand\",\n    \"Manichaean\",\n    \"Mani\",\n    \"Marchen\",\n    \"Marc\",\n    \"Masaram_Gondi\",\n    \"Gonm\",\n    \"Meetei_Mayek\",\n    \"Mtei\",\n    \"Mende_Kikakui\",\n    \"Mend\",\n    \"Meroitic_Cursive\",\n    \"Merc\",\n    \"Meroitic_Hieroglyphs\",\n    \"Mero\",\n    \"Miao\",\n    \"Plrd\",\n    \"Modi\",\n    \"Mongolian\",\n    \"Mong\",\n    \"Mro\",\n    \"Mroo\",\n    \"Multani\",\n    \"Mult\",\n    \"Myanmar\",\n    \"Mymr\",\n    \"Nabataean\",\n    \"Nbat\",\n    \"New_Tai_Lue\",\n    \"Talu\",\n    \"Newa\",\n    \"Nko\",\n    \"Nkoo\",\n    \"Nushu\",\n    \"Nshu\",\n    \"Ogham\",\n    \"Ogam\",\n    \"Ol_Chiki\",\n    \"Olck\",\n    \"Old_Hungarian\",\n    \"Hung\",\n    \"Old_Italic\",\n    \"Ital\",\n    \"Old_North_Arabian\",\n    \"Narb\",\n    \"Old_Permic\",\n    \"Perm\",\n    \"Old_Persian\",\n    \"Xpeo\",\n    \"Old_South_Arabian\",\n    \"Sarb\",\n    \"Old_Turkic\",\n    \"Orkh\",\n    \"Oriya\",\n    \"Orya\",\n    \"Osage\",\n    \"Osge\",\n    \"Osmanya\",\n    \"Osma\",\n    \"Pahawh_Hmong\",\n    \"Hmng\",\n    \"Palmyrene\",\n    \"Palm\",\n    \"Pau_Cin_Hau\",\n    \"Pauc\",\n    \"Phags_Pa\",\n    \"Phag\",\n    \"Phoenician\",\n    \"Phnx\",\n    \"Psalter_Pahlavi\",\n    \"Phlp\",\n    \"Rejang\",\n    \"Rjng\",\n    \"Runic\",\n    \"Runr\",\n    \"Samaritan\",\n    \"Samr\",\n    \"Saurashtra\",\n    \"Saur\",\n    \"Sharada\",\n    \"Shrd\",\n    \"Shavian\",\n    \"Shaw\",\n    \"Siddham\",\n    \"Sidd\",\n    \"SignWriting\",\n    \"Sgnw\",\n    \"Sinhala\",\n    \"Sinh\",\n    \"Sora_Sompeng\",\n    \"Sora\",\n    \"Soyombo\",\n    \"Soyo\",\n    \"Sundanese\",\n    \"Sund\",\n    \"Syloti_Nagri\",\n    \"Sylo\",\n    \"Syriac\",\n    \"Syrc\",\n    \"Tagalog\",\n    \"Tglg\",\n    \"Tagbanwa\",\n    \"Tagb\",\n    \"Tai_Le\",\n    \"Tale\",\n    \"Tai_Tham\",\n    \"Lana\",\n    \"Tai_Viet\",\n    \"Tavt\",\n    \"Takri\",\n    \"Takr\",\n    \"Tamil\",\n    \"Taml\",\n    \"Tangut\",\n    \"Tang\",\n    \"Telugu\",\n    \"Telu\",\n    \"Thaana\",\n    \"Thaa\",\n    \"Thai\",\n    \"Tibetan\",\n    \"Tibt\",\n    \"Tifinagh\",\n    \"Tfng\",\n    \"Tirhuta\",\n    \"Tirh\",\n    \"Ugaritic\",\n    \"Ugar\",\n    \"Vai\",\n    \"Vaii\",\n    \"Warang_Citi\",\n    \"Wara\",\n    \"Yi\",\n    \"Yiii\",\n    \"Zanabazar_Square\",\n    \"Zanb\"\n  ]\n};\nArray.prototype.push.apply(data.$LONE, data.General_Category);\ndata.gc = data.General_Category;\ndata.sc = data.Script_Extensions = data.scx = data.Script;\n\nvar pp$9 = Parser.prototype;\n\nvar RegExpValidationState = function RegExpValidationState(parser) {\n  this.parser = parser;\n  this.validFlags = \"gim\" + (parser.options.ecmaVersion >= 6 ? \"uy\" : \"\") + (parser.options.ecmaVersion >= 9 ? \"s\" : \"\");\n  this.source = \"\";\n  this.flags = \"\";\n  this.start = 0;\n  this.switchU = false;\n  this.switchN = false;\n  this.pos = 0;\n  this.lastIntValue = 0;\n  this.lastStringValue = \"\";\n  this.lastAssertionIsQuantifiable = false;\n  this.numCapturingParens = 0;\n  this.maxBackReference = 0;\n  this.groupNames = [];\n  this.backReferenceNames = [];\n};\n\nRegExpValidationState.prototype.reset = function reset (start, pattern, flags) {\n  var unicode = flags.indexOf(\"u\") !== -1;\n  this.start = start | 0;\n  this.source = pattern + \"\";\n  this.flags = flags;\n  this.switchU = unicode && this.parser.options.ecmaVersion >= 6;\n  this.switchN = unicode && this.parser.options.ecmaVersion >= 9;\n};\n\nRegExpValidationState.prototype.raise = function raise (message) {\n  this.parser.raiseRecoverable(this.start, (\"Invalid regular expression: /\" + (this.source) + \"/: \" + message));\n};\n\n// If u flag is given, this returns the code point at the index (it combines a surrogate pair).\n// Otherwise, this returns the code unit of the index (can be a part of a surrogate pair).\nRegExpValidationState.prototype.at = function at (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return -1\n  }\n  var c = s.charCodeAt(i);\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l) {\n    return c\n  }\n  var next = s.charCodeAt(i + 1);\n  return next >= 0xDC00 && next <= 0xDFFF ? (c << 10) + next - 0x35FDC00 : c\n};\n\nRegExpValidationState.prototype.nextIndex = function nextIndex (i) {\n  var s = this.source;\n  var l = s.length;\n  if (i >= l) {\n    return l\n  }\n  var c = s.charCodeAt(i), next;\n  if (!this.switchU || c <= 0xD7FF || c >= 0xE000 || i + 1 >= l ||\n      (next = s.charCodeAt(i + 1)) < 0xDC00 || next > 0xDFFF) {\n    return i + 1\n  }\n  return i + 2\n};\n\nRegExpValidationState.prototype.current = function current () {\n  return this.at(this.pos)\n};\n\nRegExpValidationState.prototype.lookahead = function lookahead () {\n  return this.at(this.nextIndex(this.pos))\n};\n\nRegExpValidationState.prototype.advance = function advance () {\n  this.pos = this.nextIndex(this.pos);\n};\n\nRegExpValidationState.prototype.eat = function eat (ch) {\n  if (this.current() === ch) {\n    this.advance();\n    return true\n  }\n  return false\n};\n\nfunction codePointToString$1(ch) {\n  if (ch <= 0xFFFF) { return String.fromCharCode(ch) }\n  ch -= 0x10000;\n  return String.fromCharCode((ch >> 10) + 0xD800, (ch & 0x03FF) + 0xDC00)\n}\n\n/**\n * Validate the flags part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpFlags = function(state) {\n  var this$1 = this;\n\n  var validFlags = state.validFlags;\n  var flags = state.flags;\n\n  for (var i = 0; i < flags.length; i++) {\n    var flag = flags.charAt(i);\n    if (validFlags.indexOf(flag) === -1) {\n      this$1.raise(state.start, \"Invalid regular expression flag\");\n    }\n    if (flags.indexOf(flag, i + 1) > -1) {\n      this$1.raise(state.start, \"Duplicate regular expression flag\");\n    }\n  }\n};\n\n/**\n * Validate the pattern part of a given RegExpLiteral.\n *\n * @param {RegExpValidationState} state The state to validate RegExp.\n * @returns {void}\n */\npp$9.validateRegExpPattern = function(state) {\n  this.regexp_pattern(state);\n\n  // The goal symbol for the parse is |Pattern[~U, ~N]|. If the result of\n  // parsing contains a |GroupName|, reparse with the goal symbol\n  // |Pattern[~U, +N]| and use this result instead. Throw a *SyntaxError*\n  // exception if _P_ did not conform to the grammar, if any elements of _P_\n  // were not matched by the parse, or if any Early Error conditions exist.\n  if (!state.switchN && this.options.ecmaVersion >= 9 && state.groupNames.length > 0) {\n    state.switchN = true;\n    this.regexp_pattern(state);\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Pattern\npp$9.regexp_pattern = function(state) {\n  state.pos = 0;\n  state.lastIntValue = 0;\n  state.lastStringValue = \"\";\n  state.lastAssertionIsQuantifiable = false;\n  state.numCapturingParens = 0;\n  state.maxBackReference = 0;\n  state.groupNames.length = 0;\n  state.backReferenceNames.length = 0;\n\n  this.regexp_disjunction(state);\n\n  if (state.pos !== state.source.length) {\n    // Make the same messages as V8.\n    if (state.eat(0x29 /* ) */)) {\n      state.raise(\"Unmatched ')'\");\n    }\n    if (state.eat(0x5D /* [ */) || state.eat(0x7D /* } */)) {\n      state.raise(\"Lone quantifier brackets\");\n    }\n  }\n  if (state.maxBackReference > state.numCapturingParens) {\n    state.raise(\"Invalid escape\");\n  }\n  for (var i = 0, list = state.backReferenceNames; i < list.length; i += 1) {\n    var name = list[i];\n\n    if (state.groupNames.indexOf(name) === -1) {\n      state.raise(\"Invalid named capture referenced\");\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Disjunction\npp$9.regexp_disjunction = function(state) {\n  var this$1 = this;\n\n  this.regexp_alternative(state);\n  while (state.eat(0x7C /* | */)) {\n    this$1.regexp_alternative(state);\n  }\n\n  // Make the same message as V8.\n  if (this.regexp_eatQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  if (state.eat(0x7B /* { */)) {\n    state.raise(\"Lone quantifier brackets\");\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Alternative\npp$9.regexp_alternative = function(state) {\n  while (state.pos < state.source.length && this.regexp_eatTerm(state))\n    {  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Term\npp$9.regexp_eatTerm = function(state) {\n  if (this.regexp_eatAssertion(state)) {\n    // Handle `QuantifiableAssertion Quantifier` alternative.\n    // `state.lastAssertionIsQuantifiable` is true if the last eaten Assertion\n    // is a QuantifiableAssertion.\n    if (state.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(state)) {\n      // Make the same message as V8.\n      if (state.switchU) {\n        state.raise(\"Invalid quantifier\");\n      }\n    }\n    return true\n  }\n\n  if (state.switchU ? this.regexp_eatAtom(state) : this.regexp_eatExtendedAtom(state)) {\n    this.regexp_eatQuantifier(state);\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-Assertion\npp$9.regexp_eatAssertion = function(state) {\n  var start = state.pos;\n  state.lastAssertionIsQuantifiable = false;\n\n  // ^, $\n  if (state.eat(0x5E /* ^ */) || state.eat(0x24 /* $ */)) {\n    return true\n  }\n\n  // \\b \\B\n  if (state.eat(0x5C /* \\ */)) {\n    if (state.eat(0x42 /* B */) || state.eat(0x62 /* b */)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  // Lookahead / Lookbehind\n  if (state.eat(0x28 /* ( */) && state.eat(0x3F /* ? */)) {\n    var lookbehind = false;\n    if (this.options.ecmaVersion >= 9) {\n      lookbehind = state.eat(0x3C /* < */);\n    }\n    if (state.eat(0x3D /* = */) || state.eat(0x21 /* ! */)) {\n      this.regexp_disjunction(state);\n      if (!state.eat(0x29 /* ) */)) {\n        state.raise(\"Unterminated group\");\n      }\n      state.lastAssertionIsQuantifiable = !lookbehind;\n      return true\n    }\n  }\n\n  state.pos = start;\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Quantifier\npp$9.regexp_eatQuantifier = function(state, noError) {\n  if ( noError === void 0 ) noError = false;\n\n  if (this.regexp_eatQuantifierPrefix(state, noError)) {\n    state.eat(0x3F /* ? */);\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-QuantifierPrefix\npp$9.regexp_eatQuantifierPrefix = function(state, noError) {\n  return (\n    state.eat(0x2A /* * */) ||\n    state.eat(0x2B /* + */) ||\n    state.eat(0x3F /* ? */) ||\n    this.regexp_eatBracedQuantifier(state, noError)\n  )\n};\npp$9.regexp_eatBracedQuantifier = function(state, noError) {\n  var start = state.pos;\n  if (state.eat(0x7B /* { */)) {\n    var min = 0, max = -1;\n    if (this.regexp_eatDecimalDigits(state)) {\n      min = state.lastIntValue;\n      if (state.eat(0x2C /* , */) && this.regexp_eatDecimalDigits(state)) {\n        max = state.lastIntValue;\n      }\n      if (state.eat(0x7D /* } */)) {\n        // SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-term\n        if (max !== -1 && max < min && !noError) {\n          state.raise(\"numbers out of order in {} quantifier\");\n        }\n        return true\n      }\n    }\n    if (state.switchU && !noError) {\n      state.raise(\"Incomplete quantifier\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Atom\npp$9.regexp_eatAtom = function(state) {\n  return (\n    this.regexp_eatPatternCharacters(state) ||\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state)\n  )\n};\npp$9.regexp_eatReverseSolidusAtomEscape = function(state) {\n  var start = state.pos;\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatAtomEscape(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatUncapturingGroup = function(state) {\n  var start = state.pos;\n  if (state.eat(0x28 /* ( */)) {\n    if (state.eat(0x3F /* ? */) && state.eat(0x3A /* : */)) {\n      this.regexp_disjunction(state);\n      if (state.eat(0x29 /* ) */)) {\n        return true\n      }\n      state.raise(\"Unterminated group\");\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatCapturingGroup = function(state) {\n  if (state.eat(0x28 /* ( */)) {\n    if (this.options.ecmaVersion >= 9) {\n      this.regexp_groupSpecifier(state);\n    } else if (state.current() === 0x3F /* ? */) {\n      state.raise(\"Invalid group\");\n    }\n    this.regexp_disjunction(state);\n    if (state.eat(0x29 /* ) */)) {\n      state.numCapturingParens += 1;\n      return true\n    }\n    state.raise(\"Unterminated group\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedAtom\npp$9.regexp_eatExtendedAtom = function(state) {\n  return (\n    state.eat(0x2E /* . */) ||\n    this.regexp_eatReverseSolidusAtomEscape(state) ||\n    this.regexp_eatCharacterClass(state) ||\n    this.regexp_eatUncapturingGroup(state) ||\n    this.regexp_eatCapturingGroup(state) ||\n    this.regexp_eatInvalidBracedQuantifier(state) ||\n    this.regexp_eatExtendedPatternCharacter(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-InvalidBracedQuantifier\npp$9.regexp_eatInvalidBracedQuantifier = function(state) {\n  if (this.regexp_eatBracedQuantifier(state, true)) {\n    state.raise(\"Nothing to repeat\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-SyntaxCharacter\npp$9.regexp_eatSyntaxCharacter = function(state) {\n  var ch = state.current();\n  if (isSyntaxCharacter(ch)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isSyntaxCharacter(ch) {\n  return (\n    ch === 0x24 /* $ */ ||\n    ch >= 0x28 /* ( */ && ch <= 0x2B /* + */ ||\n    ch === 0x2E /* . */ ||\n    ch === 0x3F /* ? */ ||\n    ch >= 0x5B /* [ */ && ch <= 0x5E /* ^ */ ||\n    ch >= 0x7B /* { */ && ch <= 0x7D /* } */\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-PatternCharacter\n// But eat eager.\npp$9.regexp_eatPatternCharacters = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  while ((ch = state.current()) !== -1 && !isSyntaxCharacter(ch)) {\n    state.advance();\n  }\n  return state.pos !== start\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ExtendedPatternCharacter\npp$9.regexp_eatExtendedPatternCharacter = function(state) {\n  var ch = state.current();\n  if (\n    ch !== -1 &&\n    ch !== 0x24 /* $ */ &&\n    !(ch >= 0x28 /* ( */ && ch <= 0x2B /* + */) &&\n    ch !== 0x2E /* . */ &&\n    ch !== 0x3F /* ? */ &&\n    ch !== 0x5B /* [ */ &&\n    ch !== 0x5E /* ^ */ &&\n    ch !== 0x7C /* | */\n  ) {\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// GroupSpecifier[U] ::\n//   [empty]\n//   `?` GroupName[?U]\npp$9.regexp_groupSpecifier = function(state) {\n  if (state.eat(0x3F /* ? */)) {\n    if (this.regexp_eatGroupName(state)) {\n      if (state.groupNames.indexOf(state.lastStringValue) !== -1) {\n        state.raise(\"Duplicate capture group name\");\n      }\n      state.groupNames.push(state.lastStringValue);\n      return\n    }\n    state.raise(\"Invalid group\");\n  }\n};\n\n// GroupName[U] ::\n//   `<` RegExpIdentifierName[?U] `>`\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatGroupName = function(state) {\n  state.lastStringValue = \"\";\n  if (state.eat(0x3C /* < */)) {\n    if (this.regexp_eatRegExpIdentifierName(state) && state.eat(0x3E /* > */)) {\n      return true\n    }\n    state.raise(\"Invalid capture group name\");\n  }\n  return false\n};\n\n// RegExpIdentifierName[U] ::\n//   RegExpIdentifierStart[?U]\n//   RegExpIdentifierName[?U] RegExpIdentifierPart[?U]\n// Note: this updates `state.lastStringValue` property with the eaten name.\npp$9.regexp_eatRegExpIdentifierName = function(state) {\n  state.lastStringValue = \"\";\n  if (this.regexp_eatRegExpIdentifierStart(state)) {\n    state.lastStringValue += codePointToString$1(state.lastIntValue);\n    while (this.regexp_eatRegExpIdentifierPart(state)) {\n      state.lastStringValue += codePointToString$1(state.lastIntValue);\n    }\n    return true\n  }\n  return false\n};\n\n// RegExpIdentifierStart[U] ::\n//   UnicodeIDStart\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\npp$9.regexp_eatRegExpIdentifierStart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierStart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierStart(ch) {\n  return isIdentifierStart(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */\n}\n\n// RegExpIdentifierPart[U] ::\n//   UnicodeIDContinue\n//   `$`\n//   `_`\n//   `\\` RegExpUnicodeEscapeSequence[?U]\n//   <ZWNJ>\n//   <ZWJ>\npp$9.regexp_eatRegExpIdentifierPart = function(state) {\n  var start = state.pos;\n  var ch = state.current();\n  state.advance();\n\n  if (ch === 0x5C /* \\ */ && this.regexp_eatRegExpUnicodeEscapeSequence(state)) {\n    ch = state.lastIntValue;\n  }\n  if (isRegExpIdentifierPart(ch)) {\n    state.lastIntValue = ch;\n    return true\n  }\n\n  state.pos = start;\n  return false\n};\nfunction isRegExpIdentifierPart(ch) {\n  return isIdentifierChar(ch, true) || ch === 0x24 /* $ */ || ch === 0x5F /* _ */ || ch === 0x200C /* <ZWNJ> */ || ch === 0x200D /* <ZWJ> */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-AtomEscape\npp$9.regexp_eatAtomEscape = function(state) {\n  if (\n    this.regexp_eatBackReference(state) ||\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state) ||\n    (state.switchN && this.regexp_eatKGroupName(state))\n  ) {\n    return true\n  }\n  if (state.switchU) {\n    // Make the same message as V8.\n    if (state.current() === 0x63 /* c */) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.raise(\"Invalid escape\");\n  }\n  return false\n};\npp$9.regexp_eatBackReference = function(state) {\n  var start = state.pos;\n  if (this.regexp_eatDecimalEscape(state)) {\n    var n = state.lastIntValue;\n    if (state.switchU) {\n      // For SyntaxError in https://www.ecma-international.org/ecma-262/8.0/#sec-atomescape\n      if (n > state.maxBackReference) {\n        state.maxBackReference = n;\n      }\n      return true\n    }\n    if (n <= state.numCapturingParens) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatKGroupName = function(state) {\n  if (state.eat(0x6B /* k */)) {\n    if (this.regexp_eatGroupName(state)) {\n      state.backReferenceNames.push(state.lastStringValue);\n      return true\n    }\n    state.raise(\"Invalid named reference\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-CharacterEscape\npp$9.regexp_eatCharacterEscape = function(state) {\n  return (\n    this.regexp_eatControlEscape(state) ||\n    this.regexp_eatCControlLetter(state) ||\n    this.regexp_eatZero(state) ||\n    this.regexp_eatHexEscapeSequence(state) ||\n    this.regexp_eatRegExpUnicodeEscapeSequence(state) ||\n    (!state.switchU && this.regexp_eatLegacyOctalEscapeSequence(state)) ||\n    this.regexp_eatIdentityEscape(state)\n  )\n};\npp$9.regexp_eatCControlLetter = function(state) {\n  var start = state.pos;\n  if (state.eat(0x63 /* c */)) {\n    if (this.regexp_eatControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n  return false\n};\npp$9.regexp_eatZero = function(state) {\n  if (state.current() === 0x30 /* 0 */ && !isDecimalDigit(state.lookahead())) {\n    state.lastIntValue = 0;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlEscape\npp$9.regexp_eatControlEscape = function(state) {\n  var ch = state.current();\n  if (ch === 0x74 /* t */) {\n    state.lastIntValue = 0x09; /* \\t */\n    state.advance();\n    return true\n  }\n  if (ch === 0x6E /* n */) {\n    state.lastIntValue = 0x0A; /* \\n */\n    state.advance();\n    return true\n  }\n  if (ch === 0x76 /* v */) {\n    state.lastIntValue = 0x0B; /* \\v */\n    state.advance();\n    return true\n  }\n  if (ch === 0x66 /* f */) {\n    state.lastIntValue = 0x0C; /* \\f */\n    state.advance();\n    return true\n  }\n  if (ch === 0x72 /* r */) {\n    state.lastIntValue = 0x0D; /* \\r */\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ControlLetter\npp$9.regexp_eatControlLetter = function(state) {\n  var ch = state.current();\n  if (isControlLetter(ch)) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\nfunction isControlLetter(ch) {\n  return (\n    (ch >= 0x41 /* A */ && ch <= 0x5A /* Z */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x7A /* z */)\n  )\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-RegExpUnicodeEscapeSequence\npp$9.regexp_eatRegExpUnicodeEscapeSequence = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x75 /* u */)) {\n    if (this.regexp_eatFixedHexDigits(state, 4)) {\n      var lead = state.lastIntValue;\n      if (state.switchU && lead >= 0xD800 && lead <= 0xDBFF) {\n        var leadSurrogateEnd = state.pos;\n        if (state.eat(0x5C /* \\ */) && state.eat(0x75 /* u */) && this.regexp_eatFixedHexDigits(state, 4)) {\n          var trail = state.lastIntValue;\n          if (trail >= 0xDC00 && trail <= 0xDFFF) {\n            state.lastIntValue = (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n            return true\n          }\n        }\n        state.pos = leadSurrogateEnd;\n        state.lastIntValue = lead;\n      }\n      return true\n    }\n    if (\n      state.switchU &&\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatHexDigits(state) &&\n      state.eat(0x7D /* } */) &&\n      isValidUnicode(state.lastIntValue)\n    ) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid unicode escape\");\n    }\n    state.pos = start;\n  }\n\n  return false\n};\nfunction isValidUnicode(ch) {\n  return ch >= 0 && ch <= 0x10FFFF\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-IdentityEscape\npp$9.regexp_eatIdentityEscape = function(state) {\n  if (state.switchU) {\n    if (this.regexp_eatSyntaxCharacter(state)) {\n      return true\n    }\n    if (state.eat(0x2F /* / */)) {\n      state.lastIntValue = 0x2F; /* / */\n      return true\n    }\n    return false\n  }\n\n  var ch = state.current();\n  if (ch !== 0x63 /* c */ && (!state.switchN || ch !== 0x6B /* k */)) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalEscape\npp$9.regexp_eatDecimalEscape = function(state) {\n  state.lastIntValue = 0;\n  var ch = state.current();\n  if (ch >= 0x31 /* 1 */ && ch <= 0x39 /* 9 */) {\n    do {\n      state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n      state.advance();\n    } while ((ch = state.current()) >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */)\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClassEscape\npp$9.regexp_eatCharacterClassEscape = function(state) {\n  var ch = state.current();\n\n  if (isCharacterClassEscape(ch)) {\n    state.lastIntValue = -1;\n    state.advance();\n    return true\n  }\n\n  if (\n    state.switchU &&\n    this.options.ecmaVersion >= 9 &&\n    (ch === 0x50 /* P */ || ch === 0x70 /* p */)\n  ) {\n    state.lastIntValue = -1;\n    state.advance();\n    if (\n      state.eat(0x7B /* { */) &&\n      this.regexp_eatUnicodePropertyValueExpression(state) &&\n      state.eat(0x7D /* } */)\n    ) {\n      return true\n    }\n    state.raise(\"Invalid property name\");\n  }\n\n  return false\n};\nfunction isCharacterClassEscape(ch) {\n  return (\n    ch === 0x64 /* d */ ||\n    ch === 0x44 /* D */ ||\n    ch === 0x73 /* s */ ||\n    ch === 0x53 /* S */ ||\n    ch === 0x77 /* w */ ||\n    ch === 0x57 /* W */\n  )\n}\n\n// UnicodePropertyValueExpression ::\n//   UnicodePropertyName `=` UnicodePropertyValue\n//   LoneUnicodePropertyNameOrValue\npp$9.regexp_eatUnicodePropertyValueExpression = function(state) {\n  var start = state.pos;\n\n  // UnicodePropertyName `=` UnicodePropertyValue\n  if (this.regexp_eatUnicodePropertyName(state) && state.eat(0x3D /* = */)) {\n    var name = state.lastStringValue;\n    if (this.regexp_eatUnicodePropertyValue(state)) {\n      var value = state.lastStringValue;\n      this.regexp_validateUnicodePropertyNameAndValue(state, name, value);\n      return true\n    }\n  }\n  state.pos = start;\n\n  // LoneUnicodePropertyNameOrValue\n  if (this.regexp_eatLoneUnicodePropertyNameOrValue(state)) {\n    var nameOrValue = state.lastStringValue;\n    this.regexp_validateUnicodePropertyNameOrValue(state, nameOrValue);\n    return true\n  }\n  return false\n};\npp$9.regexp_validateUnicodePropertyNameAndValue = function(state, name, value) {\n  if (!data.hasOwnProperty(name) || data[name].indexOf(value) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\npp$9.regexp_validateUnicodePropertyNameOrValue = function(state, nameOrValue) {\n  if (data.$LONE.indexOf(nameOrValue) === -1) {\n    state.raise(\"Invalid property name\");\n  }\n};\n\n// UnicodePropertyName ::\n//   UnicodePropertyNameCharacters\npp$9.regexp_eatUnicodePropertyName = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyNameCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyNameCharacter(ch) {\n  return isControlLetter(ch) || ch === 0x5F /* _ */\n}\n\n// UnicodePropertyValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatUnicodePropertyValue = function(state) {\n  var ch = 0;\n  state.lastStringValue = \"\";\n  while (isUnicodePropertyValueCharacter(ch = state.current())) {\n    state.lastStringValue += codePointToString$1(ch);\n    state.advance();\n  }\n  return state.lastStringValue !== \"\"\n};\nfunction isUnicodePropertyValueCharacter(ch) {\n  return isUnicodePropertyNameCharacter(ch) || isDecimalDigit(ch)\n}\n\n// LoneUnicodePropertyNameOrValue ::\n//   UnicodePropertyValueCharacters\npp$9.regexp_eatLoneUnicodePropertyNameOrValue = function(state) {\n  return this.regexp_eatUnicodePropertyValue(state)\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-CharacterClass\npp$9.regexp_eatCharacterClass = function(state) {\n  if (state.eat(0x5B /* [ */)) {\n    state.eat(0x5E /* ^ */);\n    this.regexp_classRanges(state);\n    if (state.eat(0x5D /* [ */)) {\n      return true\n    }\n    // Unreachable since it threw \"unterminated regular expression\" error before.\n    state.raise(\"Unterminated character class\");\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRanges\n// https://www.ecma-international.org/ecma-262/8.0/#prod-NonemptyClassRangesNoDash\npp$9.regexp_classRanges = function(state) {\n  var this$1 = this;\n\n  while (this.regexp_eatClassAtom(state)) {\n    var left = state.lastIntValue;\n    if (state.eat(0x2D /* - */) && this$1.regexp_eatClassAtom(state)) {\n      var right = state.lastIntValue;\n      if (state.switchU && (left === -1 || right === -1)) {\n        state.raise(\"Invalid character class\");\n      }\n      if (left !== -1 && right !== -1 && left > right) {\n        state.raise(\"Range out of order in character class\");\n      }\n    }\n  }\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtom\n// https://www.ecma-international.org/ecma-262/8.0/#prod-ClassAtomNoDash\npp$9.regexp_eatClassAtom = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x5C /* \\ */)) {\n    if (this.regexp_eatClassEscape(state)) {\n      return true\n    }\n    if (state.switchU) {\n      // Make the same message as V8.\n      var ch$1 = state.current();\n      if (ch$1 === 0x63 /* c */ || isOctalDigit(ch$1)) {\n        state.raise(\"Invalid class escape\");\n      }\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n\n  var ch = state.current();\n  if (ch !== 0x5D /* [ */) {\n    state.lastIntValue = ch;\n    state.advance();\n    return true\n  }\n\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassEscape\npp$9.regexp_eatClassEscape = function(state) {\n  var start = state.pos;\n\n  if (state.eat(0x62 /* b */)) {\n    state.lastIntValue = 0x08; /* <BS> */\n    return true\n  }\n\n  if (state.switchU && state.eat(0x2D /* - */)) {\n    state.lastIntValue = 0x2D; /* - */\n    return true\n  }\n\n  if (!state.switchU && state.eat(0x63 /* c */)) {\n    if (this.regexp_eatClassControlLetter(state)) {\n      return true\n    }\n    state.pos = start;\n  }\n\n  return (\n    this.regexp_eatCharacterClassEscape(state) ||\n    this.regexp_eatCharacterEscape(state)\n  )\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-ClassControlLetter\npp$9.regexp_eatClassControlLetter = function(state) {\n  var ch = state.current();\n  if (isDecimalDigit(ch) || ch === 0x5F /* _ */) {\n    state.lastIntValue = ch % 0x20;\n    state.advance();\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatHexEscapeSequence = function(state) {\n  var start = state.pos;\n  if (state.eat(0x78 /* x */)) {\n    if (this.regexp_eatFixedHexDigits(state, 2)) {\n      return true\n    }\n    if (state.switchU) {\n      state.raise(\"Invalid escape\");\n    }\n    state.pos = start;\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-DecimalDigits\npp$9.regexp_eatDecimalDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isDecimalDigit(ch = state.current())) {\n    state.lastIntValue = 10 * state.lastIntValue + (ch - 0x30 /* 0 */);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isDecimalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigits\npp$9.regexp_eatHexDigits = function(state) {\n  var start = state.pos;\n  var ch = 0;\n  state.lastIntValue = 0;\n  while (isHexDigit(ch = state.current())) {\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return state.pos !== start\n};\nfunction isHexDigit(ch) {\n  return (\n    (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) ||\n    (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) ||\n    (ch >= 0x61 /* a */ && ch <= 0x66 /* f */)\n  )\n}\nfunction hexToInt(ch) {\n  if (ch >= 0x41 /* A */ && ch <= 0x46 /* F */) {\n    return 10 + (ch - 0x41 /* A */)\n  }\n  if (ch >= 0x61 /* a */ && ch <= 0x66 /* f */) {\n    return 10 + (ch - 0x61 /* a */)\n  }\n  return ch - 0x30 /* 0 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-annexB-LegacyOctalEscapeSequence\n// Allows only 0-377(octal) i.e. 0-255(decimal).\npp$9.regexp_eatLegacyOctalEscapeSequence = function(state) {\n  if (this.regexp_eatOctalDigit(state)) {\n    var n1 = state.lastIntValue;\n    if (this.regexp_eatOctalDigit(state)) {\n      var n2 = state.lastIntValue;\n      if (n1 <= 3 && this.regexp_eatOctalDigit(state)) {\n        state.lastIntValue = n1 * 64 + n2 * 8 + state.lastIntValue;\n      } else {\n        state.lastIntValue = n1 * 8 + n2;\n      }\n    } else {\n      state.lastIntValue = n1;\n    }\n    return true\n  }\n  return false\n};\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-OctalDigit\npp$9.regexp_eatOctalDigit = function(state) {\n  var ch = state.current();\n  if (isOctalDigit(ch)) {\n    state.lastIntValue = ch - 0x30; /* 0 */\n    state.advance();\n    return true\n  }\n  state.lastIntValue = 0;\n  return false\n};\nfunction isOctalDigit(ch) {\n  return ch >= 0x30 /* 0 */ && ch <= 0x37 /* 7 */\n}\n\n// https://www.ecma-international.org/ecma-262/8.0/#prod-Hex4Digits\n// https://www.ecma-international.org/ecma-262/8.0/#prod-HexDigit\n// And HexDigit HexDigit in https://www.ecma-international.org/ecma-262/8.0/#prod-HexEscapeSequence\npp$9.regexp_eatFixedHexDigits = function(state, length) {\n  var start = state.pos;\n  state.lastIntValue = 0;\n  for (var i = 0; i < length; ++i) {\n    var ch = state.current();\n    if (!isHexDigit(ch)) {\n      state.pos = start;\n      return false\n    }\n    state.lastIntValue = 16 * state.lastIntValue + hexToInt(ch);\n    state.advance();\n  }\n  return true\n};\n\n// Object type used to represent tokens. Note that normally, tokens\n// simply exist as properties on the parser object. This is only\n// used for the onToken callback and the external tokenizer.\n\nvar Token = function Token(p) {\n  this.type = p.type;\n  this.value = p.value;\n  this.start = p.start;\n  this.end = p.end;\n  if (p.options.locations)\n    { this.loc = new SourceLocation(p, p.startLoc, p.endLoc); }\n  if (p.options.ranges)\n    { this.range = [p.start, p.end]; }\n};\n\n// ## Tokenizer\n\nvar pp$8 = Parser.prototype;\n\n// Move to the next token\n\npp$8.next = function() {\n  if (this.options.onToken)\n    { this.options.onToken(new Token(this)); }\n\n  this.lastTokEnd = this.end;\n  this.lastTokStart = this.start;\n  this.lastTokEndLoc = this.endLoc;\n  this.lastTokStartLoc = this.startLoc;\n  this.nextToken();\n};\n\npp$8.getToken = function() {\n  this.next();\n  return new Token(this)\n};\n\n// If we're in an ES6 environment, make parsers iterable\nif (typeof Symbol !== \"undefined\")\n  { pp$8[Symbol.iterator] = function() {\n    var this$1 = this;\n\n    return {\n      next: function () {\n        var token = this$1.getToken();\n        return {\n          done: token.type === types.eof,\n          value: token\n        }\n      }\n    }\n  }; }\n\n// Toggle strict mode. Re-reads the next number or string to please\n// pedantic tests (`\"use strict\"; 010;` should fail).\n\npp$8.curContext = function() {\n  return this.context[this.context.length - 1]\n};\n\n// Read a single token, updating the parser object's token-related\n// properties.\n\npp$8.nextToken = function() {\n  var curContext = this.curContext();\n  if (!curContext || !curContext.preserveSpace) { this.skipSpace(); }\n\n  this.start = this.pos;\n  if (this.options.locations) { this.startLoc = this.curPosition(); }\n  if (this.pos >= this.input.length) { return this.finishToken(types.eof) }\n\n  if (curContext.override) { return curContext.override(this) }\n  else { this.readToken(this.fullCharCodeAtPos()); }\n};\n\npp$8.readToken = function(code) {\n  // Identifier or keyword. '\\uXXXX' sequences are allowed in\n  // identifiers, so '\\' also dispatches to that.\n  if (isIdentifierStart(code, this.options.ecmaVersion >= 6) || code === 92 /* '\\' */)\n    { return this.readWord() }\n\n  return this.getTokenFromCode(code)\n};\n\npp$8.fullCharCodeAtPos = function() {\n  var code = this.input.charCodeAt(this.pos);\n  if (code <= 0xd7ff || code >= 0xe000) { return code }\n  var next = this.input.charCodeAt(this.pos + 1);\n  return (code << 10) + next - 0x35fdc00\n};\n\npp$8.skipBlockComment = function() {\n  var this$1 = this;\n\n  var startLoc = this.options.onComment && this.curPosition();\n  var start = this.pos, end = this.input.indexOf(\"*/\", this.pos += 2);\n  if (end === -1) { this.raise(this.pos - 2, \"Unterminated comment\"); }\n  this.pos = end + 2;\n  if (this.options.locations) {\n    lineBreakG.lastIndex = start;\n    var match;\n    while ((match = lineBreakG.exec(this.input)) && match.index < this.pos) {\n      ++this$1.curLine;\n      this$1.lineStart = match.index + match[0].length;\n    }\n  }\n  if (this.options.onComment)\n    { this.options.onComment(true, this.input.slice(start + 2, end), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\npp$8.skipLineComment = function(startSkip) {\n  var this$1 = this;\n\n  var start = this.pos;\n  var startLoc = this.options.onComment && this.curPosition();\n  var ch = this.input.charCodeAt(this.pos += startSkip);\n  while (this.pos < this.input.length && !isNewLine(ch)) {\n    ch = this$1.input.charCodeAt(++this$1.pos);\n  }\n  if (this.options.onComment)\n    { this.options.onComment(false, this.input.slice(start + startSkip, this.pos), start, this.pos,\n                           startLoc, this.curPosition()); }\n};\n\n// Called at the start of the parse and after every token. Skips\n// whitespace and comments, and.\n\npp$8.skipSpace = function() {\n  var this$1 = this;\n\n  loop: while (this.pos < this.input.length) {\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    switch (ch) {\n    case 32: case 160: // ' '\n      ++this$1.pos;\n      break\n    case 13:\n      if (this$1.input.charCodeAt(this$1.pos + 1) === 10) {\n        ++this$1.pos;\n      }\n    case 10: case 8232: case 8233:\n      ++this$1.pos;\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      break\n    case 47: // '/'\n      switch (this$1.input.charCodeAt(this$1.pos + 1)) {\n      case 42: // '*'\n        this$1.skipBlockComment();\n        break\n      case 47:\n        this$1.skipLineComment(2);\n        break\n      default:\n        break loop\n      }\n      break\n    default:\n      if (ch > 8 && ch < 14 || ch >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(ch))) {\n        ++this$1.pos;\n      } else {\n        break loop\n      }\n    }\n  }\n};\n\n// Called at the end of every token. Sets `end`, `val`, and\n// maintains `context` and `exprAllowed`, and skips the space after\n// the token, so that the next one's `start` will point at the\n// right position.\n\npp$8.finishToken = function(type, val) {\n  this.end = this.pos;\n  if (this.options.locations) { this.endLoc = this.curPosition(); }\n  var prevType = this.type;\n  this.type = type;\n  this.value = val;\n\n  this.updateContext(prevType);\n};\n\n// ### Token reading\n\n// This is the function that is called to fetch the next token. It\n// is somewhat obscure, because it works in character codes rather\n// than characters, and because operator parsing has been inlined\n// into it.\n//\n// All in the name of speed.\n//\npp$8.readToken_dot = function() {\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next >= 48 && next <= 57) { return this.readNumber(true) }\n  var next2 = this.input.charCodeAt(this.pos + 2);\n  if (this.options.ecmaVersion >= 6 && next === 46 && next2 === 46) { // 46 = dot '.'\n    this.pos += 3;\n    return this.finishToken(types.ellipsis)\n  } else {\n    ++this.pos;\n    return this.finishToken(types.dot)\n  }\n};\n\npp$8.readToken_slash = function() { // '/'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (this.exprAllowed) { ++this.pos; return this.readRegexp() }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.slash, 1)\n};\n\npp$8.readToken_mult_modulo_exp = function(code) { // '%*'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  var tokentype = code === 42 ? types.star : types.modulo;\n\n  // exponentiation operator ** and **=\n  if (this.options.ecmaVersion >= 7 && code === 42 && next === 42) {\n    ++size;\n    tokentype = types.starstar;\n    next = this.input.charCodeAt(this.pos + 2);\n  }\n\n  if (next === 61) { return this.finishOp(types.assign, size + 1) }\n  return this.finishOp(tokentype, size)\n};\n\npp$8.readToken_pipe_amp = function(code) { // '|&'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) { return this.finishOp(code === 124 ? types.logicalOR : types.logicalAND, 2) }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(code === 124 ? types.bitwiseOR : types.bitwiseAND, 1)\n};\n\npp$8.readToken_caret = function() { // '^'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.bitwiseXOR, 1)\n};\n\npp$8.readToken_plus_min = function(code) { // '+-'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === code) {\n    if (next === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 &&\n        (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos)))) {\n      // A `-->` line comment\n      this.skipLineComment(3);\n      this.skipSpace();\n      return this.nextToken()\n    }\n    return this.finishOp(types.incDec, 2)\n  }\n  if (next === 61) { return this.finishOp(types.assign, 2) }\n  return this.finishOp(types.plusMin, 1)\n};\n\npp$8.readToken_lt_gt = function(code) { // '<>'\n  var next = this.input.charCodeAt(this.pos + 1);\n  var size = 1;\n  if (next === code) {\n    size = code === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2;\n    if (this.input.charCodeAt(this.pos + size) === 61) { return this.finishOp(types.assign, size + 1) }\n    return this.finishOp(types.bitShift, size)\n  }\n  if (next === 33 && code === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 &&\n      this.input.charCodeAt(this.pos + 3) === 45) {\n    // `<!--`, an XML-style comment that should be interpreted as a line comment\n    this.skipLineComment(4);\n    this.skipSpace();\n    return this.nextToken()\n  }\n  if (next === 61) { size = 2; }\n  return this.finishOp(types.relational, size)\n};\n\npp$8.readToken_eq_excl = function(code) { // '=!'\n  var next = this.input.charCodeAt(this.pos + 1);\n  if (next === 61) { return this.finishOp(types.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) }\n  if (code === 61 && next === 62 && this.options.ecmaVersion >= 6) { // '=>'\n    this.pos += 2;\n    return this.finishToken(types.arrow)\n  }\n  return this.finishOp(code === 61 ? types.eq : types.prefix, 1)\n};\n\npp$8.getTokenFromCode = function(code) {\n  switch (code) {\n  // The interpretation of a dot depends on whether it is followed\n  // by a digit or another two dots.\n  case 46: // '.'\n    return this.readToken_dot()\n\n  // Punctuation tokens.\n  case 40: ++this.pos; return this.finishToken(types.parenL)\n  case 41: ++this.pos; return this.finishToken(types.parenR)\n  case 59: ++this.pos; return this.finishToken(types.semi)\n  case 44: ++this.pos; return this.finishToken(types.comma)\n  case 91: ++this.pos; return this.finishToken(types.bracketL)\n  case 93: ++this.pos; return this.finishToken(types.bracketR)\n  case 123: ++this.pos; return this.finishToken(types.braceL)\n  case 125: ++this.pos; return this.finishToken(types.braceR)\n  case 58: ++this.pos; return this.finishToken(types.colon)\n  case 63: ++this.pos; return this.finishToken(types.question)\n\n  case 96: // '`'\n    if (this.options.ecmaVersion < 6) { break }\n    ++this.pos;\n    return this.finishToken(types.backQuote)\n\n  case 48: // '0'\n    var next = this.input.charCodeAt(this.pos + 1);\n    if (next === 120 || next === 88) { return this.readRadixNumber(16) } // '0x', '0X' - hex number\n    if (this.options.ecmaVersion >= 6) {\n      if (next === 111 || next === 79) { return this.readRadixNumber(8) } // '0o', '0O' - octal number\n      if (next === 98 || next === 66) { return this.readRadixNumber(2) } // '0b', '0B' - binary number\n    }\n\n  // Anything else beginning with a digit is an integer, octal\n  // number, or float.\n  case 49: case 50: case 51: case 52: case 53: case 54: case 55: case 56: case 57: // 1-9\n    return this.readNumber(false)\n\n  // Quotes produce strings.\n  case 34: case 39: // '\"', \"'\"\n    return this.readString(code)\n\n  // Operators are parsed inline in tiny state machines. '=' (61) is\n  // often referred to. `finishOp` simply skips the amount of\n  // characters it is given as second argument, and returns a token\n  // of the type given by its first argument.\n\n  case 47: // '/'\n    return this.readToken_slash()\n\n  case 37: case 42: // '%*'\n    return this.readToken_mult_modulo_exp(code)\n\n  case 124: case 38: // '|&'\n    return this.readToken_pipe_amp(code)\n\n  case 94: // '^'\n    return this.readToken_caret()\n\n  case 43: case 45: // '+-'\n    return this.readToken_plus_min(code)\n\n  case 60: case 62: // '<>'\n    return this.readToken_lt_gt(code)\n\n  case 61: case 33: // '=!'\n    return this.readToken_eq_excl(code)\n\n  case 126: // '~'\n    return this.finishOp(types.prefix, 1)\n  }\n\n  this.raise(this.pos, \"Unexpected character '\" + codePointToString(code) + \"'\");\n};\n\npp$8.finishOp = function(type, size) {\n  var str = this.input.slice(this.pos, this.pos + size);\n  this.pos += size;\n  return this.finishToken(type, str)\n};\n\npp$8.readRegexp = function() {\n  var this$1 = this;\n\n  var escaped, inClass, start = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(start, \"Unterminated regular expression\"); }\n    var ch = this$1.input.charAt(this$1.pos);\n    if (lineBreak.test(ch)) { this$1.raise(start, \"Unterminated regular expression\"); }\n    if (!escaped) {\n      if (ch === \"[\") { inClass = true; }\n      else if (ch === \"]\" && inClass) { inClass = false; }\n      else if (ch === \"/\" && !inClass) { break }\n      escaped = ch === \"\\\\\";\n    } else { escaped = false; }\n    ++this$1.pos;\n  }\n  var pattern = this.input.slice(start, this.pos);\n  ++this.pos;\n  var flagsStart = this.pos;\n  var flags = this.readWord1();\n  if (this.containsEsc) { this.unexpected(flagsStart); }\n\n  // Validate pattern\n  var state = this.regexpState || (this.regexpState = new RegExpValidationState(this));\n  state.reset(start, pattern, flags);\n  this.validateRegExpFlags(state);\n  this.validateRegExpPattern(state);\n\n  // Create Literal#value property value.\n  var value = null;\n  try {\n    value = new RegExp(pattern, flags);\n  } catch (e) {\n    // ESTree requires null if it failed to instantiate RegExp object.\n    // https://github.com/estree/estree/blob/a27003adf4fd7bfad44de9cef372a2eacd527b1c/es5.md#regexpliteral\n  }\n\n  return this.finishToken(types.regexp, {pattern: pattern, flags: flags, value: value})\n};\n\n// Read an integer in the given radix. Return null if zero digits\n// were read, the integer value otherwise. When `len` is given, this\n// will return `null` unless the integer has exactly `len` digits.\n\npp$8.readInt = function(radix, len) {\n  var this$1 = this;\n\n  var start = this.pos, total = 0;\n  for (var i = 0, e = len == null ? Infinity : len; i < e; ++i) {\n    var code = this$1.input.charCodeAt(this$1.pos), val = (void 0);\n    if (code >= 97) { val = code - 97 + 10; } // a\n    else if (code >= 65) { val = code - 65 + 10; } // A\n    else if (code >= 48 && code <= 57) { val = code - 48; } // 0-9\n    else { val = Infinity; }\n    if (val >= radix) { break }\n    ++this$1.pos;\n    total = total * radix + val;\n  }\n  if (this.pos === start || len != null && this.pos - start !== len) { return null }\n\n  return total\n};\n\npp$8.readRadixNumber = function(radix) {\n  this.pos += 2; // 0x\n  var val = this.readInt(radix);\n  if (val == null) { this.raise(this.start + 2, \"Expected number in radix \" + radix); }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n  return this.finishToken(types.num, val)\n};\n\n// Read an integer, octal integer, or floating-point number.\n\npp$8.readNumber = function(startsWithDot) {\n  var start = this.pos;\n  if (!startsWithDot && this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  var octal = this.pos - start >= 2 && this.input.charCodeAt(start) === 48;\n  if (octal && this.strict) { this.raise(start, \"Invalid number\"); }\n  if (octal && /[89]/.test(this.input.slice(start, this.pos))) { octal = false; }\n  var next = this.input.charCodeAt(this.pos);\n  if (next === 46 && !octal) { // '.'\n    ++this.pos;\n    this.readInt(10);\n    next = this.input.charCodeAt(this.pos);\n  }\n  if ((next === 69 || next === 101) && !octal) { // 'eE'\n    next = this.input.charCodeAt(++this.pos);\n    if (next === 43 || next === 45) { ++this.pos; } // '+-'\n    if (this.readInt(10) === null) { this.raise(start, \"Invalid number\"); }\n  }\n  if (isIdentifierStart(this.fullCharCodeAtPos())) { this.raise(this.pos, \"Identifier directly after number\"); }\n\n  var str = this.input.slice(start, this.pos);\n  var val = octal ? parseInt(str, 8) : parseFloat(str);\n  return this.finishToken(types.num, val)\n};\n\n// Read a string value, interpreting backslash-escapes.\n\npp$8.readCodePoint = function() {\n  var ch = this.input.charCodeAt(this.pos), code;\n\n  if (ch === 123) { // '{'\n    if (this.options.ecmaVersion < 6) { this.unexpected(); }\n    var codePos = ++this.pos;\n    code = this.readHexChar(this.input.indexOf(\"}\", this.pos) - this.pos);\n    ++this.pos;\n    if (code > 0x10FFFF) { this.invalidStringToken(codePos, \"Code point out of bounds\"); }\n  } else {\n    code = this.readHexChar(4);\n  }\n  return code\n};\n\nfunction codePointToString(code) {\n  // UTF-16 Decoding\n  if (code <= 0xFFFF) { return String.fromCharCode(code) }\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xD800, (code & 1023) + 0xDC00)\n}\n\npp$8.readString = function(quote) {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = ++this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === quote) { break }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(false);\n      chunkStart = this$1.pos;\n    } else {\n      if (isNewLine(ch, this$1.options.ecmaVersion >= 10)) { this$1.raise(this$1.start, \"Unterminated string constant\"); }\n      ++this$1.pos;\n    }\n  }\n  out += this.input.slice(chunkStart, this.pos++);\n  return this.finishToken(types.string, out)\n};\n\n// Reads template string tokens.\n\nvar INVALID_TEMPLATE_ESCAPE_ERROR = {};\n\npp$8.tryReadTemplateToken = function() {\n  this.inTemplateElement = true;\n  try {\n    this.readTmplToken();\n  } catch (err) {\n    if (err === INVALID_TEMPLATE_ESCAPE_ERROR) {\n      this.readInvalidTemplateToken();\n    } else {\n      throw err\n    }\n  }\n\n  this.inTemplateElement = false;\n};\n\npp$8.invalidStringToken = function(position, message) {\n  if (this.inTemplateElement && this.options.ecmaVersion >= 9) {\n    throw INVALID_TEMPLATE_ESCAPE_ERROR\n  } else {\n    this.raise(position, message);\n  }\n};\n\npp$8.readTmplToken = function() {\n  var this$1 = this;\n\n  var out = \"\", chunkStart = this.pos;\n  for (;;) {\n    if (this$1.pos >= this$1.input.length) { this$1.raise(this$1.start, \"Unterminated template\"); }\n    var ch = this$1.input.charCodeAt(this$1.pos);\n    if (ch === 96 || ch === 36 && this$1.input.charCodeAt(this$1.pos + 1) === 123) { // '`', '${'\n      if (this$1.pos === this$1.start && (this$1.type === types.template || this$1.type === types.invalidTemplate)) {\n        if (ch === 36) {\n          this$1.pos += 2;\n          return this$1.finishToken(types.dollarBraceL)\n        } else {\n          ++this$1.pos;\n          return this$1.finishToken(types.backQuote)\n        }\n      }\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      return this$1.finishToken(types.template, out)\n    }\n    if (ch === 92) { // '\\'\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      out += this$1.readEscapedChar(true);\n      chunkStart = this$1.pos;\n    } else if (isNewLine(ch)) {\n      out += this$1.input.slice(chunkStart, this$1.pos);\n      ++this$1.pos;\n      switch (ch) {\n      case 13:\n        if (this$1.input.charCodeAt(this$1.pos) === 10) { ++this$1.pos; }\n      case 10:\n        out += \"\\n\";\n        break\n      default:\n        out += String.fromCharCode(ch);\n        break\n      }\n      if (this$1.options.locations) {\n        ++this$1.curLine;\n        this$1.lineStart = this$1.pos;\n      }\n      chunkStart = this$1.pos;\n    } else {\n      ++this$1.pos;\n    }\n  }\n};\n\n// Reads a template token to search for the end, without validating any escape sequences\npp$8.readInvalidTemplateToken = function() {\n  var this$1 = this;\n\n  for (; this.pos < this.input.length; this.pos++) {\n    switch (this$1.input[this$1.pos]) {\n    case \"\\\\\":\n      ++this$1.pos;\n      break\n\n    case \"$\":\n      if (this$1.input[this$1.pos + 1] !== \"{\") {\n        break\n      }\n    // falls through\n\n    case \"`\":\n      return this$1.finishToken(types.invalidTemplate, this$1.input.slice(this$1.start, this$1.pos))\n\n    // no default\n    }\n  }\n  this.raise(this.start, \"Unterminated template\");\n};\n\n// Used to read escaped characters\n\npp$8.readEscapedChar = function(inTemplate) {\n  var ch = this.input.charCodeAt(++this.pos);\n  ++this.pos;\n  switch (ch) {\n  case 110: return \"\\n\" // 'n' -> '\\n'\n  case 114: return \"\\r\" // 'r' -> '\\r'\n  case 120: return String.fromCharCode(this.readHexChar(2)) // 'x'\n  case 117: return codePointToString(this.readCodePoint()) // 'u'\n  case 116: return \"\\t\" // 't' -> '\\t'\n  case 98: return \"\\b\" // 'b' -> '\\b'\n  case 118: return \"\\u000b\" // 'v' -> '\\u000b'\n  case 102: return \"\\f\" // 'f' -> '\\f'\n  case 13: if (this.input.charCodeAt(this.pos) === 10) { ++this.pos; } // '\\r\\n'\n  case 10: // ' \\n'\n    if (this.options.locations) { this.lineStart = this.pos; ++this.curLine; }\n    return \"\"\n  default:\n    if (ch >= 48 && ch <= 55) {\n      var octalStr = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0];\n      var octal = parseInt(octalStr, 8);\n      if (octal > 255) {\n        octalStr = octalStr.slice(0, -1);\n        octal = parseInt(octalStr, 8);\n      }\n      this.pos += octalStr.length - 1;\n      ch = this.input.charCodeAt(this.pos);\n      if ((octalStr !== \"0\" || ch === 56 || ch === 57) && (this.strict || inTemplate)) {\n        this.invalidStringToken(\n          this.pos - 1 - octalStr.length,\n          inTemplate\n            ? \"Octal literal in template string\"\n            : \"Octal literal in strict mode\"\n        );\n      }\n      return String.fromCharCode(octal)\n    }\n    return String.fromCharCode(ch)\n  }\n};\n\n// Used to read character escape sequences ('\\x', '\\u', '\\U').\n\npp$8.readHexChar = function(len) {\n  var codePos = this.pos;\n  var n = this.readInt(16, len);\n  if (n === null) { this.invalidStringToken(codePos, \"Bad character escape sequence\"); }\n  return n\n};\n\n// Read an identifier, and return it as a string. Sets `this.containsEsc`\n// to whether the word contained a '\\u' escape.\n//\n// Incrementally adds only escaped chars, adding other chunks as-is\n// as a micro-optimization.\n\npp$8.readWord1 = function() {\n  var this$1 = this;\n\n  this.containsEsc = false;\n  var word = \"\", first = true, chunkStart = this.pos;\n  var astral = this.options.ecmaVersion >= 6;\n  while (this.pos < this.input.length) {\n    var ch = this$1.fullCharCodeAtPos();\n    if (isIdentifierChar(ch, astral)) {\n      this$1.pos += ch <= 0xffff ? 1 : 2;\n    } else if (ch === 92) { // \"\\\"\n      this$1.containsEsc = true;\n      word += this$1.input.slice(chunkStart, this$1.pos);\n      var escStart = this$1.pos;\n      if (this$1.input.charCodeAt(++this$1.pos) !== 117) // \"u\"\n        { this$1.invalidStringToken(this$1.pos, \"Expecting Unicode escape sequence \\\\uXXXX\"); }\n      ++this$1.pos;\n      var esc = this$1.readCodePoint();\n      if (!(first ? isIdentifierStart : isIdentifierChar)(esc, astral))\n        { this$1.invalidStringToken(escStart, \"Invalid Unicode escape\"); }\n      word += codePointToString(esc);\n      chunkStart = this$1.pos;\n    } else {\n      break\n    }\n    first = false;\n  }\n  return word + this.input.slice(chunkStart, this.pos)\n};\n\n// Read an identifier or keyword token. Will check for reserved\n// words when necessary.\n\npp$8.readWord = function() {\n  var word = this.readWord1();\n  var type = types.name;\n  if (this.keywords.test(word)) {\n    if (this.containsEsc) { this.raiseRecoverable(this.start, \"Escape sequence in keyword \" + word); }\n    type = keywords$1[word];\n  }\n  return this.finishToken(type, word)\n};\n\n// Acorn is a tiny, fast JavaScript parser written in JavaScript.\n//\n// Acorn was written by Marijn Haverbeke, Ingvar Stepanyan, and\n// various contributors and released under an MIT license.\n//\n// Git repositories for Acorn are available at\n//\n//     http://marijnhaverbeke.nl/git/acorn\n//     https://github.com/acornjs/acorn.git\n//\n// Please use the [github bug tracker][ghbt] to report issues.\n//\n// [ghbt]: https://github.com/acornjs/acorn/issues\n//\n// This file defines the main parser interface. The library also comes\n// with a [error-tolerant parser][dammit] and an\n// [abstract syntax tree walker][walk], defined in other files.\n//\n// [dammit]: acorn_loose.js\n// [walk]: util/walk.js\n\nvar version = \"5.7.3\";\n\n// The main exported interface (under `self.acorn` when in the\n// browser) is a `parse` function that takes a code string and\n// returns an abstract syntax tree as specified by [Mozilla parser\n// API][api].\n//\n// [api]: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API\n\nfunction parse(input, options) {\n  return new Parser(options, input).parse()\n}\n\n// This function tries to parse a single expression at a given\n// offset in a string. Useful for parsing mixed-language formats\n// that embed JavaScript expressions.\n\nfunction parseExpressionAt(input, pos, options) {\n  var p = new Parser(options, input, pos);\n  p.nextToken();\n  return p.parseExpression()\n}\n\n// Acorn is organized as a tokenizer and a recursive-descent parser.\n// The `tokenizer` export provides an interface to the tokenizer.\n\nfunction tokenizer(input, options) {\n  return new Parser(options, input)\n}\n\n// This is a terrible kludge to support the existing, pre-ES6\n// interface where the loose parser module retroactively adds exports\n// to this module.\nvar parse_dammit;\nvar LooseParser;\nvar pluginsLoose; // eslint-disable-line camelcase\nfunction addLooseExports(parse, Parser$$1, plugins$$1) {\n  parse_dammit = parse; // eslint-disable-line camelcase\n  LooseParser = Parser$$1;\n  pluginsLoose = plugins$$1;\n}\n\nexport { version, parse, parseExpressionAt, tokenizer, parse_dammit, LooseParser, pluginsLoose, addLooseExports, Parser, plugins, defaultOptions, Position, SourceLocation, getLineInfo, Node, TokenType, types as tokTypes, keywords$1 as keywordTypes, TokContext, types$1 as tokContexts, isIdentifierChar, isIdentifierStart, Token, isNewLine, lineBreak, lineBreakG, nonASCIIwhitespace };\n"],"mappings":"AAAA;;AAEA,IAAIA,aAAa,GAAG;EAClB,CAAC,EAAE,qNAAqN;EACxN,CAAC,EAAE,8CAA8C;EACjD,CAAC,EAAE,MAAM;EACTC,MAAM,EAAE,wEAAwE;EAChFC,UAAU,EAAE;AACd,CAAC;;AAED;;AAEA,IAAIC,oBAAoB,GAAG,6KAA6K;AAExM,IAAIC,QAAQ,GAAG;EACb,CAAC,EAAED,oBAAoB;EACvB,CAAC,EAAEA,oBAAoB,GAAG;AAC5B,CAAC;AAED,IAAIE,yBAAyB,GAAG,iBAAiB;;AAEjD;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAIC,4BAA4B,GAAG,2tIAA2tI;AAC9vI,IAAIC,uBAAuB,GAAG,qjFAAqjF;AAEnlF,IAAIC,uBAAuB,GAAG,IAAIC,MAAM,CAAC,GAAG,GAAGH,4BAA4B,GAAG,GAAG,CAAC;AAClF,IAAII,kBAAkB,GAAG,IAAID,MAAM,CAAC,GAAG,GAAGH,4BAA4B,GAAGC,uBAAuB,GAAG,GAAG,CAAC;AAEvGD,4BAA4B,GAAGC,uBAAuB,GAAG,IAAI;;AAE7D;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAII,0BAA0B,GAAG,CAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,IAAI,EAAC,IAAI,EAAC,IAAI,EAAC,GAAG,EAAC,IAAI,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,EAAE,EAAC,GAAG,EAAC,IAAI,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,IAAI,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,KAAK,EAAC,EAAE,EAAC,IAAI,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,IAAI,EAAC,IAAI,EAAC,GAAG,CAAC;;AAErqC;AACA,IAAIC,qBAAqB,GAAG,CAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,KAAK,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,EAAE,EAAC,CAAC,EAAC,KAAK,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,IAAI,EAAC,EAAE,EAAC,GAAG,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,IAAI,EAAC,CAAC,EAAC,CAAC,EAAC,EAAE,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,IAAI,EAAC,CAAC,EAAC,GAAG,EAAC,CAAC,EAAC,CAAC,EAAC,CAAC,EAAC,MAAM,EAAC,GAAG,CAAC;;AAEjlB;AA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}