{"ast":null,"code":"\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\nconst {\n  HTML_NS\n} = require(\"../living/helpers/namespaces\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\nconst OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\nconst originalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function () {\n  const before = this.items[this.stackTop];\n  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n  originalPop.apply(this, args);\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\nconst originalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function () {\n  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    args[_key2] = arguments[_key2];\n  }\n  originalPush.apply(this, args);\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\nmodule.exports = class HTMLToDOM {\n  constructor(parsingMode) {\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n  appendToNode(html, node) {\n    html = String(html);\n    return this._doParse(html, true, node);\n  }\n  appendToDocument(html, documentImpl) {\n    html = String(html);\n    return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n  }\n  _doParse() {\n    return this.parser === parse5 ? this._parseWithParse5(...arguments) : this._parseWithSax(...arguments);\n  }\n  _parseWithParse5(html, isFragment, contextNode) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n    options.treeAdapter = adapter;\n    if (isFragment) {\n      const fragment = this.parser.parseFragment(contextNode, html, options);\n      if (contextNode._templateContents) {\n        contextNode._templateContents.appendChild(fragment);\n      } else {\n        contextNode.appendChild(fragment);\n      }\n    } else {\n      this.parser.parse(html, options);\n    }\n    return contextNode;\n  }\n  _parseWithSax(html, isFragment, contextNode) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser( /* strict = */true, {\n      xmlns: true,\n      strictEntities: true\n    });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [contextNode];\n    parser.ontext = text => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.oncdata = cdata => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"cdata\",\n        data: cdata\n      });\n    };\n    parser.onopentag = arg => {\n      const attrs = Object.keys(arg.attributes).map(key => {\n        const rawAttribute = arg.attributes[key];\n        let {\n          prefix\n        } = rawAttribute;\n        let localName = rawAttribute.local;\n        if (prefix === \"xmlns\" && localName === \"\") {\n          // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n          localName = prefix;\n          prefix = null;\n        }\n        if (prefix === \"\") {\n          prefix = null;\n        }\n        const namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n        return {\n          name: rawAttribute.name,\n          value: rawAttribute.value,\n          prefix,\n          localName,\n          namespace\n        };\n      });\n      const tag = {\n        type: \"tag\",\n        name: arg.local,\n        prefix: arg.prefix,\n        namespace: arg.uri,\n        attributes: attrs\n      };\n      if (arg.local === \"script\" && arg.uri === HTML_NS) {\n        openStack.push(tag);\n      } else {\n        const elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") {\n        // we have an empty script tag\n        setChildForSax(openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{\n        type: \"text\",\n        data: scriptText\n      }];\n      const elem = setChildForSax(openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while (result = entityMatcher.exec(dt)) {\n        const [, name, value] = result;\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n};\nfunction setChildForSax(parentImpl, node) {\n  const currentDocument = parentImpl && parentImpl._ownerDocument || parentImpl;\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n      break;\n  }\n  if (!newNode) {\n    return null;\n  }\n  if (node.attributes) {\n    for (const a of node.attributes) {\n      attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n    }\n  }\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n  return newNode;\n}\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], {\n    ownerDocument,\n    name,\n    publicId,\n    systemId\n  });\n}","map":{"version":3,"names":["parse5","require","sax","attributes","DocumentType","JSDOMParse5Adapter","HTML_NS","OpenElementStack","originalPop","prototype","pop","before","items","stackTop","_len","arguments","length","args","Array","_key","apply","_poppedOffStackOfOpenElements","originalPush","push","_len2","_key2","after","_pushedOnStackOfOpenElements","module","exports","HTMLToDOM","constructor","parsingMode","parser","appendToNode","html","node","String","_doParse","appendToDocument","documentImpl","_parseOptions","_parseWithParse5","_parseWithSax","isFragment","contextNode","options","undefined","adapter","_ownerDocument","treeAdapter","fragment","parseFragment","_templateContents","appendChild","parse","SaxParser","xmlns","strictEntities","noscript","looseCase","openStack","ontext","text","setChildForSax","type","data","oncdata","cdata","onopentag","arg","attrs","Object","keys","map","key","rawAttribute","prefix","localName","local","namespace","uri","name","value","tag","elem","onclosetag","onscript","scriptText","children","oncomment","comment","onprocessinginstruction","pi","body","ondoctype","dt","entityMatcher","result","exec","ENTITIES","onerror","err","write","close","parentImpl","currentDocument","newNode","isTemplateContents","_createElementWithCorrectElementInterface","_prefix","_namespaceURI","tagName","createTextNode","createCDATASection","createComment","toLowerCase","slice","createProcessingInstruction","substring","parseDocType","a","setAttributeValue","c","HTML5_DOCTYPE","PUBLIC_DOCTYPE","SYSTEM_DOCTYPE","doc","test","createDocumentTypeInternal","publicPieces","systemPieces","ownerDocument","publicId","systemId","createImpl"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/browser/htmltodom.js"],"sourcesContent":["\"use strict\";\n\nconst parse5 = require(\"parse5\");\nconst sax = require(\"sax\");\nconst attributes = require(\"../living/attributes\");\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst JSDOMParse5Adapter = require(\"./parse5-adapter-parsing\");\nconst { HTML_NS } = require(\"../living/helpers/namespaces\");\n\n// Horrible monkey-patch to implement https://github.com/inikulin/parse5/issues/237\nconst OpenElementStack = require(\"parse5/lib/parser/open_element_stack\");\nconst originalPop = OpenElementStack.prototype.pop;\nOpenElementStack.prototype.pop = function (...args) {\n  const before = this.items[this.stackTop];\n  originalPop.apply(this, args);\n  if (before._poppedOffStackOfOpenElements) {\n    before._poppedOffStackOfOpenElements();\n  }\n};\n\nconst originalPush = OpenElementStack.prototype.push;\nOpenElementStack.prototype.push = function (...args) {\n  originalPush.apply(this, args);\n  const after = this.items[this.stackTop];\n  if (after._pushedOnStackOfOpenElements) {\n    after._pushedOnStackOfOpenElements();\n  }\n};\n\nmodule.exports = class HTMLToDOM {\n  constructor(parsingMode) {\n    this.parser = parsingMode === \"xml\" ? sax : parse5;\n  }\n\n  appendToNode(html, node) {\n    html = String(html);\n\n    return this._doParse(html, true, node);\n  }\n\n  appendToDocument(html, documentImpl) {\n    html = String(html);\n\n    return this._doParse(html, false, documentImpl, documentImpl._parseOptions);\n  }\n\n  _doParse(...args) {\n    return this.parser === parse5 ? this._parseWithParse5(...args) : this._parseWithSax(...args);\n  }\n\n  _parseWithParse5(html, isFragment, contextNode, options = {}) {\n    const adapter = new JSDOMParse5Adapter(contextNode._ownerDocument || contextNode);\n    options.treeAdapter = adapter;\n\n    if (isFragment) {\n      const fragment = this.parser.parseFragment(contextNode, html, options);\n\n      if (contextNode._templateContents) {\n        contextNode._templateContents.appendChild(fragment);\n      } else {\n        contextNode.appendChild(fragment);\n      }\n    } else {\n      this.parser.parse(html, options);\n    }\n\n    return contextNode;\n  }\n\n  _parseWithSax(html, isFragment, contextNode) {\n    const SaxParser = this.parser.parser;\n    const parser = new SaxParser(/* strict = */true, { xmlns: true, strictEntities: true });\n    parser.noscript = false;\n    parser.looseCase = \"toString\";\n    const openStack = [contextNode];\n    parser.ontext = text => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"text\",\n        data: text\n      });\n    };\n    parser.oncdata = cdata => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"cdata\",\n        data: cdata\n      });\n    };\n    parser.onopentag = arg => {\n      const attrs = Object.keys(arg.attributes).map(key => {\n        const rawAttribute = arg.attributes[key];\n\n        let { prefix } = rawAttribute;\n        let localName = rawAttribute.local;\n        if (prefix === \"xmlns\" && localName === \"\") {\n          // intended weirdness in node-sax, see https://github.com/isaacs/sax-js/issues/165\n          localName = prefix;\n          prefix = null;\n        }\n\n        if (prefix === \"\") {\n          prefix = null;\n        }\n\n        const namespace = rawAttribute.uri === \"\" ? null : rawAttribute.uri;\n\n        return { name: rawAttribute.name, value: rawAttribute.value, prefix, localName, namespace };\n      });\n      const tag = {\n        type: \"tag\",\n        name: arg.local,\n        prefix: arg.prefix,\n        namespace: arg.uri,\n        attributes: attrs\n      };\n\n      if (arg.local === \"script\" && arg.uri === HTML_NS) {\n        openStack.push(tag);\n      } else {\n        const elem = setChildForSax(openStack[openStack.length - 1], tag);\n        openStack.push(elem);\n      }\n    };\n    parser.onclosetag = () => {\n      const elem = openStack.pop();\n      if (elem.constructor.name === \"Object\") { // we have an empty script tag\n        setChildForSax(openStack[openStack.length - 1], elem);\n      }\n    };\n    parser.onscript = scriptText => {\n      const tag = openStack.pop();\n      tag.children = [{ type: \"text\", data: scriptText }];\n      const elem = setChildForSax(openStack[openStack.length - 1], tag);\n      openStack.push(elem);\n    };\n    parser.oncomment = comment => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"comment\",\n        data: comment\n      });\n    };\n    parser.onprocessinginstruction = pi => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"?\" + pi.name,\n        data: \"?\" + pi.name + \" \" + pi.body + \"?\"\n      });\n    };\n    parser.ondoctype = dt => {\n      setChildForSax(openStack[openStack.length - 1], {\n        type: \"directive\",\n        name: \"!doctype\",\n        data: \"!doctype \" + dt\n      });\n\n      const entityMatcher = /<!ENTITY ([^ ]+) \"([^\"]+)\">/g;\n      let result;\n      while ((result = entityMatcher.exec(dt))) {\n        const [, name, value] = result;\n        if (!(name in parser.ENTITIES)) {\n          parser.ENTITIES[name] = value;\n        }\n      }\n    };\n\n    parser.onerror = err => {\n      throw err;\n    };\n    parser.write(html).close();\n  }\n};\n\nfunction setChildForSax(parentImpl, node) {\n  const currentDocument = (parentImpl && parentImpl._ownerDocument) || parentImpl;\n\n  let newNode;\n  let isTemplateContents = false;\n  switch (node.type) {\n    case \"tag\":\n    case \"script\":\n    case \"style\":\n      newNode = currentDocument._createElementWithCorrectElementInterface(node.name, node.namespace);\n      newNode._prefix = node.prefix || null;\n      newNode._namespaceURI = node.namespace || null;\n      break;\n\n    case \"root\":\n      // If we are in <template> then add all children to the parent's _templateContents; skip this virtual root node.\n      if (parentImpl.tagName === \"TEMPLATE\" && parentImpl._namespaceURI === HTML_NS) {\n        newNode = parentImpl._templateContents;\n        isTemplateContents = true;\n      }\n      break;\n\n    case \"text\":\n      // HTML entities should already be decoded by the parser, so no need to decode them\n      newNode = currentDocument.createTextNode(node.data);\n      break;\n\n    case \"cdata\":\n      newNode = currentDocument.createCDATASection(node.data);\n      break;\n\n    case \"comment\":\n      newNode = currentDocument.createComment(node.data);\n      break;\n\n    case \"directive\":\n      if (node.name[0] === \"?\" && node.name.toLowerCase() !== \"?xml\") {\n        const data = node.data.slice(node.name.length + 1, -1);\n        newNode = currentDocument.createProcessingInstruction(node.name.substring(1), data);\n      } else if (node.name.toLowerCase() === \"!doctype\") {\n        newNode = parseDocType(currentDocument, \"<\" + node.data + \">\");\n      }\n      break;\n  }\n\n  if (!newNode) {\n    return null;\n  }\n\n  if (node.attributes) {\n    for (const a of node.attributes) {\n      attributes.setAttributeValue(newNode, a.localName, a.value, a.prefix, a.namespace);\n    }\n  }\n\n  if (node.children) {\n    for (let c = 0; c < node.children.length; c++) {\n      setChildForSax(newNode, node.children[c]);\n    }\n  }\n\n  if (!isTemplateContents) {\n    if (parentImpl._templateContents) {\n      // Setting innerHTML on a <template>\n      parentImpl._templateContents.appendChild(newNode);\n    } else {\n      parentImpl.appendChild(newNode);\n    }\n  }\n\n  return newNode;\n}\n\nconst HTML5_DOCTYPE = /<!doctype html>/i;\nconst PUBLIC_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+public\\s+\"([^\"]+)\"\\s+\"([^\"]+)\"/i;\nconst SYSTEM_DOCTYPE = /<!doctype\\s+([^\\s]+)\\s+system\\s+\"([^\"]+)\"/i;\n\nfunction parseDocType(doc, html) {\n  if (HTML5_DOCTYPE.test(html)) {\n    return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n  }\n\n  const publicPieces = PUBLIC_DOCTYPE.exec(html);\n  if (publicPieces) {\n    return createDocumentTypeInternal(doc, publicPieces[1], publicPieces[2], publicPieces[3]);\n  }\n\n  const systemPieces = SYSTEM_DOCTYPE.exec(html);\n  if (systemPieces) {\n    return createDocumentTypeInternal(doc, systemPieces[1], \"\", systemPieces[2]);\n  }\n\n  // Shouldn't get here (the parser shouldn't let us know about invalid doctypes), but our logic likely isn't\n  // real-world perfect, so let's fallback.\n  return createDocumentTypeInternal(doc, \"html\", \"\", \"\");\n}\n\nfunction createDocumentTypeInternal(ownerDocument, name, publicId, systemId) {\n  return DocumentType.createImpl([], { ownerDocument, name, publicId, systemId });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}