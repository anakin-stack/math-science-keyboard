{"ast":null,"code":"\"use strict\";\n\nconst attributes = require(\"./attributes\");\nconst {\n  cloningSteps,\n  domSymbolTree\n} = require(\"./helpers/internal-constants\");\nconst NODE_TYPE = require(\"./node-type\");\nconst orderedSetParse = require(\"./helpers/ordered-set\").parse;\nconst {\n  asciiCaseInsensitiveMatch,\n  asciiLowercase\n} = require(\"./helpers/strings\");\nconst {\n  HTML_NS,\n  XMLNS_NS\n} = require(\"./helpers/namespaces\");\nconst HTMLCollection = require(\"./generated/HTMLCollection\");\nmodule.exports.clone = function (node, document, cloneChildren) {\n  if (document === undefined) {\n    document = node._ownerDocument;\n  }\n  let copy;\n  switch (node.nodeType) {\n    case NODE_TYPE.DOCUMENT_NODE:\n      // Can't use a simple Document.createImpl because of circular dependency issues :-/\n      copy = document.implementation.createDocument(null, \"\", null);\n      copy._encoding = node._encoding;\n      copy.contentType = node.contentType;\n      copy._URL = node._URL;\n      copy.origin = node.origin;\n      copy._parsingMode = node._parsingMode;\n      break;\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      copy = document.implementation.createDocumentType(node.name, node.publicId, node.systemId);\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      copy = document._createElementWithCorrectElementInterface(node._localName, node._namespaceURI);\n      copy._prefix = node._prefix;\n      attributes.copyAttributeList(node, copy);\n      break;\n    case NODE_TYPE.TEXT_NODE:\n      copy = document.createTextNode(node._data);\n      break;\n    case NODE_TYPE.CDATA_SECTION_NODE:\n      copy = document.createCDATASection(node._data);\n      break;\n    case NODE_TYPE.COMMENT_NODE:\n      copy = document.createComment(node._data);\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      copy = document.createProcessingInstruction(node.target, node._data);\n      break;\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      copy = document.createDocumentFragment();\n      break;\n  }\n  if (node[cloningSteps]) {\n    node[cloningSteps](copy, node, document, cloneChildren);\n  }\n  if (cloneChildren) {\n    for (const child of domSymbolTree.childrenIterator(node)) {\n      const childCopy = module.exports.clone(child, document, true);\n      copy.appendChild(childCopy);\n    }\n  }\n  return copy;\n};\n\n// For the following, memoization is not applied here since the memoized results are stored on `this`.\n\nmodule.exports.listOfElementsWithClassNames = (classNames, root) => {\n  // https://dom.spec.whatwg.org/#concept-getElementsByClassName\n\n  const classes = orderedSetParse(classNames);\n  if (classes.size === 0) {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => []\n    });\n  }\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => {\n      const isQuirksMode = root._ownerDocument.compatMode === \"BackCompat\";\n      return domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n          const {\n            classList\n          } = node;\n          if (isQuirksMode) {\n            for (const className of classes) {\n              if (!classList.tokenSet.some(cur => asciiCaseInsensitiveMatch(cur, className))) {\n                return false;\n              }\n            }\n          } else {\n            for (const className of classes) {\n              if (!classList.tokenSet.contains(className)) {\n                return false;\n              }\n            }\n          }\n          return true;\n        }\n      });\n    }\n  });\n};\nmodule.exports.listOfElementsWithQualifiedName = (qualifiedName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagname\n\n  if (qualifiedName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter: node => node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root\n      })\n    });\n  }\n  if (root._ownerDocument._parsingMode === \"html\") {\n    const lowerQualifiedName = asciiLowercase(qualifiedName);\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n          if (node._namespaceURI === HTML_NS) {\n            return node._qualifiedName === lowerQualifiedName;\n          }\n          return node._qualifiedName === qualifiedName;\n        }\n      })\n    });\n  }\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => domSymbolTree.treeToArray(root, {\n      filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n        return node._qualifiedName === qualifiedName;\n      }\n    })\n  });\n};\nmodule.exports.listOfElementsWithNamespaceAndLocalName = (namespace, localName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagnamens\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n  if (namespace === \"*\" && localName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter: node => node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root\n      })\n    });\n  }\n  if (namespace === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n          return node._localName === localName;\n        }\n      })\n    });\n  }\n  if (localName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n          return node._namespaceURI === namespace;\n        }\n      })\n    });\n  }\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => domSymbolTree.treeToArray(root, {\n      filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n        return node._localName === localName && node._namespaceURI === namespace;\n      }\n    })\n  });\n};\n\n// https://dom.spec.whatwg.org/#converting-nodes-into-a-node\n// create a fragment (or just return a node for one item)\nexports.convertNodesIntoNode = (document, nodes) => {\n  if (nodes.length === 1) {\n    // note: I'd prefer to check instanceof Node rather than string\n    return typeof nodes[0] === \"string\" ? document.createTextNode(nodes[0]) : nodes[0];\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < nodes.length; i++) {\n    fragment.appendChild(typeof nodes[i] === \"string\" ? document.createTextNode(nodes[i]) : nodes[i]);\n  }\n  return fragment;\n};\n\n// https://dom.spec.whatwg.org/#locate-a-namespace-prefix\nexports.locateNamespacePrefix = (element, namespace) => {\n  if (element._namespaceURI === namespace && element._prefix !== null) {\n    return element._prefix;\n  }\n  for (const attribute of element._attributeList) {\n    if (attribute._namespacePrefix === \"xmlns\" && attribute._value === namespace) {\n      return attribute._localName;\n    }\n  }\n  if (element.parentElement !== null) {\n    return exports.locateNamespacePrefix(element.parentElement, namespace);\n  }\n  return null;\n};\n\n// https://dom.spec.whatwg.org/#locate-a-namespace\nexports.locateNamespace = (node, prefix) => {\n  switch (node.nodeType) {\n    case NODE_TYPE.ELEMENT_NODE:\n      {\n        if (node._namespaceURI !== null && node._prefix === prefix) {\n          return node._namespaceURI;\n        }\n        if (prefix === null) {\n          for (const attribute of node._attributeList) {\n            if (attribute._namespace === XMLNS_NS && attribute._namespacePrefix === null && attribute._localName === \"xmlns\") {\n              return attribute._value !== \"\" ? attribute._value : null;\n            }\n          }\n        } else {\n          for (const attribute of node._attributeList) {\n            if (attribute._namespace === XMLNS_NS && attribute._namespacePrefix === \"xmlns\" && attribute._localName === prefix) {\n              return attribute._value !== \"\" ? attribute._value : null;\n            }\n          }\n        }\n        if (node.parentElement === null) {\n          return null;\n        }\n        return exports.locateNamespace(node.parentElement, prefix);\n      }\n    case NODE_TYPE.DOCUMENT_NODE:\n      {\n        if (node.documentElement === null) {\n          return null;\n        }\n        return exports.locateNamespace(node.documentElement, prefix);\n      }\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      {\n        return null;\n      }\n    case NODE_TYPE.ATTRIBUTE_NODE:\n      {\n        if (node._element === null) {\n          return null;\n        }\n        return exports.locateNamespace(node._element, prefix);\n      }\n    default:\n      {\n        if (node.parentElement === null) {\n          return null;\n        }\n        return exports.locateNamespace(node.parentElement, prefix);\n      }\n  }\n};","map":{"version":3,"names":["attributes","require","cloningSteps","domSymbolTree","NODE_TYPE","orderedSetParse","parse","asciiCaseInsensitiveMatch","asciiLowercase","HTML_NS","XMLNS_NS","HTMLCollection","module","exports","clone","node","document","cloneChildren","undefined","_ownerDocument","copy","nodeType","DOCUMENT_NODE","implementation","createDocument","_encoding","contentType","_URL","origin","_parsingMode","DOCUMENT_TYPE_NODE","createDocumentType","name","publicId","systemId","ELEMENT_NODE","_createElementWithCorrectElementInterface","_localName","_namespaceURI","_prefix","copyAttributeList","TEXT_NODE","createTextNode","_data","CDATA_SECTION_NODE","createCDATASection","COMMENT_NODE","createComment","PROCESSING_INSTRUCTION_NODE","createProcessingInstruction","target","DOCUMENT_FRAGMENT_NODE","createDocumentFragment","child","childrenIterator","childCopy","appendChild","listOfElementsWithClassNames","classNames","root","classes","size","createImpl","element","query","isQuirksMode","compatMode","treeToArray","filter","classList","className","tokenSet","some","cur","contains","listOfElementsWithQualifiedName","qualifiedName","lowerQualifiedName","_qualifiedName","listOfElementsWithNamespaceAndLocalName","namespace","localName","convertNodesIntoNode","nodes","length","fragment","i","locateNamespacePrefix","attribute","_attributeList","_namespacePrefix","_value","parentElement","locateNamespace","prefix","_namespace","documentElement","ATTRIBUTE_NODE","_element"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/node.js"],"sourcesContent":["\"use strict\";\nconst attributes = require(\"./attributes\");\nconst { cloningSteps, domSymbolTree } = require(\"./helpers/internal-constants\");\nconst NODE_TYPE = require(\"./node-type\");\nconst orderedSetParse = require(\"./helpers/ordered-set\").parse;\nconst { asciiCaseInsensitiveMatch, asciiLowercase } = require(\"./helpers/strings\");\nconst { HTML_NS, XMLNS_NS } = require(\"./helpers/namespaces\");\nconst HTMLCollection = require(\"./generated/HTMLCollection\");\n\nmodule.exports.clone = function (node, document, cloneChildren) {\n  if (document === undefined) {\n    document = node._ownerDocument;\n  }\n\n  let copy;\n  switch (node.nodeType) {\n    case NODE_TYPE.DOCUMENT_NODE:\n      // Can't use a simple Document.createImpl because of circular dependency issues :-/\n      copy = document.implementation.createDocument(null, \"\", null);\n      copy._encoding = node._encoding;\n      copy.contentType = node.contentType;\n      copy._URL = node._URL;\n      copy.origin = node.origin;\n      copy._parsingMode = node._parsingMode;\n      break;\n\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      copy = document.implementation.createDocumentType(node.name, node.publicId, node.systemId);\n      break;\n\n    case NODE_TYPE.ELEMENT_NODE:\n      copy = document._createElementWithCorrectElementInterface(node._localName, node._namespaceURI);\n      copy._prefix = node._prefix;\n      attributes.copyAttributeList(node, copy);\n      break;\n\n    case NODE_TYPE.TEXT_NODE:\n      copy = document.createTextNode(node._data);\n      break;\n\n    case NODE_TYPE.CDATA_SECTION_NODE:\n      copy = document.createCDATASection(node._data);\n      break;\n\n    case NODE_TYPE.COMMENT_NODE:\n      copy = document.createComment(node._data);\n      break;\n\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      copy = document.createProcessingInstruction(node.target, node._data);\n      break;\n\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      copy = document.createDocumentFragment();\n      break;\n  }\n\n  if (node[cloningSteps]) {\n    node[cloningSteps](copy, node, document, cloneChildren);\n  }\n\n  if (cloneChildren) {\n    for (const child of domSymbolTree.childrenIterator(node)) {\n      const childCopy = module.exports.clone(child, document, true);\n      copy.appendChild(childCopy);\n    }\n  }\n\n  return copy;\n};\n\n// For the following, memoization is not applied here since the memoized results are stored on `this`.\n\nmodule.exports.listOfElementsWithClassNames = (classNames, root) => {\n  // https://dom.spec.whatwg.org/#concept-getElementsByClassName\n\n  const classes = orderedSetParse(classNames);\n\n  if (classes.size === 0) {\n    return HTMLCollection.createImpl([], { element: root, query: () => [] });\n  }\n\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => {\n      const isQuirksMode = root._ownerDocument.compatMode === \"BackCompat\";\n\n      return domSymbolTree.treeToArray(root, { filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        const { classList } = node;\n        if (isQuirksMode) {\n          for (const className of classes) {\n            if (!classList.tokenSet.some(cur => asciiCaseInsensitiveMatch(cur, className))) {\n              return false;\n            }\n          }\n        } else {\n          for (const className of classes) {\n            if (!classList.tokenSet.contains(className)) {\n              return false;\n            }\n          }\n        }\n\n        return true;\n      } });\n    }\n  });\n};\n\nmodule.exports.listOfElementsWithQualifiedName = (qualifiedName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagname\n\n  if (qualifiedName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter: node => node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root\n      })\n    });\n  }\n\n  if (root._ownerDocument._parsingMode === \"html\") {\n    const lowerQualifiedName = asciiLowercase(qualifiedName);\n\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n\n          if (node._namespaceURI === HTML_NS) {\n            return node._qualifiedName === lowerQualifiedName;\n          }\n\n          return node._qualifiedName === qualifiedName;\n        }\n      })\n    });\n  }\n\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => domSymbolTree.treeToArray(root, {\n      filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._qualifiedName === qualifiedName;\n      }\n    })\n  });\n};\n\nmodule.exports.listOfElementsWithNamespaceAndLocalName = (namespace, localName, root) => {\n  // https://dom.spec.whatwg.org/#concept-getelementsbytagnamens\n\n  if (namespace === \"\") {\n    namespace = null;\n  }\n\n  if (namespace === \"*\" && localName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter: node => node.nodeType === NODE_TYPE.ELEMENT_NODE && node !== root\n      })\n    });\n  }\n\n  if (namespace === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n\n          return node._localName === localName;\n        }\n      })\n    });\n  }\n\n  if (localName === \"*\") {\n    return HTMLCollection.createImpl([], {\n      element: root,\n      query: () => domSymbolTree.treeToArray(root, {\n        filter(node) {\n          if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n            return false;\n          }\n\n          return node._namespaceURI === namespace;\n        }\n      })\n    });\n  }\n\n  return HTMLCollection.createImpl([], {\n    element: root,\n    query: () => domSymbolTree.treeToArray(root, {\n      filter(node) {\n        if (node.nodeType !== NODE_TYPE.ELEMENT_NODE || node === root) {\n          return false;\n        }\n\n        return node._localName === localName && node._namespaceURI === namespace;\n      }\n    })\n  });\n};\n\n// https://dom.spec.whatwg.org/#converting-nodes-into-a-node\n// create a fragment (or just return a node for one item)\nexports.convertNodesIntoNode = (document, nodes) => {\n  if (nodes.length === 1) { // note: I'd prefer to check instanceof Node rather than string\n    return typeof nodes[0] === \"string\" ? document.createTextNode(nodes[0]) : nodes[0];\n  }\n  const fragment = document.createDocumentFragment();\n  for (let i = 0; i < nodes.length; i++) {\n    fragment.appendChild(typeof nodes[i] === \"string\" ? document.createTextNode(nodes[i]) : nodes[i]);\n  }\n  return fragment;\n};\n\n// https://dom.spec.whatwg.org/#locate-a-namespace-prefix\nexports.locateNamespacePrefix = (element, namespace) => {\n  if (element._namespaceURI === namespace && element._prefix !== null) {\n    return element._prefix;\n  }\n\n  for (const attribute of element._attributeList) {\n    if (attribute._namespacePrefix === \"xmlns\" && attribute._value === namespace) {\n      return attribute._localName;\n    }\n  }\n\n  if (element.parentElement !== null) {\n    return exports.locateNamespacePrefix(element.parentElement, namespace);\n  }\n\n  return null;\n};\n\n// https://dom.spec.whatwg.org/#locate-a-namespace\nexports.locateNamespace = (node, prefix) => {\n  switch (node.nodeType) {\n    case NODE_TYPE.ELEMENT_NODE: {\n      if (node._namespaceURI !== null && node._prefix === prefix) {\n        return node._namespaceURI;\n      }\n\n      if (prefix === null) {\n        for (const attribute of node._attributeList) {\n          if (attribute._namespace === XMLNS_NS &&\n              attribute._namespacePrefix === null &&\n              attribute._localName === \"xmlns\") {\n            return attribute._value !== \"\" ? attribute._value : null;\n          }\n        }\n      } else {\n        for (const attribute of node._attributeList) {\n          if (attribute._namespace === XMLNS_NS &&\n              attribute._namespacePrefix === \"xmlns\" &&\n              attribute._localName === prefix) {\n            return attribute._value !== \"\" ? attribute._value : null;\n          }\n        }\n      }\n\n      if (node.parentElement === null) {\n        return null;\n      }\n\n      return exports.locateNamespace(node.parentElement, prefix);\n    }\n\n    case NODE_TYPE.DOCUMENT_NODE: {\n      if (node.documentElement === null) {\n        return null;\n      }\n\n      return exports.locateNamespace(node.documentElement, prefix);\n    }\n\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n    case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n      return null;\n    }\n\n    case NODE_TYPE.ATTRIBUTE_NODE: {\n      if (node._element === null) {\n        return null;\n      }\n\n      return exports.locateNamespace(node._element, prefix);\n    }\n\n    default: {\n      if (node.parentElement === null) {\n        return null;\n      }\n\n      return exports.locateNamespace(node.parentElement, prefix);\n    }\n  }\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}