{"ast":null,"code":"\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst {\n  domSymbolTree\n} = require(\"../helpers/internal-constants\");\nconst {\n  simultaneousIterators\n} = require(\"../../utils\");\nconst DOMException = require(\"domexception\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst NodeList = require(\"../generated/NodeList\");\nconst {\n  documentBaseURLSerialized\n} = require(\"../helpers/document-base-url\");\nconst {\n  clone,\n  locateNamespacePrefix,\n  locateNamespace\n} = require(\"../node\");\nconst attributes = require(\"../attributes\");\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE || node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE || node.nodeType === NODE_TYPE.NOTATION_NODE ||\n  //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n  node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId || a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName || a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n  return true;\n}\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n    domSymbolTree.initialize(this);\n    this._ownerDocument = privateData.ownerDocument;\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n  getRootNode() {\n    // ignore option for composed, because of no Shadow DOM support\n    let root;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      root = ancestor;\n    }\n    return root;\n  }\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n  get isConnected() {\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      if (ancestor.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n    return this._childNodesList;\n  }\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n  insertBefore(newChildImpl, refChildImpl) {\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n        }\n      }\n    }\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while (grandChildImpl = domSymbolTree.firstChild(newChildImpl)) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl);\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n        }\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n      this._modified();\n      if (newChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n      this._descendantAdded(this, newChildImpl);\n    }\n    return newChildImpl;\n  } // raises(DOMException);\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n  replaceChild(node, child) {\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n  _attach() {\n    this._attached = true;\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n  _detach() {\n    this._attached = false;\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n  removeChild( /* Node */oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(oldChildImpl);\n    }\n    domSymbolTree.remove(oldChildImpl);\n    this._modified();\n    oldChildImpl._detach();\n    this._descendantRemoved(this, oldChildImpl);\n    if (oldChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n    return oldChildImpl;\n  } // raises(DOMException);\n\n  appendChild(newChild) {\n    return this.insertBefore(newChild, null);\n  }\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Normalize should only transform Text nodes, and nothing else.\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n      const prevChild = domSymbolTree.previousSibling(child);\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC | NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n    return result;\n  }\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          return locateNamespacePrefix(this, namespace);\n        }\n      case NODE_TYPE.DOCUMENT_NODE:\n        {\n          return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n        }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        {\n          return null;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n        }\n      default:\n        {\n          return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n        }\n    }\n  }\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n    return locateNamespace(this, prefix);\n  }\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n    return nodeEquals(this, node);\n  }\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n    return false;\n  }\n  cloneNode(deep) {\n    deep = Boolean(deep);\n    return clone(this, undefined, deep);\n  }\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n      default:\n        {\n          return null;\n        }\n    }\n  }\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let text = \"\";\n          for (const child of domSymbolTree.treeIterator(this)) {\n            if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n              text += child.nodeValue;\n            }\n          }\n          return text;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          return this._value;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          return this._data;\n        }\n      default:\n        {\n          return null;\n        }\n    }\n  }\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE:\n        {\n          let child = domSymbolTree.firstChild(this);\n          while (child) {\n            this.removeChild(child);\n            child = domSymbolTree.firstChild(this);\n          }\n          if (value !== null && value !== \"\") {\n            this.appendChild(this._ownerDocument.createTextNode(value));\n          }\n          break;\n        }\n      case NODE_TYPE.ATTRIBUTE_NODE:\n        {\n          attributes.setAnExistingAttributeValue(this, value);\n          break;\n        }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE:\n        {\n          this.replaceData(0, this.length, value);\n          break;\n        }\n    }\n  }\n}\nmodule.exports = {\n  implementation: NodeImpl\n};","map":{"version":3,"names":["EventTargetImpl","require","implementation","domSymbolTree","simultaneousIterators","DOMException","NODE_TYPE","NODE_DOCUMENT_POSITION","NodeList","documentBaseURLSerialized","clone","locateNamespacePrefix","locateNamespace","attributes","isObsoleteNodeType","node","nodeType","ENTITY_NODE","ENTITY_REFERENCE_NODE","NOTATION_NODE","CDATA_SECTION_NODE","nodeEquals","a","b","DOCUMENT_TYPE_NODE","name","publicId","systemId","ELEMENT_NODE","_namespaceURI","_prefix","_localName","_attributes","length","PROCESSING_INSTRUCTION_NODE","_target","_data","TEXT_NODE","COMMENT_NODE","attributeListsEqual","nodes","childrenIterator","NodeImpl","constructor","args","privateData","initialize","_ownerDocument","ownerDocument","_childNodesList","_childrenList","_version","_memoizedQueries","parentNode","parent","getRootNode","root","ancestor","ancestorsIterator","nodeName","tagName","target","DOCUMENT_NODE","DOCUMENT_FRAGMENT_NODE","firstChild","isConnected","lastChild","childNodes","createImpl","element","query","childrenToArray","_update","nextSibling","previousSibling","insertBefore","newChildImpl","refChildImpl","ATTRIBUTE_NODE","adoptNode","grandChildImpl","removeChild","oldParentImpl","appendChild","_modified","_childTextContentChangeSteps","_attached","_attach","_descendantAdded","_clearMemoizedQueries","myParent","_descendantRemoved","child","replaceChild","_detach","_lastFocusedElement","oldChildImpl","_runPreRemovingSteps","remove","newChild","hasChildNodes","hasChildren","normalize","nodeValue","prevChild","appendData","parentElement","baseURI","compareDocumentPosition","otherImpl","reference","Error","result","compareTreePosition","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","DOCUMENT_POSITION_FOLLOWING","lookupPrefix","namespace","documentElement","_element","lookupNamespaceURI","prefix","isDefaultNamespace","defaultNamespace","contains","other","Boolean","DOCUMENT_POSITION_CONTAINED_BY","isEqualNode","isSameNode","cloneNode","deep","undefined","_value","value","setAnExistingAttributeValue","replaceData","textContent","text","treeIterator","createTextNode","module","exports"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/nodes/Node-impl.js"],"sourcesContent":["\"use strict\";\n\nconst EventTargetImpl = require(\"../events/EventTarget-impl\").implementation;\nconst { domSymbolTree } = require(\"../helpers/internal-constants\");\nconst { simultaneousIterators } = require(\"../../utils\");\nconst DOMException = require(\"domexception\");\nconst NODE_TYPE = require(\"../node-type\");\nconst NODE_DOCUMENT_POSITION = require(\"../node-document-position\");\nconst NodeList = require(\"../generated/NodeList\");\nconst { documentBaseURLSerialized } = require(\"../helpers/document-base-url\");\nconst { clone, locateNamespacePrefix, locateNamespace } = require(\"../node\");\nconst attributes = require(\"../attributes\");\n\nfunction isObsoleteNodeType(node) {\n  return node.nodeType === NODE_TYPE.ENTITY_NODE ||\n    node.nodeType === NODE_TYPE.ENTITY_REFERENCE_NODE ||\n    node.nodeType === NODE_TYPE.NOTATION_NODE ||\n  //  node.nodeType === NODE_TYPE.ATTRIBUTE_NODE ||  // this is missing how do we handle?\n    node.nodeType === NODE_TYPE.CDATA_SECTION_NODE;\n}\n\nfunction nodeEquals(a, b) {\n  if (a.nodeType !== b.nodeType) {\n    return false;\n  }\n\n  switch (a.nodeType) {\n    case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      if (a.name !== b.name || a.publicId !== b.publicId ||\n          a.systemId !== b.systemId) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.ELEMENT_NODE:\n      if (a._namespaceURI !== b._namespaceURI || a._prefix !== b._prefix || a._localName !== b._localName ||\n          a._attributes.length !== b._attributes.length) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      if (a._target !== b._target || a._data !== b._data) {\n        return false;\n      }\n      break;\n    case NODE_TYPE.TEXT_NODE:\n    case NODE_TYPE.COMMENT_NODE:\n      if (a._data !== b._data) {\n        return false;\n      }\n      break;\n  }\n\n  if (a.nodeType === NODE_TYPE.ELEMENT_NODE && !attributes.attributeListsEqual(a, b)) {\n    return false;\n  }\n\n  for (const nodes of simultaneousIterators(domSymbolTree.childrenIterator(a), domSymbolTree.childrenIterator(b))) {\n    if (!nodes[0] || !nodes[1]) {\n      // mismatch in the amount of childNodes\n      return false;\n    }\n\n    if (!nodeEquals(nodes[0], nodes[1])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nclass NodeImpl extends EventTargetImpl {\n  constructor(args, privateData) {\n    super();\n\n    domSymbolTree.initialize(this);\n\n    this._ownerDocument = privateData.ownerDocument;\n\n    this._childNodesList = null;\n    this._childrenList = null;\n    this._version = 0;\n    this._memoizedQueries = {};\n  }\n\n  get parentNode() {\n    return domSymbolTree.parent(this);\n  }\n\n  getRootNode() {\n    // ignore option for composed, because of no Shadow DOM support\n    let root;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      root = ancestor;\n    }\n    return root;\n  }\n\n  get nodeName() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE:\n        return this.tagName;\n      case NODE_TYPE.TEXT_NODE:\n        return \"#text\";\n      case NODE_TYPE.CDATA_SECTION_NODE:\n        return \"#cdata-section\";\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n        return this.target;\n      case NODE_TYPE.COMMENT_NODE:\n        return \"#comment\";\n      case NODE_TYPE.DOCUMENT_NODE:\n        return \"#document\";\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n        return this.name;\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n        return \"#document-fragment\";\n    }\n\n    // should never happen\n    return null;\n  }\n\n  get firstChild() {\n    return domSymbolTree.firstChild(this);\n  }\n\n  get isConnected() {\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      if (ancestor.nodeType === NODE_TYPE.DOCUMENT_NODE) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  get ownerDocument() {\n    return this.nodeType === NODE_TYPE.DOCUMENT_NODE ? null : this._ownerDocument;\n  }\n\n  get lastChild() {\n    return domSymbolTree.lastChild(this);\n  }\n\n  get childNodes() {\n    if (!this._childNodesList) {\n      this._childNodesList = NodeList.createImpl([], {\n        element: this,\n        query: () => domSymbolTree.childrenToArray(this)\n      });\n    } else {\n      this._childNodesList._update();\n    }\n\n    return this._childNodesList;\n  }\n\n  get nextSibling() {\n    return domSymbolTree.nextSibling(this);\n  }\n\n  get previousSibling() {\n    return domSymbolTree.previousSibling(this);\n  }\n\n  insertBefore(newChildImpl, refChildImpl) {\n    // DocumentType must be implicitly adopted\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_TYPE_NODE) {\n      newChildImpl._ownerDocument = this._ownerDocument;\n    }\n\n    if (newChildImpl.nodeType && newChildImpl.nodeType === NODE_TYPE.ATTRIBUTE_NODE) {\n      throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n    }\n\n    if (this._ownerDocument !== newChildImpl._ownerDocument) {\n      // adopt the node when it's not in this document\n      this._ownerDocument.adoptNode(newChildImpl);\n    } else {\n      // search for parents matching the newChild\n      for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n        if (ancestor === newChildImpl) {\n          throw new DOMException(\"The operation would yield an incorrect node tree.\", \"HierarchyRequestError\");\n        }\n      }\n    }\n\n    // fragments are merged into the element (except parser-created fragments in <template>)\n    if (newChildImpl.nodeType === NODE_TYPE.DOCUMENT_FRAGMENT_NODE) {\n      let grandChildImpl;\n      while ((grandChildImpl = domSymbolTree.firstChild(newChildImpl))) {\n        newChildImpl.removeChild(grandChildImpl);\n        this.insertBefore(grandChildImpl, refChildImpl);\n      }\n    } else if (newChildImpl === refChildImpl) {\n      return newChildImpl;\n    } else {\n      const oldParentImpl = domSymbolTree.parent(newChildImpl);\n      // if the newChild is already in the tree elsewhere, remove it first\n      if (oldParentImpl) {\n        oldParentImpl.removeChild(newChildImpl);\n      }\n\n      if (refChildImpl === null) {\n        domSymbolTree.appendChild(this, newChildImpl);\n      } else {\n        if (domSymbolTree.parent(refChildImpl) !== this) {\n          throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n        }\n\n        domSymbolTree.insertBefore(refChildImpl, newChildImpl);\n      }\n\n      this._modified();\n      if (newChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n        this._childTextContentChangeSteps();\n      }\n\n      if (this._attached && newChildImpl._attach) {\n        newChildImpl._attach();\n      }\n\n      this._descendantAdded(this, newChildImpl);\n    }\n\n    return newChildImpl;\n  } // raises(DOMException);\n\n  _modified() {\n    this._version++;\n    for (const ancestor of domSymbolTree.ancestorsIterator(this)) {\n      ancestor._version++;\n    }\n\n    if (this._childrenList) {\n      this._childrenList._update();\n    }\n    if (this._childNodesList) {\n      this._childNodesList._update();\n    }\n    this._clearMemoizedQueries();\n  }\n\n  _childTextContentChangeSteps() {\n    // Default: do nothing\n  }\n\n  _clearMemoizedQueries() {\n    this._memoizedQueries = {};\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._clearMemoizedQueries();\n    }\n  }\n\n  _descendantRemoved(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantRemoved(parent, child);\n    }\n  }\n\n  _descendantAdded(parent, child) {\n    const myParent = domSymbolTree.parent(this);\n    if (myParent) {\n      myParent._descendantAdded(parent, child);\n    }\n  }\n\n  replaceChild(node, child) {\n    this.insertBefore(node, child);\n    return this.removeChild(child);\n  }\n\n  _attach() {\n    this._attached = true;\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._attach) {\n        child._attach();\n      }\n    }\n  }\n\n  _detach() {\n    this._attached = false;\n\n    if (this._ownerDocument && this._ownerDocument._lastFocusedElement === this) {\n      this._ownerDocument._lastFocusedElement = null;\n    }\n\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child._detach) {\n        child._detach();\n      }\n    }\n  }\n\n  removeChild(/* Node */ oldChildImpl) {\n    if (!oldChildImpl || domSymbolTree.parent(oldChildImpl) !== this) {\n      throw new DOMException(\"The object can not be found here.\", \"NotFoundError\");\n    }\n\n    if (this._ownerDocument) {\n      this._ownerDocument._runPreRemovingSteps(oldChildImpl);\n    }\n    domSymbolTree.remove(oldChildImpl);\n    this._modified();\n    oldChildImpl._detach();\n    this._descendantRemoved(this, oldChildImpl);\n    if (oldChildImpl.nodeType === NODE_TYPE.TEXT_NODE) {\n      this._childTextContentChangeSteps();\n    }\n    return oldChildImpl;\n  } // raises(DOMException);\n\n  appendChild(newChild) {\n    return this.insertBefore(newChild, null);\n  }\n\n  hasChildNodes() {\n    return domSymbolTree.hasChildren(this);\n  }\n\n  normalize() {\n    for (const child of domSymbolTree.childrenIterator(this)) {\n      if (child.normalize) {\n        child.normalize();\n      }\n\n      // Normalize should only transform Text nodes, and nothing else.\n      if (child.nodeType !== NODE_TYPE.TEXT_NODE) {\n        continue;\n      }\n\n      if (child.nodeValue === \"\") {\n        this.removeChild(child);\n        continue;\n      }\n\n      const prevChild = domSymbolTree.previousSibling(child);\n\n      if (prevChild && prevChild.nodeType === NODE_TYPE.TEXT_NODE) {\n        // merge text nodes\n        prevChild.appendData(child.nodeValue);\n        this.removeChild(child);\n      }\n    }\n  }\n\n  get parentElement() {\n    const parentNode = domSymbolTree.parent(this);\n    return parentNode !== null && parentNode.nodeType === NODE_TYPE.ELEMENT_NODE ? parentNode : null;\n  }\n\n  get baseURI() {\n    return documentBaseURLSerialized(this._ownerDocument);\n  }\n\n  compareDocumentPosition(otherImpl) {\n    // Let reference be the context object.\n    const reference = this;\n\n    if (isObsoleteNodeType(reference) || isObsoleteNodeType(otherImpl)) {\n      throw new Error(\"Obsolete node type\");\n    }\n\n    const result = domSymbolTree.compareTreePosition(reference, otherImpl);\n\n    // “If other and reference are not in the same tree, return the result of adding DOCUMENT_POSITION_DISCONNECTED,\n    //  DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC, and either DOCUMENT_POSITION_PRECEDING or\n    // DOCUMENT_POSITION_FOLLOWING, with the constraint that this is to be consistent, together.”\n    if (result === NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED) {\n      // symbol-tree does not add these bits required by the spec:\n      return NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_DISCONNECTED |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC |\n        NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_FOLLOWING;\n    }\n\n    return result;\n  }\n\n  lookupPrefix(namespace) {\n    if (namespace === null || namespace === \"\") {\n      return null;\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ELEMENT_NODE: {\n        return locateNamespacePrefix(this, namespace);\n      }\n      case NODE_TYPE.DOCUMENT_NODE: {\n        return this.documentElement !== null ? locateNamespacePrefix(this.documentElement, namespace) : null;\n      }\n      case NODE_TYPE.DOCUMENT_TYPE_NODE:\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE: {\n        return null;\n      }\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._element !== null ? locateNamespacePrefix(this._element, namespace) : null;\n      }\n      default: {\n        return this.parentElement !== null ? locateNamespacePrefix(this.parentElement, namespace) : null;\n      }\n    }\n  }\n\n  lookupNamespaceURI(prefix) {\n    if (prefix === \"\") {\n      prefix = null;\n    }\n\n    return locateNamespace(this, prefix);\n  }\n\n  isDefaultNamespace(namespace) {\n    if (namespace === \"\") {\n      namespace = null;\n    }\n\n    const defaultNamespace = locateNamespace(this, null);\n    return defaultNamespace === namespace;\n  }\n\n  contains(other) {\n    if (other === null) {\n      return false;\n    } else if (this === other) {\n      return true;\n    }\n    return Boolean(this.compareDocumentPosition(other) & NODE_DOCUMENT_POSITION.DOCUMENT_POSITION_CONTAINED_BY);\n  }\n\n  isEqualNode(node) {\n    if (node === null) {\n      return false;\n    }\n\n    // Fast-path, not in the spec\n    if (this === node) {\n      return true;\n    }\n\n    return nodeEquals(this, node);\n  }\n\n  isSameNode(node) {\n    if (this === node) {\n      return true;\n    }\n\n    return false;\n  }\n\n  cloneNode(deep) {\n    deep = Boolean(deep);\n\n    return clone(this, undefined, deep);\n  }\n\n  get nodeValue() {\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set nodeValue(value) {\n    if (value === null) {\n      value = \"\";\n    }\n\n    switch (this.nodeType) {\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n\n  get textContent() {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let text = \"\";\n        for (const child of domSymbolTree.treeIterator(this)) {\n          if (child.nodeType === NODE_TYPE.TEXT_NODE || child.nodeType === NODE_TYPE.CDATA_SECTION_NODE) {\n            text += child.nodeValue;\n          }\n        }\n        return text;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        return this._value;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        return this._data;\n      }\n\n      default: {\n        return null;\n      }\n    }\n  }\n\n  set textContent(value) {\n    switch (this.nodeType) {\n      case NODE_TYPE.DOCUMENT_FRAGMENT_NODE:\n      case NODE_TYPE.ELEMENT_NODE: {\n        let child = domSymbolTree.firstChild(this);\n        while (child) {\n          this.removeChild(child);\n          child = domSymbolTree.firstChild(this);\n        }\n\n        if (value !== null && value !== \"\") {\n          this.appendChild(this._ownerDocument.createTextNode(value));\n        }\n\n        break;\n      }\n\n      case NODE_TYPE.ATTRIBUTE_NODE: {\n        attributes.setAnExistingAttributeValue(this, value);\n        break;\n      }\n\n      case NODE_TYPE.TEXT_NODE:\n      case NODE_TYPE.CDATA_SECTION_NODE: // CDATASection is a subclass of Text\n      case NODE_TYPE.PROCESSING_INSTRUCTION_NODE:\n      case NODE_TYPE.COMMENT_NODE: {\n        this.replaceData(0, this.length, value);\n        break;\n      }\n    }\n  }\n}\n\nmodule.exports = {\n  implementation: NodeImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}