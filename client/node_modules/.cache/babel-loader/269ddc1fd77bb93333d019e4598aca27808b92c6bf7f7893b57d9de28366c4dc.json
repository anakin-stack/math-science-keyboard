{"ast":null,"code":"\"use strict\";\n\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst {\n  Canvas\n} = require(\"../../utils\");\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n    return super._attrModified.apply(this, arguments);\n  }\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = new Canvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n    notImplemented(\"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n  toDataURL() {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL.apply(this._canvas, arguments);\n    }\n    notImplemented(\"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\", this._ownerDocument._defaultView);\n    return null;\n  }\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      let stream;\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          stream = canvas.createJPEGStream({\n            quality: Math.max(0, Math.min(1, qualityArgument)) * 100\n          });\n          break;\n        default:\n          // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n          type = \"image/png\";\n          stream = canvas.createPNGStream();\n      }\n      const buffers = [];\n      stream.on(\"data\", chunk => {\n        buffers.push(chunk);\n      });\n      stream.on(\"end\", () => {\n        callback(new window.Blob(buffers, {\n          type\n        }));\n      });\n    } else {\n      notImplemented(\"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\", window);\n    }\n  }\n  get width() {\n    const parsed = parseInt(this.getAttribute(\"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttribute(\"width\", String(v));\n  }\n  get height() {\n    const parsed = parseInt(this.getAttribute(\"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttribute(\"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n    return prev.apply(ctx, arguments);\n  };\n}\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};","map":{"version":3,"names":["HTMLElementImpl","require","implementation","notImplemented","idlUtils","Canvas","HTMLCanvasElementImpl","_attrModified","name","value","_canvas","parseInt","apply","arguments","_getCanvas","width","height","getContext","contextId","canvas","_context","wrapperForImpl","wrapNodeCanvasMethod","_ownerDocument","_defaultView","toDataURL","toBlob","callback","type","qualityArgument","window","stream","createJPEGStream","quality","Math","max","min","createPNGStream","buffers","on","chunk","push","Blob","parsed","getAttribute","isNaN","v","setAttribute","String","ctx","prev","image","impl","implForWrapper","_image","module","exports"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/nodes/HTMLCanvasElement-impl.js"],"sourcesContent":["\"use strict\";\nconst HTMLElementImpl = require(\"./HTMLElement-impl\").implementation;\nconst notImplemented = require(\"../../browser/not-implemented\");\nconst idlUtils = require(\"../generated/utils\");\nconst { Canvas } = require(\"../../utils\");\n\nclass HTMLCanvasElementImpl extends HTMLElementImpl {\n  _attrModified(name, value) {\n    if (this._canvas && (name === \"width\" || name === \"height\")) {\n      this._canvas[name] = parseInt(value);\n    }\n\n    return super._attrModified.apply(this, arguments);\n  }\n\n  _getCanvas() {\n    if (Canvas && !this._canvas) {\n      this._canvas = new Canvas(this.width, this.height);\n    }\n    return this._canvas;\n  }\n\n  getContext(contextId) {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      if (!this._context) {\n        this._context = canvas.getContext(contextId) || null;\n        if (this._context) {\n          // Override the native canvas reference with our wrapper. This is the\n          // reason why we need to locally cache _context, since each call to\n          // canvas.getContext(contextId) would replace this reference again.\n          // Perhaps in the longer term, a better solution would be to create a\n          // full wrapper for the Context object as well.\n          this._context.canvas = idlUtils.wrapperForImpl(this);\n          wrapNodeCanvasMethod(this._context, \"createPattern\");\n          wrapNodeCanvasMethod(this._context, \"drawImage\");\n        }\n      }\n      return this._context;\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.getContext (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toDataURL() {\n    const canvas = this._getCanvas();\n    if (canvas) {\n      return canvas.toDataURL.apply(this._canvas, arguments);\n    }\n\n    notImplemented(\n      \"HTMLCanvasElement.prototype.toDataURL (without installing the canvas npm package)\",\n      this._ownerDocument._defaultView\n    );\n    return null;\n  }\n\n  toBlob(callback, type, qualityArgument) {\n    const window = this._ownerDocument._defaultView;\n    const canvas = this._getCanvas();\n    if (canvas) {\n      let stream;\n      switch (type) {\n        case \"image/jpg\":\n        case \"image/jpeg\":\n          stream = canvas.createJPEGStream({\n            quality: Math.max(0, Math.min(1, qualityArgument)) * 100\n          });\n          break;\n        default:\n          // TODO: Patch node-canvas to receive qualityArgument for PNG stream\n          type = \"image/png\";\n          stream = canvas.createPNGStream();\n      }\n      const buffers = [];\n      stream.on(\"data\", chunk => {\n        buffers.push(chunk);\n      });\n      stream.on(\"end\", () => {\n        callback(new window.Blob(buffers, { type }));\n      });\n    } else {\n      notImplemented(\n        \"HTMLCanvasElement.prototype.toBlob (without installing the canvas npm package)\",\n        window\n      );\n    }\n  }\n\n  get width() {\n    const parsed = parseInt(this.getAttribute(\"width\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 300 : parsed;\n  }\n\n  set width(v) {\n    v = v > 2147483647 ? 300 : v;\n    this.setAttribute(\"width\", String(v));\n  }\n\n  get height() {\n    const parsed = parseInt(this.getAttribute(\"height\"));\n    return isNaN(parsed) || parsed < 0 || parsed > 2147483647 ? 150 : parsed;\n  }\n\n  set height(v) {\n    v = v > 2147483647 ? 150 : v;\n    this.setAttribute(\"height\", String(v));\n  }\n}\n\n// We need to wrap the methods that receive an image or canvas object\n// (luckily, always as the first argument), so that these objects can be\n// unwrapped an the expected types passed.\nfunction wrapNodeCanvasMethod(ctx, name) {\n  const prev = ctx[name];\n  ctx[name] = function (image) {\n    const impl = idlUtils.implForWrapper(image);\n    if (impl) {\n      arguments[0] = impl._image || impl._canvas;\n    }\n    return prev.apply(ctx, arguments);\n  };\n}\n\nmodule.exports = {\n  implementation: HTMLCanvasElementImpl\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}