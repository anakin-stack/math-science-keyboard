{"ast":null,"code":"\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\nconst impl = utils.implSymbol;\nconst IteratorPrototype = Object.create(utils.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const internal = this[utils.iterInternalSymbol];\n      const {\n        target,\n        kind,\n        index\n      } = internal;\n      const values = Array.from(target[impl]);\n      const len = values.length;\n      if (index >= len) {\n        return {\n          value: undefined,\n          done: true\n        };\n      }\n      const pair = values[index];\n      internal.index = index + 1;\n      const [key, value] = pair.map(utils.tryWrapperForImpl);\n      let result;\n      switch (kind) {\n        case \"key\":\n          result = key;\n          break;\n        case \"value\":\n          result = value;\n          break;\n        case \"key+value\":\n          result = [key, value];\n          break;\n      }\n      return {\n        value: result,\n        done: false\n      };\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  [Symbol.toStringTag]: {\n    value: \"URLSearchParamsIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\nfunction URLSearchParams() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n  if (args[0] !== undefined) {\n    if (utils.isObject(args[0])) {\n      if (args[0][Symbol.iterator] !== undefined) {\n        if (!utils.isObject(args[0])) {\n          throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \" is not an iterable object.\");\n        } else {\n          const V = [];\n          const tmp = args[0];\n          for (let nextItem of tmp) {\n            if (!utils.isObject(nextItem)) {\n              throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \"'s element\" + \" is not an iterable object.\");\n            } else {\n              const V = [];\n              const tmp = nextItem;\n              for (let nextItem of tmp) {\n                nextItem = conversions[\"USVString\"](nextItem, {\n                  context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \"'s element\" + \"'s element\"\n                });\n                V.push(nextItem);\n              }\n              nextItem = V;\n            }\n            V.push(nextItem);\n          }\n          args[0] = V;\n        }\n      } else {\n        if (!utils.isObject(args[0])) {\n          throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \" is not an object.\");\n        } else {\n          const result = Object.create(null);\n          for (const key of Reflect.ownKeys(args[0])) {\n            const desc = Object.getOwnPropertyDescriptor(args[0], key);\n            if (desc && desc.enumerable) {\n              let typedKey = key;\n              let typedValue = args[0][key];\n              typedKey = conversions[\"USVString\"](typedKey, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s key\"\n              });\n              typedValue = conversions[\"USVString\"](typedValue, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s value\"\n              });\n              result[typedKey] = typedValue;\n            }\n          }\n          args[0] = result;\n        }\n      }\n    } else {\n      args[0] = conversions[\"USVString\"](args[0], {\n        context: \"Failed to construct 'URLSearchParams': parameter 1\"\n      });\n    }\n  } else {\n    args[0] = \"\";\n  }\n  iface.setup(this, args);\n}\nObject.defineProperty(URLSearchParams, \"prototype\", {\n  value: URLSearchParams.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\nObject.defineProperty(URLSearchParams.prototype, Symbol.iterator, {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n  value: function entries() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    return module.exports.createDefaultIterator(this, \"key+value\");\n  }\n});\nURLSearchParams.prototype.forEach = function forEach(callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'forEach' on 'URLSearchParams': 1 argument required, \" + \"but only 0 present.\");\n  }\n  if (typeof callback !== \"function\") {\n    throw new TypeError(\"Failed to execute 'forEach' on 'URLSearchParams': The callback provided \" + \"as parameter 1 is not a function.\");\n  }\n  const thisArg = arguments[1];\n  let pairs = Array.from(this[impl]);\n  let i = 0;\n  while (i < pairs.length) {\n    const [key, value] = pairs[i].map(utils.tryWrapperForImpl);\n    callback.call(thisArg, value, key, this);\n    pairs = Array.from(this[impl]);\n    i++;\n  }\n};\nURLSearchParams.prototype.append = function append(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'append' on 'URLSearchParams': 2 \" + \"arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'append' on 'URLSearchParams': parameter 1\"\n  });\n  args[1] = conversions[\"USVString\"](args[1], {\n    context: \"Failed to execute 'append' on 'URLSearchParams': parameter 2\"\n  });\n  return this[impl].append(...args);\n};\nURLSearchParams.prototype.delete = function _(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'delete' on 'URLSearchParams': 1 \" + \"argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'delete' on 'URLSearchParams': parameter 1\"\n  });\n  return this[impl].delete(...args);\n};\nURLSearchParams.prototype.get = function get(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'get' on 'URLSearchParams': 1 \" + \"argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'get' on 'URLSearchParams': parameter 1\"\n  });\n  return this[impl].get(...args);\n};\nURLSearchParams.prototype.getAll = function getAll(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'getAll' on 'URLSearchParams': 1 \" + \"argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\"\n  });\n  return utils.tryWrapperForImpl(this[impl].getAll(...args));\n};\nURLSearchParams.prototype.has = function has(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\"Failed to execute 'has' on 'URLSearchParams': 1 \" + \"argument required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'has' on 'URLSearchParams': parameter 1\"\n  });\n  return this[impl].has(...args);\n};\nURLSearchParams.prototype.set = function set(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 2) {\n    throw new TypeError(\"Failed to execute 'set' on 'URLSearchParams': 2 \" + \"arguments required, but only \" + arguments.length + \" present.\");\n  }\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'set' on 'URLSearchParams': parameter 1\"\n  });\n  args[1] = conversions[\"USVString\"](args[1], {\n    context: \"Failed to execute 'set' on 'URLSearchParams': parameter 2\"\n  });\n  return this[impl].set(...args);\n};\nURLSearchParams.prototype.sort = function sort() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this[impl].sort();\n};\nURLSearchParams.prototype.toString = function toString() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return this[impl].toString();\n};\nURLSearchParams.prototype.entries = URLSearchParams.prototype[Symbol.iterator];\nURLSearchParams.prototype.keys = function keys() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return module.exports.createDefaultIterator(this, \"key\");\n};\nURLSearchParams.prototype.values = function values() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return module.exports.createDefaultIterator(this, \"value\");\n};\nObject.defineProperty(URLSearchParams.prototype, Symbol.toStringTag, {\n  value: \"URLSearchParams\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj) {\n    let {\n      context = \"The provided value\"\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'URLSearchParams'.`);\n  },\n  createDefaultIterator(target, kind) {\n    const iterator = Object.create(IteratorPrototype);\n    Object.defineProperty(iterator, utils.iterInternalSymbol, {\n      value: {\n        target,\n        kind,\n        index: 0\n      },\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    return iterator;\n  },\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URLSearchParams.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(URLSearchParams.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {},\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n    privateData.wrapper = obj;\n    this._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n  interface: URLSearchParams,\n  expose: {\n    Window: {\n      URLSearchParams\n    },\n    Worker: {\n      URLSearchParams\n    }\n  }\n}; // iface\nmodule.exports = iface;\nconst Impl = require(\".//URLSearchParams-impl.js\");","map":{"version":3,"names":["conversions","require","utils","impl","implSymbol","IteratorPrototype","Object","create","next","value","internal","iterInternalSymbol","target","kind","index","values","Array","from","len","length","undefined","done","pair","key","map","tryWrapperForImpl","result","writable","enumerable","configurable","Symbol","toStringTag","URLSearchParams","args","i","arguments","isObject","iterator","TypeError","V","tmp","nextItem","context","push","Reflect","ownKeys","desc","getOwnPropertyDescriptor","typedKey","typedValue","iface","setup","defineProperty","prototype","entries","module","exports","is","createDefaultIterator","forEach","callback","thisArg","pairs","call","append","name","delete","_","get","getAll","has","set","sort","toString","keys","mixedInto","obj","Impl","implementation","isImpl","wrapper","wrapperForImpl","convert","implForWrapper","constructorArgs","privateData","createImpl","_internalSetup","wrapperSymbol","init","interface","expose","Window","Worker"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/whatwg-url/lib/URLSearchParams.js"],"sourcesContent":["\"use strict\";\n\nconst conversions = require(\"webidl-conversions\");\nconst utils = require(\"./utils.js\");\n\nconst impl = utils.implSymbol;\n\nconst IteratorPrototype = Object.create(utils.IteratorPrototype, {\n  next: {\n    value: function next() {\n      const internal = this[utils.iterInternalSymbol];\n      const { target, kind, index } = internal;\n      const values = Array.from(target[impl]);\n      const len = values.length;\n      if (index >= len) {\n        return { value: undefined, done: true };\n      }\n\n      const pair = values[index];\n      internal.index = index + 1;\n      const [key, value] = pair.map(utils.tryWrapperForImpl);\n\n      let result;\n      switch (kind) {\n        case \"key\":\n          result = key;\n          break;\n        case \"value\":\n          result = value;\n          break;\n        case \"key+value\":\n          result = [key, value];\n          break;\n      }\n      return { value: result, done: false };\n    },\n    writable: true,\n    enumerable: true,\n    configurable: true\n  },\n  [Symbol.toStringTag]: {\n    value: \"URLSearchParamsIterator\",\n    writable: false,\n    enumerable: false,\n    configurable: true\n  }\n});\n\nfunction URLSearchParams() {\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n\n  if (args[0] !== undefined) {\n    if (utils.isObject(args[0])) {\n      if (args[0][Symbol.iterator] !== undefined) {\n        if (!utils.isObject(args[0])) {\n          throw new TypeError(\n            \"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \" is not an iterable object.\"\n          );\n        } else {\n          const V = [];\n          const tmp = args[0];\n          for (let nextItem of tmp) {\n            if (!utils.isObject(nextItem)) {\n              throw new TypeError(\n                \"Failed to construct 'URLSearchParams': parameter 1\" +\n                  \" sequence\" +\n                  \"'s element\" +\n                  \" is not an iterable object.\"\n              );\n            } else {\n              const V = [];\n              const tmp = nextItem;\n              for (let nextItem of tmp) {\n                nextItem = conversions[\"USVString\"](nextItem, {\n                  context:\n                    \"Failed to construct 'URLSearchParams': parameter 1\" + \" sequence\" + \"'s element\" + \"'s element\"\n                });\n\n                V.push(nextItem);\n              }\n              nextItem = V;\n            }\n\n            V.push(nextItem);\n          }\n          args[0] = V;\n        }\n      } else {\n        if (!utils.isObject(args[0])) {\n          throw new TypeError(\"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \" is not an object.\");\n        } else {\n          const result = Object.create(null);\n          for (const key of Reflect.ownKeys(args[0])) {\n            const desc = Object.getOwnPropertyDescriptor(args[0], key);\n            if (desc && desc.enumerable) {\n              let typedKey = key;\n              let typedValue = args[0][key];\n\n              typedKey = conversions[\"USVString\"](typedKey, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s key\"\n              });\n\n              typedValue = conversions[\"USVString\"](typedValue, {\n                context: \"Failed to construct 'URLSearchParams': parameter 1\" + \" record\" + \"'s value\"\n              });\n\n              result[typedKey] = typedValue;\n            }\n          }\n          args[0] = result;\n        }\n      }\n    } else {\n      args[0] = conversions[\"USVString\"](args[0], { context: \"Failed to construct 'URLSearchParams': parameter 1\" });\n    }\n  } else {\n    args[0] = \"\";\n  }\n\n  iface.setup(this, args);\n}\n\nObject.defineProperty(URLSearchParams, \"prototype\", {\n  value: URLSearchParams.prototype,\n  writable: false,\n  enumerable: false,\n  configurable: false\n});\n\nObject.defineProperty(URLSearchParams.prototype, Symbol.iterator, {\n  writable: true,\n  enumerable: false,\n  configurable: true,\n  value: function entries() {\n    if (!this || !module.exports.is(this)) {\n      throw new TypeError(\"Illegal invocation\");\n    }\n    return module.exports.createDefaultIterator(this, \"key+value\");\n  }\n});\nURLSearchParams.prototype.forEach = function forEach(callback) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'forEach' on 'URLSearchParams': 1 argument required, \" + \"but only 0 present.\"\n    );\n  }\n  if (typeof callback !== \"function\") {\n    throw new TypeError(\n      \"Failed to execute 'forEach' on 'URLSearchParams': The callback provided \" + \"as parameter 1 is not a function.\"\n    );\n  }\n  const thisArg = arguments[1];\n  let pairs = Array.from(this[impl]);\n  let i = 0;\n  while (i < pairs.length) {\n    const [key, value] = pairs[i].map(utils.tryWrapperForImpl);\n    callback.call(thisArg, value, key, this);\n    pairs = Array.from(this[impl]);\n    i++;\n  }\n};\nURLSearchParams.prototype.append = function append(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 2) {\n    throw new TypeError(\n      \"Failed to execute 'append' on 'URLSearchParams': 2 \" +\n        \"arguments required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'append' on 'URLSearchParams': parameter 1\"\n  });\n\n  args[1] = conversions[\"USVString\"](args[1], {\n    context: \"Failed to execute 'append' on 'URLSearchParams': parameter 2\"\n  });\n\n  return this[impl].append(...args);\n};\n\nURLSearchParams.prototype.delete = function _(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'delete' on 'URLSearchParams': 1 \" +\n        \"argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'delete' on 'URLSearchParams': parameter 1\"\n  });\n\n  return this[impl].delete(...args);\n};\n\nURLSearchParams.prototype.get = function get(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'get' on 'URLSearchParams': 1 \" +\n        \"argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], { context: \"Failed to execute 'get' on 'URLSearchParams': parameter 1\" });\n\n  return this[impl].get(...args);\n};\n\nURLSearchParams.prototype.getAll = function getAll(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'getAll' on 'URLSearchParams': 1 \" +\n        \"argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], {\n    context: \"Failed to execute 'getAll' on 'URLSearchParams': parameter 1\"\n  });\n\n  return utils.tryWrapperForImpl(this[impl].getAll(...args));\n};\n\nURLSearchParams.prototype.has = function has(name) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 1) {\n    throw new TypeError(\n      \"Failed to execute 'has' on 'URLSearchParams': 1 \" +\n        \"argument required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 1; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], { context: \"Failed to execute 'has' on 'URLSearchParams': parameter 1\" });\n\n  return this[impl].has(...args);\n};\n\nURLSearchParams.prototype.set = function set(name, value) {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  if (arguments.length < 2) {\n    throw new TypeError(\n      \"Failed to execute 'set' on 'URLSearchParams': 2 \" +\n        \"arguments required, but only \" +\n        arguments.length +\n        \" present.\"\n    );\n  }\n\n  const args = [];\n  for (let i = 0; i < arguments.length && i < 2; ++i) {\n    args[i] = arguments[i];\n  }\n\n  args[0] = conversions[\"USVString\"](args[0], { context: \"Failed to execute 'set' on 'URLSearchParams': parameter 1\" });\n\n  args[1] = conversions[\"USVString\"](args[1], { context: \"Failed to execute 'set' on 'URLSearchParams': parameter 2\" });\n\n  return this[impl].set(...args);\n};\n\nURLSearchParams.prototype.sort = function sort() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  return this[impl].sort();\n};\n\nURLSearchParams.prototype.toString = function toString() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n\n  return this[impl].toString();\n};\n\nURLSearchParams.prototype.entries = URLSearchParams.prototype[Symbol.iterator];\n\nURLSearchParams.prototype.keys = function keys() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return module.exports.createDefaultIterator(this, \"key\");\n};\n\nURLSearchParams.prototype.values = function values() {\n  if (!this || !module.exports.is(this)) {\n    throw new TypeError(\"Illegal invocation\");\n  }\n  return module.exports.createDefaultIterator(this, \"value\");\n};\n\nObject.defineProperty(URLSearchParams.prototype, Symbol.toStringTag, {\n  value: \"URLSearchParams\",\n  writable: false,\n  enumerable: false,\n  configurable: true\n});\n\nconst iface = {\n  mixedInto: [],\n  is(obj) {\n    if (obj) {\n      if (obj[impl] instanceof Impl.implementation) {\n        return true;\n      }\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (obj instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  isImpl(obj) {\n    if (obj) {\n      if (obj instanceof Impl.implementation) {\n        return true;\n      }\n\n      const wrapper = utils.wrapperForImpl(obj);\n      for (let i = 0; i < module.exports.mixedInto.length; ++i) {\n        if (wrapper instanceof module.exports.mixedInto[i]) {\n          return true;\n        }\n      }\n    }\n    return false;\n  },\n  convert(obj, { context = \"The provided value\" } = {}) {\n    if (module.exports.is(obj)) {\n      return utils.implForWrapper(obj);\n    }\n    throw new TypeError(`${context} is not of type 'URLSearchParams'.`);\n  },\n\n  createDefaultIterator(target, kind) {\n    const iterator = Object.create(IteratorPrototype);\n    Object.defineProperty(iterator, utils.iterInternalSymbol, {\n      value: { target, kind, index: 0 },\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n    return iterator;\n  },\n\n  create(constructorArgs, privateData) {\n    let obj = Object.create(URLSearchParams.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return obj;\n  },\n  createImpl(constructorArgs, privateData) {\n    let obj = Object.create(URLSearchParams.prototype);\n    obj = this.setup(obj, constructorArgs, privateData);\n    return utils.implForWrapper(obj);\n  },\n  _internalSetup(obj) {},\n  setup(obj, constructorArgs, privateData) {\n    if (!privateData) privateData = {};\n\n    privateData.wrapper = obj;\n\n    this._internalSetup(obj);\n    Object.defineProperty(obj, impl, {\n      value: new Impl.implementation(constructorArgs, privateData),\n      writable: false,\n      enumerable: false,\n      configurable: true\n    });\n\n    obj[impl][utils.wrapperSymbol] = obj;\n    if (Impl.init) {\n      Impl.init(obj[impl], privateData);\n    }\n    return obj;\n  },\n  interface: URLSearchParams,\n  expose: {\n    Window: { URLSearchParams },\n    Worker: { URLSearchParams }\n  }\n}; // iface\nmodule.exports = iface;\n\nconst Impl = require(\".//URLSearchParams-impl.js\");\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}