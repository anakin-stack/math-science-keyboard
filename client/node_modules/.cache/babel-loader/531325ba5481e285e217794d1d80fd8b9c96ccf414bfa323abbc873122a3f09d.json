{"ast":null,"code":"\"use strict\";\n\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n    this._historyTraversalQueue.add(timeoutId);\n  }\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n  get length() {\n    return this._entries.length;\n  }\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry) {\n    let flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n    const document = idlUtils.implForWrapper(this._window._document);\n    const {\n      currentEntry\n    } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n    document._URL = specifiedEntry.url;\n    const hashChanged = specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n    this.updateCurrentEntry(specifiedEntry);\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\"popstate\", {\n        bubbles: false,\n        state\n      }], {\n        isTrusted: true\n      }));\n    }\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\"hashchange\", {\n        bubbles: false,\n        oldURL: whatwgURL.serializeURL(oldURL),\n        newURL: whatwgURL.serializeURL(newURL)\n      }], {\n        isTrusted: true\n      }));\n    }\n  }\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;","map":{"version":3,"names":["whatwgURL","require","HashChangeEvent","PopStateEvent","notImplemented","idlUtils","SessionHistory","constructor","initialEntry","window","_window","_windowImpl","implForWrapper","_historyTraversalQueue","Set","_entries","_currentIndex","_queueHistoryTraversalTask","fn","timeoutId","setTimeout","delete","add","clearHistoryTraversalTasks","clearTimeout","clear","length","currentEntry","removeAllEntriesAfterCurrentEntry","splice","Infinity","traverseByDelta","delta","newIndex","specifiedEntry","document","traverseHistory","flags","arguments","undefined","nonBlockingEvents","Boolean","_document","title","_URL","url","hashChanged","fragment","oldURL","newURL","replacement","indexOf","updateCurrentEntry","state","stateObject","_history","_state","stateChanged","_latestEntry","fireEvents","_fireEvents","_dispatch","createImpl","bubbles","isTrusted","serializeURL","addEntryAfterCurrentEntry","entry","module","exports"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/living/window/SessionHistory.js"],"sourcesContent":["\"use strict\";\nconst whatwgURL = require(\"whatwg-url\");\nconst HashChangeEvent = require(\"../generated/HashChangeEvent.js\");\nconst PopStateEvent = require(\"../generated/PopStateEvent.js\");\nconst notImplemented = require(\"../../browser/not-implemented.js\");\nconst idlUtils = require(\"../generated/utils.js\");\n\n// https://html.spec.whatwg.org/#session-history\nclass SessionHistory {\n  constructor(initialEntry, window) {\n    this._window = window;\n    this._windowImpl = idlUtils.implForWrapper(window);\n    this._historyTraversalQueue = new Set();\n    this._entries = [initialEntry];\n    this._currentIndex = 0;\n  }\n\n  _queueHistoryTraversalTask(fn) {\n    const timeoutId = this._window.setTimeout(() => {\n      this._historyTraversalQueue.delete(timeoutId);\n      fn();\n    }, 0);\n\n    this._historyTraversalQueue.add(timeoutId);\n  }\n\n  clearHistoryTraversalTasks() {\n    for (const timeoutId of this._historyTraversalQueue) {\n      this._window.clearTimeout(timeoutId);\n    }\n    this._historyTraversalQueue.clear();\n  }\n\n  get length() {\n    return this._entries.length;\n  }\n\n  get currentEntry() {\n    return this._entries[this._currentIndex];\n  }\n\n  // https://html.spec.whatwg.org/#dom-history-pushstate\n  removeAllEntriesAfterCurrentEntry() {\n    this._entries.splice(this._currentIndex + 1, Infinity);\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history-by-a-delta\n  traverseByDelta(delta) {\n    this._queueHistoryTraversalTask(() => {\n      const newIndex = this._currentIndex + delta;\n      if (newIndex < 0 || newIndex >= this.length) {\n        return;\n      }\n\n      const specifiedEntry = this._entries[newIndex];\n\n      // Not implemented: unload a document guard\n\n      // Not clear that this should be queued. html/browsers/history/the-history-interface/004.html can be fixed\n      // by removing the queue, but doing so breaks some tests in history.js that also pass in browsers.\n      this._queueHistoryTraversalTask(() => {\n        // If there is an ongoing attempt to navigate specified browsing context that has not yet matured,\n        // then cancel that attempt to navigate the browsing context.\n\n        // Doing this seems to break tests involving navigating via push/pop state and via fragments. I think this\n        // is because these navigations should already count as having \"matured\" because the document is not changing.\n\n        // this.clearHistoryTraversalTasks();\n\n        if (specifiedEntry.document !== this.currentEntry.document) {\n          // TODO: unload the active document with the recycle parameter set to false\n          notImplemented(\"Traversing history in a way that would change the window\", this._window);\n        }\n        this.traverseHistory(specifiedEntry);\n      });\n    });\n  }\n\n  // https://html.spec.whatwg.org/#traverse-the-history\n  traverseHistory(specifiedEntry, flags = {}) {\n    if (!specifiedEntry.document) {\n      // If entry no longer holds a Document object, then navigate the browsing context to entry's URL\n      // to perform an entry update of entry, and abort these steps\n      notImplemented(\"Traversing the history to an entry that no longer holds a Document object\", this._window);\n    }\n    // Not spec compliant, just minimal. Lots of missing steps.\n\n    const nonBlockingEvents = Boolean(flags.nonBlockingEvents);\n\n    const document = idlUtils.implForWrapper(this._window._document);\n\n    const { currentEntry } = this;\n\n    // If the current entry's title was not set by the pushState() or replaceState() methods, then set its title\n    // to the value returned by the document.title IDL attribute.\n    if (currentEntry.title === undefined) {\n      currentEntry.title = document.title;\n    }\n\n\n    if (specifiedEntry.document !== currentEntry.document) {\n      // If entry has a different Document object than the current entry, then...\n      notImplemented(\"Traversing the history to an entry with a different Document\", this._window);\n    }\n\n    document._URL = specifiedEntry.url;\n\n    const hashChanged =\n      specifiedEntry.url.fragment !== currentEntry.url.fragment && specifiedEntry.document === currentEntry.document;\n    let oldURL;\n    let newURL;\n    if (hashChanged) {\n      oldURL = currentEntry.url;\n      newURL = specifiedEntry.url;\n    }\n\n    if (flags.replacement) {\n      // If the traversal was initiated with replacement enabled, remove the entry immediately before the\n      // specified entry in the session history.\n      this._entries.splice(this._entries.indexOf(specifiedEntry) - 1, 1);\n    }\n\n    this.updateCurrentEntry(specifiedEntry);\n\n    const state = specifiedEntry.stateObject; // TODO structured clone\n\n    // arguably it's a bit odd that the state and latestEntry do not belong to the SessionHistory\n    // but the spec gives them to \"History\" and \"Document\" respecively.\n    document._history._state = state;\n    const stateChanged = specifiedEntry.document._latestEntry !== specifiedEntry;\n    specifiedEntry.document._latestEntry = specifiedEntry;\n\n    const fireEvents = () => this._fireEvents(stateChanged, hashChanged, state, oldURL, newURL);\n\n    if (nonBlockingEvents) {\n      this._window.setTimeout(fireEvents, 0);\n    } else {\n      fireEvents();\n    }\n  }\n\n  _fireEvents(stateChanged, hashChanged, state, oldURL, newURL) {\n    if (stateChanged) {\n      this._windowImpl._dispatch(PopStateEvent.createImpl([\n        \"popstate\",\n        {\n          bubbles: false,\n          state\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n\n    if (hashChanged) {\n      this._windowImpl._dispatch(HashChangeEvent.createImpl([\n        \"hashchange\",\n        {\n          bubbles: false,\n          oldURL: whatwgURL.serializeURL(oldURL),\n          newURL: whatwgURL.serializeURL(newURL)\n        }\n      ], {\n        isTrusted: true\n      }));\n    }\n  }\n\n  addEntryAfterCurrentEntry(entry) {\n    this._entries.splice(this._currentIndex + 1, 0, entry);\n  }\n\n  updateCurrentEntry(entry) {\n    this._currentIndex = this._entries.indexOf(entry);\n  }\n}\nmodule.exports = SessionHistory;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}