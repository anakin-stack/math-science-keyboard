{"ast":null,"code":"// freeze Array#slice, just in case of funny business later.\nvar _slice = Array.prototype.slice;\nvar getPromise = require('./_promise.js');\n\n// deferred gets its own scope to prevent inadvertent capture in the closure\nvar deferred = function (options) {\n  var Promise = getPromise();\n  var resolve,\n    reject,\n    p = new Promise(function (_resolve, _reject) {\n      resolve = _resolve;\n      reject = _reject;\n    });\n  var pattern = options && options.pattern;\n  var noError = options && options.noError;\n  var cb = pattern ? function (err) {\n    if (err && !noError) {\n      return reject(err);\n    }\n    var result = {},\n      i,\n      offset = noError ? 0 : 1;\n    for (i = 0; i < pattern.length; i++) {\n      result[pattern[i]] = arguments[i + offset];\n    }\n    resolve(result);\n  } : noError ? resolve : function (err, val) {\n    if (err) {\n      reject(err);\n    } else {\n      resolve(val);\n    }\n  };\n  return {\n    promise: p,\n    callback: cb\n  };\n};\nvar promisify = module.exports = function (context, func, mandatoryArgs, options) {\n  if (options && options.callbackIsFirstArg) {\n    // duplicate some code here so we don't have to process this unusual\n    // situation at runtime in the common case.\n    return function (cb) {\n      if (typeof cb === 'function') {\n        return func.apply(context, arguments);\n      }\n      var d = deferred(options);\n      var a = _slice.call(arguments, 0);\n      a.unshift(d.callback);\n      func.apply(context, a);\n      return d.promise;\n    };\n  }\n  return function () {\n    var cb = arguments[arguments.length - 1];\n    if (typeof cb === 'function') {\n      return func.apply(context, arguments);\n    }\n    // ooh, promises.\n    var d = deferred(options);\n    var a = _slice.call(arguments, 0);\n    while (a.length < mandatoryArgs) {\n      a.push(undefined);\n    }\n    a.push(d.callback);\n    var retval = func.apply(context, a);\n    if (options && options.returnsObject) {\n      // it would be nice to have a better convention here\n      Object.defineProperty(retval, 'promise', {\n        value: d.promise\n      });\n      return retval;\n    }\n    return d.promise;\n  };\n};","map":{"version":3,"names":["_slice","Array","prototype","slice","getPromise","require","deferred","options","Promise","resolve","reject","p","_resolve","_reject","pattern","noError","cb","err","result","i","offset","length","arguments","val","promise","callback","promisify","module","exports","context","func","mandatoryArgs","callbackIsFirstArg","apply","d","a","call","unshift","push","undefined","retval","returnsObject","Object","defineProperty","value"],"sources":["G:/scientificKeyboard/keyboard/node_modules/pn/_promisify.js"],"sourcesContent":["// freeze Array#slice, just in case of funny business later.\nvar _slice = Array.prototype.slice;\nvar getPromise = require('./_promise.js');\n\n// deferred gets its own scope to prevent inadvertent capture in the closure\nvar deferred = function(options) {\n    var Promise = getPromise();\n    var resolve, reject, p = new Promise(function(_resolve, _reject) {\n        resolve = _resolve; reject = _reject;\n    });\n    var pattern = (options && options.pattern);\n    var noError = (options && options.noError);\n    var cb = pattern ? function(err) {\n        if (err && !noError) { return reject(err); }\n        var result = {}, i, offset = noError ? 0 : 1;\n        for (i = 0; i < pattern.length; i++) {\n            result[pattern[i]] = arguments[i+offset];\n        }\n        resolve(result);\n    } : noError ? resolve : function(err, val) {\n        if (err) { reject(err); } else { resolve(val); }\n    };\n    return { promise: p, callback: cb };\n};\nvar promisify = module.exports = function(context, func, mandatoryArgs, options) {\n    if (options && options.callbackIsFirstArg) {\n        // duplicate some code here so we don't have to process this unusual\n        // situation at runtime in the common case.\n        return function(cb) {\n            if (typeof(cb) === 'function') {\n                return func.apply(context, arguments);\n            }\n            var d = deferred(options);\n            var a = _slice.call(arguments, 0);\n            a.unshift(d.callback);\n            func.apply(context, a);\n            return d.promise;\n        };\n    }\n    return function() {\n        var cb = arguments[arguments.length - 1];\n        if (typeof(cb) === 'function') {\n            return func.apply(context, arguments);\n        }\n        // ooh, promises.\n        var d = deferred(options);\n        var a = _slice.call(arguments, 0);\n        while (a.length < mandatoryArgs) { a.push(undefined); }\n        a.push(d.callback);\n        var retval = func.apply(context, a);\n        if (options && options.returnsObject) {\n            // it would be nice to have a better convention here\n            Object.defineProperty(retval, 'promise', { value: d.promise });\n            return retval;\n        }\n        return d.promise;\n    };\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}