{"ast":null,"code":"\"use strict\";\n\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../living/generated/DocumentFragment\");\nconst Text = require(\"../living/generated/Text\");\nconst Comment = require(\"../living/generated/Comment\");\nconst attributes = require(\"../living/attributes\");\nconst nodeTypes = require(\"../living/node-type\");\nconst serializationAdapter = require(\"./parse5-adapter-serialization\");\nmodule.exports = class JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n  }\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], {\n      ownerDocument: this._documentImpl\n    });\n  }\n  createElement(localName, namespace, attrs) {\n    const element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n    return element;\n  }\n  createCommentNode(data) {\n    return Comment.createImpl([], {\n      data,\n      ownerDocument: this._documentImpl\n    });\n  }\n  appendChild(parentNode, newNode) {\n    parentNode.appendChild(newNode);\n  }\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n  setTemplateContent(templateElement, contentFragment) {\n    templateElement._templateContents = contentFragment;\n  }\n  setDocumentType(document, name, publicId, systemId) {\n    // parse5 sometimes gives us these as null.\n    if (name === null) {\n      name = \"\";\n    }\n    if (publicId === null) {\n      publicId = \"\";\n    }\n    if (systemId === null) {\n      systemId = \"\";\n    }\n    const documentType = DocumentType.createImpl([], {\n      name,\n      publicId,\n      systemId,\n      ownerDocument: this._documentImpl\n    });\n    document.appendChild(documentType);\n  }\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n  detachNode(node) {\n    node.remove();\n  }\n  insertText(parentNode, text) {\n    const {\n      lastChild\n    } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.appendChild(textNode);\n    }\n  }\n  insertTextBefore(parentNode, text, referenceNode) {\n    const {\n      previousSibling\n    } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const textNode = Text.createImpl([], {\n        data: text,\n        ownerDocument: this._documentImpl\n      });\n      parentNode.insertBefore(textNode, referenceNode);\n    }\n  }\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n};\nObject.assign(module.exports.prototype, serializationAdapter);","map":{"version":3,"names":["DocumentType","require","DocumentFragment","Text","Comment","attributes","nodeTypes","serializationAdapter","module","exports","JSDOMParse5Adapter","constructor","documentImpl","_documentImpl","createDocument","createDocumentFragment","createImpl","ownerDocument","createElement","localName","namespace","attrs","element","_createElementWithCorrectElementInterface","_namespaceURI","adoptAttributes","_parserInserted","createCommentNode","data","appendChild","parentNode","newNode","insertBefore","referenceNode","setTemplateContent","templateElement","contentFragment","_templateContents","setDocumentType","document","name","publicId","systemId","documentType","setDocumentMode","mode","_mode","detachNode","node","remove","insertText","text","lastChild","nodeType","TEXT_NODE","textNode","insertTextBefore","previousSibling","attr","prefix","setAttributeValue","value","Object","assign","prototype"],"sources":["G:/scientificKeyboard/keyboard/node_modules/mathjax-node/node_modules/jsdom/lib/jsdom/browser/parse5-adapter-parsing.js"],"sourcesContent":["\"use strict\";\nconst DocumentType = require(\"../living/generated/DocumentType\");\nconst DocumentFragment = require(\"../living/generated/DocumentFragment\");\nconst Text = require(\"../living/generated/Text\");\nconst Comment = require(\"../living/generated/Comment\");\nconst attributes = require(\"../living/attributes\");\nconst nodeTypes = require(\"../living/node-type\");\nconst serializationAdapter = require(\"./parse5-adapter-serialization\");\n\nmodule.exports = class JSDOMParse5Adapter {\n  constructor(documentImpl) {\n    this._documentImpl = documentImpl;\n  }\n\n  createDocument() {\n    // parse5's model assumes that parse(html) will call into here to create the new Document, then return it. However,\n    // jsdom's model assumes we can create a Window (and through that create an empty Document), do some other setup\n    // stuff, and then parse, stuffing nodes into that Document as we go. So to adapt between these two models, we just\n    // return the already-created Document when asked by parse5 to \"create\" a Document.\n    return this._documentImpl;\n  }\n\n  createDocumentFragment() {\n    return DocumentFragment.createImpl([], { ownerDocument: this._documentImpl });\n  }\n\n  createElement(localName, namespace, attrs) {\n    const element = this._documentImpl._createElementWithCorrectElementInterface(localName, namespace);\n    element._namespaceURI = namespace;\n    this.adoptAttributes(element, attrs);\n\n    if (\"_parserInserted\" in element) {\n      element._parserInserted = true;\n    }\n\n    return element;\n  }\n\n  createCommentNode(data) {\n    return Comment.createImpl([], { data, ownerDocument: this._documentImpl });\n  }\n\n  appendChild(parentNode, newNode) {\n    parentNode.appendChild(newNode);\n  }\n\n  insertBefore(parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  setTemplateContent(templateElement, contentFragment) {\n    templateElement._templateContents = contentFragment;\n  }\n\n  setDocumentType(document, name, publicId, systemId) {\n    // parse5 sometimes gives us these as null.\n    if (name === null) {\n      name = \"\";\n    }\n    if (publicId === null) {\n      publicId = \"\";\n    }\n    if (systemId === null) {\n      systemId = \"\";\n    }\n\n    const documentType = DocumentType.createImpl([], { name, publicId, systemId, ownerDocument: this._documentImpl });\n    document.appendChild(documentType);\n  }\n\n  setDocumentMode(document, mode) {\n    // TODO: the rest of jsdom ignores this\n    document._mode = mode;\n  }\n\n  detachNode(node) {\n    node.remove();\n  }\n\n  insertText(parentNode, text) {\n    const { lastChild } = parentNode;\n    if (lastChild && lastChild.nodeType === nodeTypes.TEXT_NODE) {\n      lastChild.data += text;\n    } else {\n      const textNode = Text.createImpl([], { data: text, ownerDocument: this._documentImpl });\n\n      parentNode.appendChild(textNode);\n    }\n  }\n\n  insertTextBefore(parentNode, text, referenceNode) {\n    const { previousSibling } = referenceNode;\n    if (previousSibling && previousSibling.nodeType === nodeTypes.TEXT_NODE) {\n      previousSibling.data += text;\n    } else {\n      const textNode = Text.createImpl([], { data: text, ownerDocument: this._documentImpl });\n\n      parentNode.insertBefore(textNode, referenceNode);\n    }\n  }\n\n  adoptAttributes(element, attrs) {\n    for (const attr of attrs) {\n      const prefix = attr.prefix === \"\" ? null : attr.prefix;\n      attributes.setAttributeValue(element, attr.name, attr.value, prefix, attr.namespace);\n    }\n  }\n};\n\nObject.assign(module.exports.prototype, serializationAdapter);\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}